
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ClientProfile
 * 
 */
export type ClientProfile = $Result.DefaultSelection<Prisma.$ClientProfilePayload>
/**
 * Model PswProfile
 * 
 */
export type PswProfile = $Result.DefaultSelection<Prisma.$PswProfilePayload>
/**
 * Model Visit
 * 
 */
export type Visit = $Result.DefaultSelection<Prisma.$VisitPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model VisitCheckEvent
 * 
 */
export type VisitCheckEvent = $Result.DefaultSelection<Prisma.$VisitCheckEventPayload>
/**
 * Model VisitNote
 * 
 */
export type VisitNote = $Result.DefaultSelection<Prisma.$VisitNotePayload>
/**
 * Model VisitChecklist
 * 
 */
export type VisitChecklist = $Result.DefaultSelection<Prisma.$VisitChecklistPayload>
/**
 * Model Incident
 * 
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model Timesheet
 * 
 */
export type Timesheet = $Result.DefaultSelection<Prisma.$TimesheetPayload>
/**
 * Model TimesheetItem
 * 
 */
export type TimesheetItem = $Result.DefaultSelection<Prisma.$TimesheetItemPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model MessageThread
 * 
 */
export type MessageThread = $Result.DefaultSelection<Prisma.$MessageThreadPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model PswDocument
 * 
 */
export type PswDocument = $Result.DefaultSelection<Prisma.$PswDocumentPayload>
/**
 * Model FAQ
 * 
 */
export type FAQ = $Result.DefaultSelection<Prisma.$FAQPayload>
/**
 * Model DailyEntry
 * 
 */
export type DailyEntry = $Result.DefaultSelection<Prisma.$DailyEntryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  manager: 'manager',
  client: 'client',
  psw: 'psw',
  coordinator: 'coordinator',
  staff: 'staff',
  admin: 'admin',
  finance: 'finance'
};

export type Role = (typeof Role)[keyof typeof Role]


export const VisitStatus: {
  requested: 'requested',
  scheduled: 'scheduled',
  assigned: 'assigned',
  en_route: 'en_route',
  arrived: 'arrived',
  in_progress: 'in_progress',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type VisitStatus = (typeof VisitStatus)[keyof typeof VisitStatus]


export const EventType: {
  check_in: 'check_in',
  check_out: 'check_out'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const EventResult: {
  success: 'success',
  rejected: 'rejected'
};

export type EventResult = (typeof EventResult)[keyof typeof EventResult]


export const IncidentType: {
  fall_risk: 'fall_risk',
  refusal: 'refusal',
  no_show: 'no_show',
  safety: 'safety',
  other: 'other'
};

export type IncidentType = (typeof IncidentType)[keyof typeof IncidentType]


export const IncidentStatus: {
  open: 'open',
  investigating: 'investigating',
  resolved: 'resolved'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const TimesheetStatus: {
  draft: 'draft',
  submitted: 'submitted',
  approved: 'approved',
  rejected: 'rejected'
};

export type TimesheetStatus = (typeof TimesheetStatus)[keyof typeof TimesheetStatus]


export const InvoiceStatus: {
  draft: 'draft',
  unpaid: 'unpaid',
  paid: 'paid',
  void: 'void'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const DocStatus: {
  pending: 'pending',
  verified: 'verified',
  rejected: 'rejected'
};

export type DocStatus = (typeof DocStatus)[keyof typeof DocStatus]


export const DailyEntryStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED'
};

export type DailyEntryStatus = (typeof DailyEntryStatus)[keyof typeof DailyEntryStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type VisitStatus = $Enums.VisitStatus

export const VisitStatus: typeof $Enums.VisitStatus

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type EventResult = $Enums.EventResult

export const EventResult: typeof $Enums.EventResult

export type IncidentType = $Enums.IncidentType

export const IncidentType: typeof $Enums.IncidentType

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type TimesheetStatus = $Enums.TimesheetStatus

export const TimesheetStatus: typeof $Enums.TimesheetStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type DocStatus = $Enums.DocStatus

export const DocStatus: typeof $Enums.DocStatus

export type DailyEntryStatus = $Enums.DailyEntryStatus

export const DailyEntryStatus: typeof $Enums.DailyEntryStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.clientProfile`: Exposes CRUD operations for the **ClientProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientProfiles
    * const clientProfiles = await prisma.clientProfile.findMany()
    * ```
    */
  get clientProfile(): Prisma.ClientProfileDelegate<ExtArgs>;

  /**
   * `prisma.pswProfile`: Exposes CRUD operations for the **PswProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PswProfiles
    * const pswProfiles = await prisma.pswProfile.findMany()
    * ```
    */
  get pswProfile(): Prisma.PswProfileDelegate<ExtArgs>;

  /**
   * `prisma.visit`: Exposes CRUD operations for the **Visit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visits
    * const visits = await prisma.visit.findMany()
    * ```
    */
  get visit(): Prisma.VisitDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.visitCheckEvent`: Exposes CRUD operations for the **VisitCheckEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitCheckEvents
    * const visitCheckEvents = await prisma.visitCheckEvent.findMany()
    * ```
    */
  get visitCheckEvent(): Prisma.VisitCheckEventDelegate<ExtArgs>;

  /**
   * `prisma.visitNote`: Exposes CRUD operations for the **VisitNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitNotes
    * const visitNotes = await prisma.visitNote.findMany()
    * ```
    */
  get visitNote(): Prisma.VisitNoteDelegate<ExtArgs>;

  /**
   * `prisma.visitChecklist`: Exposes CRUD operations for the **VisitChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitChecklists
    * const visitChecklists = await prisma.visitChecklist.findMany()
    * ```
    */
  get visitChecklist(): Prisma.VisitChecklistDelegate<ExtArgs>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs>;

  /**
   * `prisma.timesheet`: Exposes CRUD operations for the **Timesheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timesheets
    * const timesheets = await prisma.timesheet.findMany()
    * ```
    */
  get timesheet(): Prisma.TimesheetDelegate<ExtArgs>;

  /**
   * `prisma.timesheetItem`: Exposes CRUD operations for the **TimesheetItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimesheetItems
    * const timesheetItems = await prisma.timesheetItem.findMany()
    * ```
    */
  get timesheetItem(): Prisma.TimesheetItemDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.messageThread`: Exposes CRUD operations for the **MessageThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageThreads
    * const messageThreads = await prisma.messageThread.findMany()
    * ```
    */
  get messageThread(): Prisma.MessageThreadDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs>;

  /**
   * `prisma.pswDocument`: Exposes CRUD operations for the **PswDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PswDocuments
    * const pswDocuments = await prisma.pswDocument.findMany()
    * ```
    */
  get pswDocument(): Prisma.PswDocumentDelegate<ExtArgs>;

  /**
   * `prisma.fAQ`: Exposes CRUD operations for the **FAQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQS
    * const fAQS = await prisma.fAQ.findMany()
    * ```
    */
  get fAQ(): Prisma.FAQDelegate<ExtArgs>;

  /**
   * `prisma.dailyEntry`: Exposes CRUD operations for the **DailyEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyEntries
    * const dailyEntries = await prisma.dailyEntry.findMany()
    * ```
    */
  get dailyEntry(): Prisma.DailyEntryDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ClientProfile: 'ClientProfile',
    PswProfile: 'PswProfile',
    Visit: 'Visit',
    Service: 'Service',
    VisitCheckEvent: 'VisitCheckEvent',
    VisitNote: 'VisitNote',
    VisitChecklist: 'VisitChecklist',
    Incident: 'Incident',
    Timesheet: 'Timesheet',
    TimesheetItem: 'TimesheetItem',
    Invoice: 'Invoice',
    Payment: 'Payment',
    MessageThread: 'MessageThread',
    Message: 'Message',
    AuditLog: 'AuditLog',
    Lead: 'Lead',
    BlogPost: 'BlogPost',
    PswDocument: 'PswDocument',
    FAQ: 'FAQ',
    DailyEntry: 'DailyEntry'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "clientProfile" | "pswProfile" | "visit" | "service" | "visitCheckEvent" | "visitNote" | "visitChecklist" | "incident" | "timesheet" | "timesheetItem" | "invoice" | "payment" | "messageThread" | "message" | "auditLog" | "lead" | "blogPost" | "pswDocument" | "fAQ" | "dailyEntry"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ClientProfile: {
        payload: Prisma.$ClientProfilePayload<ExtArgs>
        fields: Prisma.ClientProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findFirst: {
            args: Prisma.ClientProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findMany: {
            args: Prisma.ClientProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          create: {
            args: Prisma.ClientProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          createMany: {
            args: Prisma.ClientProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          delete: {
            args: Prisma.ClientProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          update: {
            args: Prisma.ClientProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          deleteMany: {
            args: Prisma.ClientProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          aggregate: {
            args: Prisma.ClientProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientProfile>
          }
          groupBy: {
            args: Prisma.ClientProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileCountAggregateOutputType> | number
          }
        }
      }
      PswProfile: {
        payload: Prisma.$PswProfilePayload<ExtArgs>
        fields: Prisma.PswProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PswProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PswProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload>
          }
          findFirst: {
            args: Prisma.PswProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PswProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload>
          }
          findMany: {
            args: Prisma.PswProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload>[]
          }
          create: {
            args: Prisma.PswProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload>
          }
          createMany: {
            args: Prisma.PswProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PswProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload>[]
          }
          delete: {
            args: Prisma.PswProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload>
          }
          update: {
            args: Prisma.PswProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload>
          }
          deleteMany: {
            args: Prisma.PswProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PswProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PswProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswProfilePayload>
          }
          aggregate: {
            args: Prisma.PswProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePswProfile>
          }
          groupBy: {
            args: Prisma.PswProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<PswProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.PswProfileCountArgs<ExtArgs>
            result: $Utils.Optional<PswProfileCountAggregateOutputType> | number
          }
        }
      }
      Visit: {
        payload: Prisma.$VisitPayload<ExtArgs>
        fields: Prisma.VisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          findFirst: {
            args: Prisma.VisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          findMany: {
            args: Prisma.VisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>[]
          }
          create: {
            args: Prisma.VisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          createMany: {
            args: Prisma.VisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>[]
          }
          delete: {
            args: Prisma.VisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          update: {
            args: Prisma.VisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          deleteMany: {
            args: Prisma.VisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitPayload>
          }
          aggregate: {
            args: Prisma.VisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisit>
          }
          groupBy: {
            args: Prisma.VisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitCountArgs<ExtArgs>
            result: $Utils.Optional<VisitCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      VisitCheckEvent: {
        payload: Prisma.$VisitCheckEventPayload<ExtArgs>
        fields: Prisma.VisitCheckEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitCheckEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitCheckEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload>
          }
          findFirst: {
            args: Prisma.VisitCheckEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitCheckEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload>
          }
          findMany: {
            args: Prisma.VisitCheckEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload>[]
          }
          create: {
            args: Prisma.VisitCheckEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload>
          }
          createMany: {
            args: Prisma.VisitCheckEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitCheckEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload>[]
          }
          delete: {
            args: Prisma.VisitCheckEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload>
          }
          update: {
            args: Prisma.VisitCheckEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload>
          }
          deleteMany: {
            args: Prisma.VisitCheckEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitCheckEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitCheckEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCheckEventPayload>
          }
          aggregate: {
            args: Prisma.VisitCheckEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitCheckEvent>
          }
          groupBy: {
            args: Prisma.VisitCheckEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitCheckEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitCheckEventCountArgs<ExtArgs>
            result: $Utils.Optional<VisitCheckEventCountAggregateOutputType> | number
          }
        }
      }
      VisitNote: {
        payload: Prisma.$VisitNotePayload<ExtArgs>
        fields: Prisma.VisitNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload>
          }
          findFirst: {
            args: Prisma.VisitNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload>
          }
          findMany: {
            args: Prisma.VisitNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload>[]
          }
          create: {
            args: Prisma.VisitNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload>
          }
          createMany: {
            args: Prisma.VisitNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload>[]
          }
          delete: {
            args: Prisma.VisitNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload>
          }
          update: {
            args: Prisma.VisitNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload>
          }
          deleteMany: {
            args: Prisma.VisitNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitNotePayload>
          }
          aggregate: {
            args: Prisma.VisitNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitNote>
          }
          groupBy: {
            args: Prisma.VisitNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitNoteCountArgs<ExtArgs>
            result: $Utils.Optional<VisitNoteCountAggregateOutputType> | number
          }
        }
      }
      VisitChecklist: {
        payload: Prisma.$VisitChecklistPayload<ExtArgs>
        fields: Prisma.VisitChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload>
          }
          findFirst: {
            args: Prisma.VisitChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload>
          }
          findMany: {
            args: Prisma.VisitChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload>[]
          }
          create: {
            args: Prisma.VisitChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload>
          }
          createMany: {
            args: Prisma.VisitChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload>[]
          }
          delete: {
            args: Prisma.VisitChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload>
          }
          update: {
            args: Prisma.VisitChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload>
          }
          deleteMany: {
            args: Prisma.VisitChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitChecklistPayload>
          }
          aggregate: {
            args: Prisma.VisitChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitChecklist>
          }
          groupBy: {
            args: Prisma.VisitChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<VisitChecklistCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      Timesheet: {
        payload: Prisma.$TimesheetPayload<ExtArgs>
        fields: Prisma.TimesheetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimesheetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimesheetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload>
          }
          findFirst: {
            args: Prisma.TimesheetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimesheetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload>
          }
          findMany: {
            args: Prisma.TimesheetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload>[]
          }
          create: {
            args: Prisma.TimesheetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload>
          }
          createMany: {
            args: Prisma.TimesheetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimesheetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload>[]
          }
          delete: {
            args: Prisma.TimesheetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload>
          }
          update: {
            args: Prisma.TimesheetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload>
          }
          deleteMany: {
            args: Prisma.TimesheetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimesheetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimesheetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetPayload>
          }
          aggregate: {
            args: Prisma.TimesheetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimesheet>
          }
          groupBy: {
            args: Prisma.TimesheetGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimesheetGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimesheetCountArgs<ExtArgs>
            result: $Utils.Optional<TimesheetCountAggregateOutputType> | number
          }
        }
      }
      TimesheetItem: {
        payload: Prisma.$TimesheetItemPayload<ExtArgs>
        fields: Prisma.TimesheetItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimesheetItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimesheetItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload>
          }
          findFirst: {
            args: Prisma.TimesheetItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimesheetItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload>
          }
          findMany: {
            args: Prisma.TimesheetItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload>[]
          }
          create: {
            args: Prisma.TimesheetItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload>
          }
          createMany: {
            args: Prisma.TimesheetItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimesheetItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload>[]
          }
          delete: {
            args: Prisma.TimesheetItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload>
          }
          update: {
            args: Prisma.TimesheetItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload>
          }
          deleteMany: {
            args: Prisma.TimesheetItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimesheetItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimesheetItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimesheetItemPayload>
          }
          aggregate: {
            args: Prisma.TimesheetItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimesheetItem>
          }
          groupBy: {
            args: Prisma.TimesheetItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimesheetItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimesheetItemCountArgs<ExtArgs>
            result: $Utils.Optional<TimesheetItemCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      MessageThread: {
        payload: Prisma.$MessageThreadPayload<ExtArgs>
        fields: Prisma.MessageThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          findFirst: {
            args: Prisma.MessageThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          findMany: {
            args: Prisma.MessageThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>[]
          }
          create: {
            args: Prisma.MessageThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          createMany: {
            args: Prisma.MessageThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>[]
          }
          delete: {
            args: Prisma.MessageThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          update: {
            args: Prisma.MessageThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          deleteMany: {
            args: Prisma.MessageThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          aggregate: {
            args: Prisma.MessageThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageThread>
          }
          groupBy: {
            args: Prisma.MessageThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageThreadCountArgs<ExtArgs>
            result: $Utils.Optional<MessageThreadCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      PswDocument: {
        payload: Prisma.$PswDocumentPayload<ExtArgs>
        fields: Prisma.PswDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PswDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PswDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload>
          }
          findFirst: {
            args: Prisma.PswDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PswDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload>
          }
          findMany: {
            args: Prisma.PswDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload>[]
          }
          create: {
            args: Prisma.PswDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload>
          }
          createMany: {
            args: Prisma.PswDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PswDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload>[]
          }
          delete: {
            args: Prisma.PswDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload>
          }
          update: {
            args: Prisma.PswDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload>
          }
          deleteMany: {
            args: Prisma.PswDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PswDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PswDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PswDocumentPayload>
          }
          aggregate: {
            args: Prisma.PswDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePswDocument>
          }
          groupBy: {
            args: Prisma.PswDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PswDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PswDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<PswDocumentCountAggregateOutputType> | number
          }
        }
      }
      FAQ: {
        payload: Prisma.$FAQPayload<ExtArgs>
        fields: Prisma.FAQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findFirst: {
            args: Prisma.FAQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findMany: {
            args: Prisma.FAQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          create: {
            args: Prisma.FAQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          createMany: {
            args: Prisma.FAQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          delete: {
            args: Prisma.FAQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          update: {
            args: Prisma.FAQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          deleteMany: {
            args: Prisma.FAQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FAQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          aggregate: {
            args: Prisma.FAQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQ>
          }
          groupBy: {
            args: Prisma.FAQGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQCountArgs<ExtArgs>
            result: $Utils.Optional<FAQCountAggregateOutputType> | number
          }
        }
      }
      DailyEntry: {
        payload: Prisma.$DailyEntryPayload<ExtArgs>
        fields: Prisma.DailyEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          findFirst: {
            args: Prisma.DailyEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          findMany: {
            args: Prisma.DailyEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>[]
          }
          create: {
            args: Prisma.DailyEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          createMany: {
            args: Prisma.DailyEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>[]
          }
          delete: {
            args: Prisma.DailyEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          update: {
            args: Prisma.DailyEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          deleteMany: {
            args: Prisma.DailyEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          aggregate: {
            args: Prisma.DailyEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyEntry>
          }
          groupBy: {
            args: Prisma.DailyEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyEntryCountArgs<ExtArgs>
            result: $Utils.Optional<DailyEntryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    verifiedDocs: number
    reportedIncidents: number
    reviewedTimesheets: number
    sentMessages: number
    auditLogs: number
    blogPosts: number
    VisitCheckEvent: number
    DailyEntry: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verifiedDocs?: boolean | UserCountOutputTypeCountVerifiedDocsArgs
    reportedIncidents?: boolean | UserCountOutputTypeCountReportedIncidentsArgs
    reviewedTimesheets?: boolean | UserCountOutputTypeCountReviewedTimesheetsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    blogPosts?: boolean | UserCountOutputTypeCountBlogPostsArgs
    VisitCheckEvent?: boolean | UserCountOutputTypeCountVisitCheckEventArgs
    DailyEntry?: boolean | UserCountOutputTypeCountDailyEntryArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerifiedDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PswDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedTimesheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimesheetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVisitCheckEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitCheckEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyEntryWhereInput
  }


  /**
   * Count Type ClientProfileCountOutputType
   */

  export type ClientProfileCountOutputType = {
    visits: number
    invoices: number
    messageThreads: number
    DailyEntry: number
  }

  export type ClientProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | ClientProfileCountOutputTypeCountVisitsArgs
    invoices?: boolean | ClientProfileCountOutputTypeCountInvoicesArgs
    messageThreads?: boolean | ClientProfileCountOutputTypeCountMessageThreadsArgs
    DailyEntry?: boolean | ClientProfileCountOutputTypeCountDailyEntryArgs
  }

  // Custom InputTypes
  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfileCountOutputType
     */
    select?: ClientProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountMessageThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageThreadWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountDailyEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyEntryWhereInput
  }


  /**
   * Count Type PswProfileCountOutputType
   */

  export type PswProfileCountOutputType = {
    documents: number
    assignedVisits: number
    checkEvents: number
    notes: number
    checklists: number
    timesheets: number
    messageThreads: number
  }

  export type PswProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | PswProfileCountOutputTypeCountDocumentsArgs
    assignedVisits?: boolean | PswProfileCountOutputTypeCountAssignedVisitsArgs
    checkEvents?: boolean | PswProfileCountOutputTypeCountCheckEventsArgs
    notes?: boolean | PswProfileCountOutputTypeCountNotesArgs
    checklists?: boolean | PswProfileCountOutputTypeCountChecklistsArgs
    timesheets?: boolean | PswProfileCountOutputTypeCountTimesheetsArgs
    messageThreads?: boolean | PswProfileCountOutputTypeCountMessageThreadsArgs
  }

  // Custom InputTypes
  /**
   * PswProfileCountOutputType without action
   */
  export type PswProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfileCountOutputType
     */
    select?: PswProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PswProfileCountOutputType without action
   */
  export type PswProfileCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PswDocumentWhereInput
  }

  /**
   * PswProfileCountOutputType without action
   */
  export type PswProfileCountOutputTypeCountAssignedVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }

  /**
   * PswProfileCountOutputType without action
   */
  export type PswProfileCountOutputTypeCountCheckEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitCheckEventWhereInput
  }

  /**
   * PswProfileCountOutputType without action
   */
  export type PswProfileCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitNoteWhereInput
  }

  /**
   * PswProfileCountOutputType without action
   */
  export type PswProfileCountOutputTypeCountChecklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitChecklistWhereInput
  }

  /**
   * PswProfileCountOutputType without action
   */
  export type PswProfileCountOutputTypeCountTimesheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimesheetWhereInput
  }

  /**
   * PswProfileCountOutputType without action
   */
  export type PswProfileCountOutputTypeCountMessageThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageThreadWhereInput
  }


  /**
   * Count Type VisitCountOutputType
   */

  export type VisitCountOutputType = {
    checkEvents: number
    notes: number
    checklists: number
    incidents: number
    timesheetItems: number
    DailyEntry: number
  }

  export type VisitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkEvents?: boolean | VisitCountOutputTypeCountCheckEventsArgs
    notes?: boolean | VisitCountOutputTypeCountNotesArgs
    checklists?: boolean | VisitCountOutputTypeCountChecklistsArgs
    incidents?: boolean | VisitCountOutputTypeCountIncidentsArgs
    timesheetItems?: boolean | VisitCountOutputTypeCountTimesheetItemsArgs
    DailyEntry?: boolean | VisitCountOutputTypeCountDailyEntryArgs
  }

  // Custom InputTypes
  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCountOutputType
     */
    select?: VisitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountCheckEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitCheckEventWhereInput
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitNoteWhereInput
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountChecklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitChecklistWhereInput
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountTimesheetItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimesheetItemWhereInput
  }

  /**
   * VisitCountOutputType without action
   */
  export type VisitCountOutputTypeCountDailyEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyEntryWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    visits: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | ServiceCountOutputTypeCountVisitsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
  }


  /**
   * Count Type TimesheetCountOutputType
   */

  export type TimesheetCountOutputType = {
    items: number
  }

  export type TimesheetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TimesheetCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * TimesheetCountOutputType without action
   */
  export type TimesheetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetCountOutputType
     */
    select?: TimesheetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TimesheetCountOutputType without action
   */
  export type TimesheetCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimesheetItemWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type MessageThreadCountOutputType
   */

  export type MessageThreadCountOutputType = {
    messages: number
  }

  export type MessageThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | MessageThreadCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadCountOutputType
     */
    select?: MessageThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    status: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    status: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    role: number
    email: number
    phone: number
    passwordHash: number
    status: number
    resetToken: number
    resetTokenExpiry: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    role?: true
    email?: true
    phone?: true
    passwordHash?: true
    status?: true
    resetToken?: true
    resetTokenExpiry?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    role?: true
    email?: true
    phone?: true
    passwordHash?: true
    status?: true
    resetToken?: true
    resetTokenExpiry?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    role?: true
    email?: true
    phone?: true
    passwordHash?: true
    status?: true
    resetToken?: true
    resetTokenExpiry?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    role: $Enums.Role
    email: string
    phone: string | null
    passwordHash: string
    status: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    status?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    pswProfile?: boolean | User$pswProfileArgs<ExtArgs>
    verifiedDocs?: boolean | User$verifiedDocsArgs<ExtArgs>
    reportedIncidents?: boolean | User$reportedIncidentsArgs<ExtArgs>
    reviewedTimesheets?: boolean | User$reviewedTimesheetsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    VisitCheckEvent?: boolean | User$VisitCheckEventArgs<ExtArgs>
    DailyEntry?: boolean | User$DailyEntryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    status?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    status?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    pswProfile?: boolean | User$pswProfileArgs<ExtArgs>
    verifiedDocs?: boolean | User$verifiedDocsArgs<ExtArgs>
    reportedIncidents?: boolean | User$reportedIncidentsArgs<ExtArgs>
    reviewedTimesheets?: boolean | User$reviewedTimesheetsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    VisitCheckEvent?: boolean | User$VisitCheckEventArgs<ExtArgs>
    DailyEntry?: boolean | User$DailyEntryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      clientProfile: Prisma.$ClientProfilePayload<ExtArgs> | null
      pswProfile: Prisma.$PswProfilePayload<ExtArgs> | null
      verifiedDocs: Prisma.$PswDocumentPayload<ExtArgs>[]
      reportedIncidents: Prisma.$IncidentPayload<ExtArgs>[]
      reviewedTimesheets: Prisma.$TimesheetPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      VisitCheckEvent: Prisma.$VisitCheckEventPayload<ExtArgs>[]
      DailyEntry: Prisma.$DailyEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.Role
      email: string
      phone: string | null
      passwordHash: string
      status: string | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientProfile<T extends User$clientProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$clientProfileArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pswProfile<T extends User$pswProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$pswProfileArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    verifiedDocs<T extends User$verifiedDocsArgs<ExtArgs> = {}>(args?: Subset<T, User$verifiedDocsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    reportedIncidents<T extends User$reportedIncidentsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedIncidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    reviewedTimesheets<T extends User$reviewedTimesheetsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedTimesheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    blogPosts<T extends User$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany"> | Null>
    VisitCheckEvent<T extends User$VisitCheckEventArgs<ExtArgs> = {}>(args?: Subset<T, User$VisitCheckEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "findMany"> | Null>
    DailyEntry<T extends User$DailyEntryArgs<ExtArgs> = {}>(args?: Subset<T, User$DailyEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.clientProfile
   */
  export type User$clientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    where?: ClientProfileWhereInput
  }

  /**
   * User.pswProfile
   */
  export type User$pswProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    where?: PswProfileWhereInput
  }

  /**
   * User.verifiedDocs
   */
  export type User$verifiedDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    where?: PswDocumentWhereInput
    orderBy?: PswDocumentOrderByWithRelationInput | PswDocumentOrderByWithRelationInput[]
    cursor?: PswDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PswDocumentScalarFieldEnum | PswDocumentScalarFieldEnum[]
  }

  /**
   * User.reportedIncidents
   */
  export type User$reportedIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * User.reviewedTimesheets
   */
  export type User$reviewedTimesheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    where?: TimesheetWhereInput
    orderBy?: TimesheetOrderByWithRelationInput | TimesheetOrderByWithRelationInput[]
    cursor?: TimesheetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimesheetScalarFieldEnum | TimesheetScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.blogPosts
   */
  export type User$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.VisitCheckEvent
   */
  export type User$VisitCheckEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    where?: VisitCheckEventWhereInput
    orderBy?: VisitCheckEventOrderByWithRelationInput | VisitCheckEventOrderByWithRelationInput[]
    cursor?: VisitCheckEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitCheckEventScalarFieldEnum | VisitCheckEventScalarFieldEnum[]
  }

  /**
   * User.DailyEntry
   */
  export type User$DailyEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    where?: DailyEntryWhereInput
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    cursor?: DailyEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ClientProfile
   */

  export type AggregateClientProfile = {
    _count: ClientProfileCountAggregateOutputType | null
    _avg: ClientProfileAvgAggregateOutputType | null
    _sum: ClientProfileSumAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  export type ClientProfileAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type ClientProfileSumAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type ClientProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    dob: Date | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    province: string | null
    postalCode: string | null
    lat: number | null
    lng: number | null
    emergencyName: string | null
    emergencyPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    dob: Date | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    province: string | null
    postalCode: string | null
    lat: number | null
    lng: number | null
    emergencyName: string | null
    emergencyPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientProfileCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    dob: number
    addressLine1: number
    addressLine2: number
    city: number
    province: number
    postalCode: number
    lat: number
    lng: number
    emergencyName: number
    emergencyPhone: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientProfileAvgAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type ClientProfileSumAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type ClientProfileMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    dob?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    province?: true
    postalCode?: true
    lat?: true
    lng?: true
    emergencyName?: true
    emergencyPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    dob?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    province?: true
    postalCode?: true
    lat?: true
    lng?: true
    emergencyName?: true
    emergencyPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientProfileCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    dob?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    province?: true
    postalCode?: true
    lat?: true
    lng?: true
    emergencyName?: true
    emergencyPhone?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfile to aggregate.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientProfiles
    **/
    _count?: true | ClientProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientProfileMaxAggregateInputType
  }

  export type GetClientProfileAggregateType<T extends ClientProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateClientProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientProfile[P]>
      : GetScalarType<T[P], AggregateClientProfile[P]>
  }




  export type ClientProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientProfileWhereInput
    orderBy?: ClientProfileOrderByWithAggregationInput | ClientProfileOrderByWithAggregationInput[]
    by: ClientProfileScalarFieldEnum[] | ClientProfileScalarFieldEnum
    having?: ClientProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientProfileCountAggregateInputType | true
    _avg?: ClientProfileAvgAggregateInputType
    _sum?: ClientProfileSumAggregateInputType
    _min?: ClientProfileMinAggregateInputType
    _max?: ClientProfileMaxAggregateInputType
  }

  export type ClientProfileGroupByOutputType = {
    id: string
    userId: string
    fullName: string
    dob: Date | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    province: string | null
    postalCode: string | null
    lat: number | null
    lng: number | null
    emergencyName: string | null
    emergencyPhone: string | null
    preferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ClientProfileCountAggregateOutputType | null
    _avg: ClientProfileAvgAggregateOutputType | null
    _sum: ClientProfileSumAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  type GetClientProfileGroupByPayload<T extends ClientProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
        }
      >
    >


  export type ClientProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    dob?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    lat?: boolean
    lng?: boolean
    emergencyName?: boolean
    emergencyPhone?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    visits?: boolean | ClientProfile$visitsArgs<ExtArgs>
    invoices?: boolean | ClientProfile$invoicesArgs<ExtArgs>
    messageThreads?: boolean | ClientProfile$messageThreadsArgs<ExtArgs>
    DailyEntry?: boolean | ClientProfile$DailyEntryArgs<ExtArgs>
    _count?: boolean | ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    dob?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    lat?: boolean
    lng?: boolean
    emergencyName?: boolean
    emergencyPhone?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    dob?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    lat?: boolean
    lng?: boolean
    emergencyName?: boolean
    emergencyPhone?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    visits?: boolean | ClientProfile$visitsArgs<ExtArgs>
    invoices?: boolean | ClientProfile$invoicesArgs<ExtArgs>
    messageThreads?: boolean | ClientProfile$messageThreadsArgs<ExtArgs>
    DailyEntry?: boolean | ClientProfile$DailyEntryArgs<ExtArgs>
    _count?: boolean | ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      visits: Prisma.$VisitPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      messageThreads: Prisma.$MessageThreadPayload<ExtArgs>[]
      DailyEntry: Prisma.$DailyEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fullName: string
      dob: Date | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      province: string | null
      postalCode: string | null
      lat: number | null
      lng: number | null
      emergencyName: string | null
      emergencyPhone: string | null
      preferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientProfile"]>
    composites: {}
  }

  type ClientProfileGetPayload<S extends boolean | null | undefined | ClientProfileDefaultArgs> = $Result.GetResult<Prisma.$ClientProfilePayload, S>

  type ClientProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientProfileCountAggregateInputType | true
    }

  export interface ClientProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientProfile'], meta: { name: 'ClientProfile' } }
    /**
     * Find zero or one ClientProfile that matches the filter.
     * @param {ClientProfileFindUniqueArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientProfileFindUniqueArgs>(args: SelectSubset<T, ClientProfileFindUniqueArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientProfileFindUniqueOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientProfileFindFirstArgs>(args?: SelectSubset<T, ClientProfileFindFirstArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany()
     * 
     * // Get first 10 ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientProfileFindManyArgs>(args?: SelectSubset<T, ClientProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientProfile.
     * @param {ClientProfileCreateArgs} args - Arguments to create a ClientProfile.
     * @example
     * // Create one ClientProfile
     * const ClientProfile = await prisma.clientProfile.create({
     *   data: {
     *     // ... data to create a ClientProfile
     *   }
     * })
     * 
     */
    create<T extends ClientProfileCreateArgs>(args: SelectSubset<T, ClientProfileCreateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientProfiles.
     * @param {ClientProfileCreateManyArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientProfileCreateManyArgs>(args?: SelectSubset<T, ClientProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientProfiles and returns the data saved in the database.
     * @param {ClientProfileCreateManyAndReturnArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientProfiles and only return the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientProfile.
     * @param {ClientProfileDeleteArgs} args - Arguments to delete one ClientProfile.
     * @example
     * // Delete one ClientProfile
     * const ClientProfile = await prisma.clientProfile.delete({
     *   where: {
     *     // ... filter to delete one ClientProfile
     *   }
     * })
     * 
     */
    delete<T extends ClientProfileDeleteArgs>(args: SelectSubset<T, ClientProfileDeleteArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientProfile.
     * @param {ClientProfileUpdateArgs} args - Arguments to update one ClientProfile.
     * @example
     * // Update one ClientProfile
     * const clientProfile = await prisma.clientProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientProfileUpdateArgs>(args: SelectSubset<T, ClientProfileUpdateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientProfiles.
     * @param {ClientProfileDeleteManyArgs} args - Arguments to filter ClientProfiles to delete.
     * @example
     * // Delete a few ClientProfiles
     * const { count } = await prisma.clientProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientProfileDeleteManyArgs>(args?: SelectSubset<T, ClientProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientProfiles
     * const clientProfile = await prisma.clientProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientProfileUpdateManyArgs>(args: SelectSubset<T, ClientProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientProfile.
     * @param {ClientProfileUpsertArgs} args - Arguments to update or create a ClientProfile.
     * @example
     * // Update or create a ClientProfile
     * const clientProfile = await prisma.clientProfile.upsert({
     *   create: {
     *     // ... data to create a ClientProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientProfile we want to update
     *   }
     * })
     */
    upsert<T extends ClientProfileUpsertArgs>(args: SelectSubset<T, ClientProfileUpsertArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileCountArgs} args - Arguments to filter ClientProfiles to count.
     * @example
     * // Count the number of ClientProfiles
     * const count = await prisma.clientProfile.count({
     *   where: {
     *     // ... the filter for the ClientProfiles we want to count
     *   }
     * })
    **/
    count<T extends ClientProfileCountArgs>(
      args?: Subset<T, ClientProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientProfileAggregateArgs>(args: Subset<T, ClientProfileAggregateArgs>): Prisma.PrismaPromise<GetClientProfileAggregateType<T>>

    /**
     * Group by ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientProfileGroupByArgs['orderBy'] }
        : { orderBy?: ClientProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientProfile model
   */
  readonly fields: ClientProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    visits<T extends ClientProfile$visitsArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends ClientProfile$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    messageThreads<T extends ClientProfile$messageThreadsArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$messageThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findMany"> | Null>
    DailyEntry<T extends ClientProfile$DailyEntryArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$DailyEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientProfile model
   */ 
  interface ClientProfileFieldRefs {
    readonly id: FieldRef<"ClientProfile", 'String'>
    readonly userId: FieldRef<"ClientProfile", 'String'>
    readonly fullName: FieldRef<"ClientProfile", 'String'>
    readonly dob: FieldRef<"ClientProfile", 'DateTime'>
    readonly addressLine1: FieldRef<"ClientProfile", 'String'>
    readonly addressLine2: FieldRef<"ClientProfile", 'String'>
    readonly city: FieldRef<"ClientProfile", 'String'>
    readonly province: FieldRef<"ClientProfile", 'String'>
    readonly postalCode: FieldRef<"ClientProfile", 'String'>
    readonly lat: FieldRef<"ClientProfile", 'Float'>
    readonly lng: FieldRef<"ClientProfile", 'Float'>
    readonly emergencyName: FieldRef<"ClientProfile", 'String'>
    readonly emergencyPhone: FieldRef<"ClientProfile", 'String'>
    readonly preferences: FieldRef<"ClientProfile", 'Json'>
    readonly createdAt: FieldRef<"ClientProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientProfile findUnique
   */
  export type ClientProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findUniqueOrThrow
   */
  export type ClientProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findFirst
   */
  export type ClientProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findFirstOrThrow
   */
  export type ClientProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findMany
   */
  export type ClientProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfiles to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile create
   */
  export type ClientProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientProfile.
     */
    data: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
  }

  /**
   * ClientProfile createMany
   */
  export type ClientProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientProfile createManyAndReturn
   */
  export type ClientProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientProfile update
   */
  export type ClientProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientProfile.
     */
    data: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
    /**
     * Choose, which ClientProfile to update.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile updateMany
   */
  export type ClientProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientProfiles.
     */
    data: XOR<ClientProfileUpdateManyMutationInput, ClientProfileUncheckedUpdateManyInput>
    /**
     * Filter which ClientProfiles to update
     */
    where?: ClientProfileWhereInput
  }

  /**
   * ClientProfile upsert
   */
  export type ClientProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientProfile to update in case it exists.
     */
    where: ClientProfileWhereUniqueInput
    /**
     * In case the ClientProfile found by the `where` argument doesn't exist, create a new ClientProfile with this data.
     */
    create: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
    /**
     * In case the ClientProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
  }

  /**
   * ClientProfile delete
   */
  export type ClientProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter which ClientProfile to delete.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile deleteMany
   */
  export type ClientProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfiles to delete
     */
    where?: ClientProfileWhereInput
  }

  /**
   * ClientProfile.visits
   */
  export type ClientProfile$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * ClientProfile.invoices
   */
  export type ClientProfile$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * ClientProfile.messageThreads
   */
  export type ClientProfile$messageThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    where?: MessageThreadWhereInput
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    cursor?: MessageThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * ClientProfile.DailyEntry
   */
  export type ClientProfile$DailyEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    where?: DailyEntryWhereInput
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    cursor?: DailyEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * ClientProfile without action
   */
  export type ClientProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
  }


  /**
   * Model PswProfile
   */

  export type AggregatePswProfile = {
    _count: PswProfileCountAggregateOutputType | null
    _min: PswProfileMinAggregateOutputType | null
    _max: PswProfileMaxAggregateOutputType | null
  }

  export type PswProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    bio: string | null
    isApproved: boolean | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PswProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    bio: string | null
    isApproved: boolean | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PswProfileCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    bio: number
    languages: number
    serviceAreas: number
    availability: number
    isApproved: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PswProfileMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    bio?: true
    isApproved?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PswProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    bio?: true
    isApproved?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PswProfileCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    bio?: true
    languages?: true
    serviceAreas?: true
    availability?: true
    isApproved?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PswProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PswProfile to aggregate.
     */
    where?: PswProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PswProfiles to fetch.
     */
    orderBy?: PswProfileOrderByWithRelationInput | PswProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PswProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PswProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PswProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PswProfiles
    **/
    _count?: true | PswProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PswProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PswProfileMaxAggregateInputType
  }

  export type GetPswProfileAggregateType<T extends PswProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePswProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePswProfile[P]>
      : GetScalarType<T[P], AggregatePswProfile[P]>
  }




  export type PswProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PswProfileWhereInput
    orderBy?: PswProfileOrderByWithAggregationInput | PswProfileOrderByWithAggregationInput[]
    by: PswProfileScalarFieldEnum[] | PswProfileScalarFieldEnum
    having?: PswProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PswProfileCountAggregateInputType | true
    _min?: PswProfileMinAggregateInputType
    _max?: PswProfileMaxAggregateInputType
  }

  export type PswProfileGroupByOutputType = {
    id: string
    userId: string
    fullName: string
    bio: string | null
    languages: string[]
    serviceAreas: string[]
    availability: JsonValue | null
    isApproved: boolean
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PswProfileCountAggregateOutputType | null
    _min: PswProfileMinAggregateOutputType | null
    _max: PswProfileMaxAggregateOutputType | null
  }

  type GetPswProfileGroupByPayload<T extends PswProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PswProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PswProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PswProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PswProfileGroupByOutputType[P]>
        }
      >
    >


  export type PswProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    bio?: boolean
    languages?: boolean
    serviceAreas?: boolean
    availability?: boolean
    isApproved?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | PswProfile$documentsArgs<ExtArgs>
    assignedVisits?: boolean | PswProfile$assignedVisitsArgs<ExtArgs>
    checkEvents?: boolean | PswProfile$checkEventsArgs<ExtArgs>
    notes?: boolean | PswProfile$notesArgs<ExtArgs>
    checklists?: boolean | PswProfile$checklistsArgs<ExtArgs>
    timesheets?: boolean | PswProfile$timesheetsArgs<ExtArgs>
    messageThreads?: boolean | PswProfile$messageThreadsArgs<ExtArgs>
    _count?: boolean | PswProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pswProfile"]>

  export type PswProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    bio?: boolean
    languages?: boolean
    serviceAreas?: boolean
    availability?: boolean
    isApproved?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pswProfile"]>

  export type PswProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    bio?: boolean
    languages?: boolean
    serviceAreas?: boolean
    availability?: boolean
    isApproved?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PswProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | PswProfile$documentsArgs<ExtArgs>
    assignedVisits?: boolean | PswProfile$assignedVisitsArgs<ExtArgs>
    checkEvents?: boolean | PswProfile$checkEventsArgs<ExtArgs>
    notes?: boolean | PswProfile$notesArgs<ExtArgs>
    checklists?: boolean | PswProfile$checklistsArgs<ExtArgs>
    timesheets?: boolean | PswProfile$timesheetsArgs<ExtArgs>
    messageThreads?: boolean | PswProfile$messageThreadsArgs<ExtArgs>
    _count?: boolean | PswProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PswProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PswProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PswProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      documents: Prisma.$PswDocumentPayload<ExtArgs>[]
      assignedVisits: Prisma.$VisitPayload<ExtArgs>[]
      checkEvents: Prisma.$VisitCheckEventPayload<ExtArgs>[]
      notes: Prisma.$VisitNotePayload<ExtArgs>[]
      checklists: Prisma.$VisitChecklistPayload<ExtArgs>[]
      timesheets: Prisma.$TimesheetPayload<ExtArgs>[]
      messageThreads: Prisma.$MessageThreadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fullName: string
      bio: string | null
      languages: string[]
      serviceAreas: string[]
      availability: Prisma.JsonValue | null
      isApproved: boolean
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pswProfile"]>
    composites: {}
  }

  type PswProfileGetPayload<S extends boolean | null | undefined | PswProfileDefaultArgs> = $Result.GetResult<Prisma.$PswProfilePayload, S>

  type PswProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PswProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PswProfileCountAggregateInputType | true
    }

  export interface PswProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PswProfile'], meta: { name: 'PswProfile' } }
    /**
     * Find zero or one PswProfile that matches the filter.
     * @param {PswProfileFindUniqueArgs} args - Arguments to find a PswProfile
     * @example
     * // Get one PswProfile
     * const pswProfile = await prisma.pswProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PswProfileFindUniqueArgs>(args: SelectSubset<T, PswProfileFindUniqueArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PswProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PswProfileFindUniqueOrThrowArgs} args - Arguments to find a PswProfile
     * @example
     * // Get one PswProfile
     * const pswProfile = await prisma.pswProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PswProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, PswProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PswProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswProfileFindFirstArgs} args - Arguments to find a PswProfile
     * @example
     * // Get one PswProfile
     * const pswProfile = await prisma.pswProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PswProfileFindFirstArgs>(args?: SelectSubset<T, PswProfileFindFirstArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PswProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswProfileFindFirstOrThrowArgs} args - Arguments to find a PswProfile
     * @example
     * // Get one PswProfile
     * const pswProfile = await prisma.pswProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PswProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, PswProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PswProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PswProfiles
     * const pswProfiles = await prisma.pswProfile.findMany()
     * 
     * // Get first 10 PswProfiles
     * const pswProfiles = await prisma.pswProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pswProfileWithIdOnly = await prisma.pswProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PswProfileFindManyArgs>(args?: SelectSubset<T, PswProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PswProfile.
     * @param {PswProfileCreateArgs} args - Arguments to create a PswProfile.
     * @example
     * // Create one PswProfile
     * const PswProfile = await prisma.pswProfile.create({
     *   data: {
     *     // ... data to create a PswProfile
     *   }
     * })
     * 
     */
    create<T extends PswProfileCreateArgs>(args: SelectSubset<T, PswProfileCreateArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PswProfiles.
     * @param {PswProfileCreateManyArgs} args - Arguments to create many PswProfiles.
     * @example
     * // Create many PswProfiles
     * const pswProfile = await prisma.pswProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PswProfileCreateManyArgs>(args?: SelectSubset<T, PswProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PswProfiles and returns the data saved in the database.
     * @param {PswProfileCreateManyAndReturnArgs} args - Arguments to create many PswProfiles.
     * @example
     * // Create many PswProfiles
     * const pswProfile = await prisma.pswProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PswProfiles and only return the `id`
     * const pswProfileWithIdOnly = await prisma.pswProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PswProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, PswProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PswProfile.
     * @param {PswProfileDeleteArgs} args - Arguments to delete one PswProfile.
     * @example
     * // Delete one PswProfile
     * const PswProfile = await prisma.pswProfile.delete({
     *   where: {
     *     // ... filter to delete one PswProfile
     *   }
     * })
     * 
     */
    delete<T extends PswProfileDeleteArgs>(args: SelectSubset<T, PswProfileDeleteArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PswProfile.
     * @param {PswProfileUpdateArgs} args - Arguments to update one PswProfile.
     * @example
     * // Update one PswProfile
     * const pswProfile = await prisma.pswProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PswProfileUpdateArgs>(args: SelectSubset<T, PswProfileUpdateArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PswProfiles.
     * @param {PswProfileDeleteManyArgs} args - Arguments to filter PswProfiles to delete.
     * @example
     * // Delete a few PswProfiles
     * const { count } = await prisma.pswProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PswProfileDeleteManyArgs>(args?: SelectSubset<T, PswProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PswProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PswProfiles
     * const pswProfile = await prisma.pswProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PswProfileUpdateManyArgs>(args: SelectSubset<T, PswProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PswProfile.
     * @param {PswProfileUpsertArgs} args - Arguments to update or create a PswProfile.
     * @example
     * // Update or create a PswProfile
     * const pswProfile = await prisma.pswProfile.upsert({
     *   create: {
     *     // ... data to create a PswProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PswProfile we want to update
     *   }
     * })
     */
    upsert<T extends PswProfileUpsertArgs>(args: SelectSubset<T, PswProfileUpsertArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PswProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswProfileCountArgs} args - Arguments to filter PswProfiles to count.
     * @example
     * // Count the number of PswProfiles
     * const count = await prisma.pswProfile.count({
     *   where: {
     *     // ... the filter for the PswProfiles we want to count
     *   }
     * })
    **/
    count<T extends PswProfileCountArgs>(
      args?: Subset<T, PswProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PswProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PswProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PswProfileAggregateArgs>(args: Subset<T, PswProfileAggregateArgs>): Prisma.PrismaPromise<GetPswProfileAggregateType<T>>

    /**
     * Group by PswProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PswProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PswProfileGroupByArgs['orderBy'] }
        : { orderBy?: PswProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PswProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPswProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PswProfile model
   */
  readonly fields: PswProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PswProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PswProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    documents<T extends PswProfile$documentsArgs<ExtArgs> = {}>(args?: Subset<T, PswProfile$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    assignedVisits<T extends PswProfile$assignedVisitsArgs<ExtArgs> = {}>(args?: Subset<T, PswProfile$assignedVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany"> | Null>
    checkEvents<T extends PswProfile$checkEventsArgs<ExtArgs> = {}>(args?: Subset<T, PswProfile$checkEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends PswProfile$notesArgs<ExtArgs> = {}>(args?: Subset<T, PswProfile$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "findMany"> | Null>
    checklists<T extends PswProfile$checklistsArgs<ExtArgs> = {}>(args?: Subset<T, PswProfile$checklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "findMany"> | Null>
    timesheets<T extends PswProfile$timesheetsArgs<ExtArgs> = {}>(args?: Subset<T, PswProfile$timesheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "findMany"> | Null>
    messageThreads<T extends PswProfile$messageThreadsArgs<ExtArgs> = {}>(args?: Subset<T, PswProfile$messageThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PswProfile model
   */ 
  interface PswProfileFieldRefs {
    readonly id: FieldRef<"PswProfile", 'String'>
    readonly userId: FieldRef<"PswProfile", 'String'>
    readonly fullName: FieldRef<"PswProfile", 'String'>
    readonly bio: FieldRef<"PswProfile", 'String'>
    readonly languages: FieldRef<"PswProfile", 'String[]'>
    readonly serviceAreas: FieldRef<"PswProfile", 'String[]'>
    readonly availability: FieldRef<"PswProfile", 'Json'>
    readonly isApproved: FieldRef<"PswProfile", 'Boolean'>
    readonly approvedAt: FieldRef<"PswProfile", 'DateTime'>
    readonly createdAt: FieldRef<"PswProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"PswProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PswProfile findUnique
   */
  export type PswProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    /**
     * Filter, which PswProfile to fetch.
     */
    where: PswProfileWhereUniqueInput
  }

  /**
   * PswProfile findUniqueOrThrow
   */
  export type PswProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    /**
     * Filter, which PswProfile to fetch.
     */
    where: PswProfileWhereUniqueInput
  }

  /**
   * PswProfile findFirst
   */
  export type PswProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    /**
     * Filter, which PswProfile to fetch.
     */
    where?: PswProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PswProfiles to fetch.
     */
    orderBy?: PswProfileOrderByWithRelationInput | PswProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PswProfiles.
     */
    cursor?: PswProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PswProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PswProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PswProfiles.
     */
    distinct?: PswProfileScalarFieldEnum | PswProfileScalarFieldEnum[]
  }

  /**
   * PswProfile findFirstOrThrow
   */
  export type PswProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    /**
     * Filter, which PswProfile to fetch.
     */
    where?: PswProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PswProfiles to fetch.
     */
    orderBy?: PswProfileOrderByWithRelationInput | PswProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PswProfiles.
     */
    cursor?: PswProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PswProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PswProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PswProfiles.
     */
    distinct?: PswProfileScalarFieldEnum | PswProfileScalarFieldEnum[]
  }

  /**
   * PswProfile findMany
   */
  export type PswProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    /**
     * Filter, which PswProfiles to fetch.
     */
    where?: PswProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PswProfiles to fetch.
     */
    orderBy?: PswProfileOrderByWithRelationInput | PswProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PswProfiles.
     */
    cursor?: PswProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PswProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PswProfiles.
     */
    skip?: number
    distinct?: PswProfileScalarFieldEnum | PswProfileScalarFieldEnum[]
  }

  /**
   * PswProfile create
   */
  export type PswProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a PswProfile.
     */
    data: XOR<PswProfileCreateInput, PswProfileUncheckedCreateInput>
  }

  /**
   * PswProfile createMany
   */
  export type PswProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PswProfiles.
     */
    data: PswProfileCreateManyInput | PswProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PswProfile createManyAndReturn
   */
  export type PswProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PswProfiles.
     */
    data: PswProfileCreateManyInput | PswProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PswProfile update
   */
  export type PswProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a PswProfile.
     */
    data: XOR<PswProfileUpdateInput, PswProfileUncheckedUpdateInput>
    /**
     * Choose, which PswProfile to update.
     */
    where: PswProfileWhereUniqueInput
  }

  /**
   * PswProfile updateMany
   */
  export type PswProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PswProfiles.
     */
    data: XOR<PswProfileUpdateManyMutationInput, PswProfileUncheckedUpdateManyInput>
    /**
     * Filter which PswProfiles to update
     */
    where?: PswProfileWhereInput
  }

  /**
   * PswProfile upsert
   */
  export type PswProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the PswProfile to update in case it exists.
     */
    where: PswProfileWhereUniqueInput
    /**
     * In case the PswProfile found by the `where` argument doesn't exist, create a new PswProfile with this data.
     */
    create: XOR<PswProfileCreateInput, PswProfileUncheckedCreateInput>
    /**
     * In case the PswProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PswProfileUpdateInput, PswProfileUncheckedUpdateInput>
  }

  /**
   * PswProfile delete
   */
  export type PswProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    /**
     * Filter which PswProfile to delete.
     */
    where: PswProfileWhereUniqueInput
  }

  /**
   * PswProfile deleteMany
   */
  export type PswProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PswProfiles to delete
     */
    where?: PswProfileWhereInput
  }

  /**
   * PswProfile.documents
   */
  export type PswProfile$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    where?: PswDocumentWhereInput
    orderBy?: PswDocumentOrderByWithRelationInput | PswDocumentOrderByWithRelationInput[]
    cursor?: PswDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PswDocumentScalarFieldEnum | PswDocumentScalarFieldEnum[]
  }

  /**
   * PswProfile.assignedVisits
   */
  export type PswProfile$assignedVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * PswProfile.checkEvents
   */
  export type PswProfile$checkEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    where?: VisitCheckEventWhereInput
    orderBy?: VisitCheckEventOrderByWithRelationInput | VisitCheckEventOrderByWithRelationInput[]
    cursor?: VisitCheckEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitCheckEventScalarFieldEnum | VisitCheckEventScalarFieldEnum[]
  }

  /**
   * PswProfile.notes
   */
  export type PswProfile$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    where?: VisitNoteWhereInput
    orderBy?: VisitNoteOrderByWithRelationInput | VisitNoteOrderByWithRelationInput[]
    cursor?: VisitNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitNoteScalarFieldEnum | VisitNoteScalarFieldEnum[]
  }

  /**
   * PswProfile.checklists
   */
  export type PswProfile$checklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    where?: VisitChecklistWhereInput
    orderBy?: VisitChecklistOrderByWithRelationInput | VisitChecklistOrderByWithRelationInput[]
    cursor?: VisitChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitChecklistScalarFieldEnum | VisitChecklistScalarFieldEnum[]
  }

  /**
   * PswProfile.timesheets
   */
  export type PswProfile$timesheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    where?: TimesheetWhereInput
    orderBy?: TimesheetOrderByWithRelationInput | TimesheetOrderByWithRelationInput[]
    cursor?: TimesheetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimesheetScalarFieldEnum | TimesheetScalarFieldEnum[]
  }

  /**
   * PswProfile.messageThreads
   */
  export type PswProfile$messageThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    where?: MessageThreadWhereInput
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    cursor?: MessageThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * PswProfile without action
   */
  export type PswProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
  }


  /**
   * Model Visit
   */

  export type AggregateVisit = {
    _count: VisitCountAggregateOutputType | null
    _avg: VisitAvgAggregateOutputType | null
    _sum: VisitSumAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  export type VisitAvgAggregateOutputType = {
    durationMinutes: number | null
    serviceLat: number | null
    serviceLng: number | null
  }

  export type VisitSumAggregateOutputType = {
    durationMinutes: number | null
    serviceLat: number | null
    serviceLng: number | null
  }

  export type VisitMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    serviceId: string | null
    requestedStartAt: Date | null
    durationMinutes: number | null
    status: $Enums.VisitStatus | null
    assignedPswId: string | null
    serviceAddressLine1: string | null
    serviceAddressLine2: string | null
    serviceCity: string | null
    serviceProvince: string | null
    servicePostalCode: string | null
    serviceLat: number | null
    serviceLng: number | null
    clientNotes: string | null
    coordinatorNotes: string | null
    cancellationReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    serviceId: string | null
    requestedStartAt: Date | null
    durationMinutes: number | null
    status: $Enums.VisitStatus | null
    assignedPswId: string | null
    serviceAddressLine1: string | null
    serviceAddressLine2: string | null
    serviceCity: string | null
    serviceProvince: string | null
    servicePostalCode: string | null
    serviceLat: number | null
    serviceLng: number | null
    clientNotes: string | null
    coordinatorNotes: string | null
    cancellationReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitCountAggregateOutputType = {
    id: number
    clientId: number
    serviceId: number
    requestedStartAt: number
    durationMinutes: number
    status: number
    assignedPswId: number
    serviceAddressLine1: number
    serviceAddressLine2: number
    serviceCity: number
    serviceProvince: number
    servicePostalCode: number
    serviceLat: number
    serviceLng: number
    clientNotes: number
    coordinatorNotes: number
    cancellationReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitAvgAggregateInputType = {
    durationMinutes?: true
    serviceLat?: true
    serviceLng?: true
  }

  export type VisitSumAggregateInputType = {
    durationMinutes?: true
    serviceLat?: true
    serviceLng?: true
  }

  export type VisitMinAggregateInputType = {
    id?: true
    clientId?: true
    serviceId?: true
    requestedStartAt?: true
    durationMinutes?: true
    status?: true
    assignedPswId?: true
    serviceAddressLine1?: true
    serviceAddressLine2?: true
    serviceCity?: true
    serviceProvince?: true
    servicePostalCode?: true
    serviceLat?: true
    serviceLng?: true
    clientNotes?: true
    coordinatorNotes?: true
    cancellationReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitMaxAggregateInputType = {
    id?: true
    clientId?: true
    serviceId?: true
    requestedStartAt?: true
    durationMinutes?: true
    status?: true
    assignedPswId?: true
    serviceAddressLine1?: true
    serviceAddressLine2?: true
    serviceCity?: true
    serviceProvince?: true
    servicePostalCode?: true
    serviceLat?: true
    serviceLng?: true
    clientNotes?: true
    coordinatorNotes?: true
    cancellationReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitCountAggregateInputType = {
    id?: true
    clientId?: true
    serviceId?: true
    requestedStartAt?: true
    durationMinutes?: true
    status?: true
    assignedPswId?: true
    serviceAddressLine1?: true
    serviceAddressLine2?: true
    serviceCity?: true
    serviceProvince?: true
    servicePostalCode?: true
    serviceLat?: true
    serviceLng?: true
    clientNotes?: true
    coordinatorNotes?: true
    cancellationReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visit to aggregate.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visits
    **/
    _count?: true | VisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitMaxAggregateInputType
  }

  export type GetVisitAggregateType<T extends VisitAggregateArgs> = {
        [P in keyof T & keyof AggregateVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisit[P]>
      : GetScalarType<T[P], AggregateVisit[P]>
  }




  export type VisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithAggregationInput | VisitOrderByWithAggregationInput[]
    by: VisitScalarFieldEnum[] | VisitScalarFieldEnum
    having?: VisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitCountAggregateInputType | true
    _avg?: VisitAvgAggregateInputType
    _sum?: VisitSumAggregateInputType
    _min?: VisitMinAggregateInputType
    _max?: VisitMaxAggregateInputType
  }

  export type VisitGroupByOutputType = {
    id: string
    clientId: string
    serviceId: string
    requestedStartAt: Date
    durationMinutes: number
    status: $Enums.VisitStatus | null
    assignedPswId: string | null
    serviceAddressLine1: string | null
    serviceAddressLine2: string | null
    serviceCity: string | null
    serviceProvince: string | null
    servicePostalCode: string | null
    serviceLat: number | null
    serviceLng: number | null
    clientNotes: string | null
    coordinatorNotes: string | null
    cancellationReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: VisitCountAggregateOutputType | null
    _avg: VisitAvgAggregateOutputType | null
    _sum: VisitSumAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  type GetVisitGroupByPayload<T extends VisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitGroupByOutputType[P]>
            : GetScalarType<T[P], VisitGroupByOutputType[P]>
        }
      >
    >


  export type VisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    serviceId?: boolean
    requestedStartAt?: boolean
    durationMinutes?: boolean
    status?: boolean
    assignedPswId?: boolean
    serviceAddressLine1?: boolean
    serviceAddressLine2?: boolean
    serviceCity?: boolean
    serviceProvince?: boolean
    servicePostalCode?: boolean
    serviceLat?: boolean
    serviceLng?: boolean
    clientNotes?: boolean
    coordinatorNotes?: boolean
    cancellationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    psw?: boolean | Visit$pswArgs<ExtArgs>
    checkEvents?: boolean | Visit$checkEventsArgs<ExtArgs>
    notes?: boolean | Visit$notesArgs<ExtArgs>
    checklists?: boolean | Visit$checklistsArgs<ExtArgs>
    incidents?: boolean | Visit$incidentsArgs<ExtArgs>
    timesheetItems?: boolean | Visit$timesheetItemsArgs<ExtArgs>
    DailyEntry?: boolean | Visit$DailyEntryArgs<ExtArgs>
    _count?: boolean | VisitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visit"]>

  export type VisitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    serviceId?: boolean
    requestedStartAt?: boolean
    durationMinutes?: boolean
    status?: boolean
    assignedPswId?: boolean
    serviceAddressLine1?: boolean
    serviceAddressLine2?: boolean
    serviceCity?: boolean
    serviceProvince?: boolean
    servicePostalCode?: boolean
    serviceLat?: boolean
    serviceLng?: boolean
    clientNotes?: boolean
    coordinatorNotes?: boolean
    cancellationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    psw?: boolean | Visit$pswArgs<ExtArgs>
  }, ExtArgs["result"]["visit"]>

  export type VisitSelectScalar = {
    id?: boolean
    clientId?: boolean
    serviceId?: boolean
    requestedStartAt?: boolean
    durationMinutes?: boolean
    status?: boolean
    assignedPswId?: boolean
    serviceAddressLine1?: boolean
    serviceAddressLine2?: boolean
    serviceCity?: boolean
    serviceProvince?: boolean
    servicePostalCode?: boolean
    serviceLat?: boolean
    serviceLng?: boolean
    clientNotes?: boolean
    coordinatorNotes?: boolean
    cancellationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    psw?: boolean | Visit$pswArgs<ExtArgs>
    checkEvents?: boolean | Visit$checkEventsArgs<ExtArgs>
    notes?: boolean | Visit$notesArgs<ExtArgs>
    checklists?: boolean | Visit$checklistsArgs<ExtArgs>
    incidents?: boolean | Visit$incidentsArgs<ExtArgs>
    timesheetItems?: boolean | Visit$timesheetItemsArgs<ExtArgs>
    DailyEntry?: boolean | Visit$DailyEntryArgs<ExtArgs>
    _count?: boolean | VisitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VisitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    psw?: boolean | Visit$pswArgs<ExtArgs>
  }

  export type $VisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visit"
    objects: {
      client: Prisma.$ClientProfilePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      psw: Prisma.$PswProfilePayload<ExtArgs> | null
      checkEvents: Prisma.$VisitCheckEventPayload<ExtArgs>[]
      notes: Prisma.$VisitNotePayload<ExtArgs>[]
      checklists: Prisma.$VisitChecklistPayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      timesheetItems: Prisma.$TimesheetItemPayload<ExtArgs>[]
      DailyEntry: Prisma.$DailyEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      serviceId: string
      requestedStartAt: Date
      durationMinutes: number
      status: $Enums.VisitStatus | null
      assignedPswId: string | null
      serviceAddressLine1: string | null
      serviceAddressLine2: string | null
      serviceCity: string | null
      serviceProvince: string | null
      servicePostalCode: string | null
      serviceLat: number | null
      serviceLng: number | null
      clientNotes: string | null
      coordinatorNotes: string | null
      cancellationReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visit"]>
    composites: {}
  }

  type VisitGetPayload<S extends boolean | null | undefined | VisitDefaultArgs> = $Result.GetResult<Prisma.$VisitPayload, S>

  type VisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitCountAggregateInputType | true
    }

  export interface VisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visit'], meta: { name: 'Visit' } }
    /**
     * Find zero or one Visit that matches the filter.
     * @param {VisitFindUniqueArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitFindUniqueArgs>(args: SelectSubset<T, VisitFindUniqueArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Visit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitFindUniqueOrThrowArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Visit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindFirstArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitFindFirstArgs>(args?: SelectSubset<T, VisitFindFirstArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Visit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindFirstOrThrowArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visits
     * const visits = await prisma.visit.findMany()
     * 
     * // Get first 10 Visits
     * const visits = await prisma.visit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitWithIdOnly = await prisma.visit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitFindManyArgs>(args?: SelectSubset<T, VisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Visit.
     * @param {VisitCreateArgs} args - Arguments to create a Visit.
     * @example
     * // Create one Visit
     * const Visit = await prisma.visit.create({
     *   data: {
     *     // ... data to create a Visit
     *   }
     * })
     * 
     */
    create<T extends VisitCreateArgs>(args: SelectSubset<T, VisitCreateArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Visits.
     * @param {VisitCreateManyArgs} args - Arguments to create many Visits.
     * @example
     * // Create many Visits
     * const visit = await prisma.visit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitCreateManyArgs>(args?: SelectSubset<T, VisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Visits and returns the data saved in the database.
     * @param {VisitCreateManyAndReturnArgs} args - Arguments to create many Visits.
     * @example
     * // Create many Visits
     * const visit = await prisma.visit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Visits and only return the `id`
     * const visitWithIdOnly = await prisma.visit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Visit.
     * @param {VisitDeleteArgs} args - Arguments to delete one Visit.
     * @example
     * // Delete one Visit
     * const Visit = await prisma.visit.delete({
     *   where: {
     *     // ... filter to delete one Visit
     *   }
     * })
     * 
     */
    delete<T extends VisitDeleteArgs>(args: SelectSubset<T, VisitDeleteArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Visit.
     * @param {VisitUpdateArgs} args - Arguments to update one Visit.
     * @example
     * // Update one Visit
     * const visit = await prisma.visit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitUpdateArgs>(args: SelectSubset<T, VisitUpdateArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Visits.
     * @param {VisitDeleteManyArgs} args - Arguments to filter Visits to delete.
     * @example
     * // Delete a few Visits
     * const { count } = await prisma.visit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitDeleteManyArgs>(args?: SelectSubset<T, VisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visits
     * const visit = await prisma.visit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitUpdateManyArgs>(args: SelectSubset<T, VisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visit.
     * @param {VisitUpsertArgs} args - Arguments to update or create a Visit.
     * @example
     * // Update or create a Visit
     * const visit = await prisma.visit.upsert({
     *   create: {
     *     // ... data to create a Visit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visit we want to update
     *   }
     * })
     */
    upsert<T extends VisitUpsertArgs>(args: SelectSubset<T, VisitUpsertArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCountArgs} args - Arguments to filter Visits to count.
     * @example
     * // Count the number of Visits
     * const count = await prisma.visit.count({
     *   where: {
     *     // ... the filter for the Visits we want to count
     *   }
     * })
    **/
    count<T extends VisitCountArgs>(
      args?: Subset<T, VisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitAggregateArgs>(args: Subset<T, VisitAggregateArgs>): Prisma.PrismaPromise<GetVisitAggregateType<T>>

    /**
     * Group by Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitGroupByArgs['orderBy'] }
        : { orderBy?: VisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visit model
   */
  readonly fields: VisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    psw<T extends Visit$pswArgs<ExtArgs> = {}>(args?: Subset<T, Visit$pswArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    checkEvents<T extends Visit$checkEventsArgs<ExtArgs> = {}>(args?: Subset<T, Visit$checkEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends Visit$notesArgs<ExtArgs> = {}>(args?: Subset<T, Visit$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "findMany"> | Null>
    checklists<T extends Visit$checklistsArgs<ExtArgs> = {}>(args?: Subset<T, Visit$checklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "findMany"> | Null>
    incidents<T extends Visit$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Visit$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    timesheetItems<T extends Visit$timesheetItemsArgs<ExtArgs> = {}>(args?: Subset<T, Visit$timesheetItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "findMany"> | Null>
    DailyEntry<T extends Visit$DailyEntryArgs<ExtArgs> = {}>(args?: Subset<T, Visit$DailyEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visit model
   */ 
  interface VisitFieldRefs {
    readonly id: FieldRef<"Visit", 'String'>
    readonly clientId: FieldRef<"Visit", 'String'>
    readonly serviceId: FieldRef<"Visit", 'String'>
    readonly requestedStartAt: FieldRef<"Visit", 'DateTime'>
    readonly durationMinutes: FieldRef<"Visit", 'Int'>
    readonly status: FieldRef<"Visit", 'VisitStatus'>
    readonly assignedPswId: FieldRef<"Visit", 'String'>
    readonly serviceAddressLine1: FieldRef<"Visit", 'String'>
    readonly serviceAddressLine2: FieldRef<"Visit", 'String'>
    readonly serviceCity: FieldRef<"Visit", 'String'>
    readonly serviceProvince: FieldRef<"Visit", 'String'>
    readonly servicePostalCode: FieldRef<"Visit", 'String'>
    readonly serviceLat: FieldRef<"Visit", 'Float'>
    readonly serviceLng: FieldRef<"Visit", 'Float'>
    readonly clientNotes: FieldRef<"Visit", 'String'>
    readonly coordinatorNotes: FieldRef<"Visit", 'String'>
    readonly cancellationReason: FieldRef<"Visit", 'String'>
    readonly createdAt: FieldRef<"Visit", 'DateTime'>
    readonly updatedAt: FieldRef<"Visit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Visit findUnique
   */
  export type VisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit findUniqueOrThrow
   */
  export type VisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit findFirst
   */
  export type VisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit findFirstOrThrow
   */
  export type VisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visit to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     */
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit findMany
   */
  export type VisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter, which Visits to fetch.
     */
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     */
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visits.
     */
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     */
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Visit create
   */
  export type VisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The data needed to create a Visit.
     */
    data: XOR<VisitCreateInput, VisitUncheckedCreateInput>
  }

  /**
   * Visit createMany
   */
  export type VisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visits.
     */
    data: VisitCreateManyInput | VisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visit createManyAndReturn
   */
  export type VisitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Visits.
     */
    data: VisitCreateManyInput | VisitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Visit update
   */
  export type VisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The data needed to update a Visit.
     */
    data: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
    /**
     * Choose, which Visit to update.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit updateMany
   */
  export type VisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visits.
     */
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyInput>
    /**
     * Filter which Visits to update
     */
    where?: VisitWhereInput
  }

  /**
   * Visit upsert
   */
  export type VisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * The filter to search for the Visit to update in case it exists.
     */
    where: VisitWhereUniqueInput
    /**
     * In case the Visit found by the `where` argument doesn't exist, create a new Visit with this data.
     */
    create: XOR<VisitCreateInput, VisitUncheckedCreateInput>
    /**
     * In case the Visit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
  }

  /**
   * Visit delete
   */
  export type VisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    /**
     * Filter which Visit to delete.
     */
    where: VisitWhereUniqueInput
  }

  /**
   * Visit deleteMany
   */
  export type VisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visits to delete
     */
    where?: VisitWhereInput
  }

  /**
   * Visit.psw
   */
  export type Visit$pswArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    where?: PswProfileWhereInput
  }

  /**
   * Visit.checkEvents
   */
  export type Visit$checkEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    where?: VisitCheckEventWhereInput
    orderBy?: VisitCheckEventOrderByWithRelationInput | VisitCheckEventOrderByWithRelationInput[]
    cursor?: VisitCheckEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitCheckEventScalarFieldEnum | VisitCheckEventScalarFieldEnum[]
  }

  /**
   * Visit.notes
   */
  export type Visit$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    where?: VisitNoteWhereInput
    orderBy?: VisitNoteOrderByWithRelationInput | VisitNoteOrderByWithRelationInput[]
    cursor?: VisitNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitNoteScalarFieldEnum | VisitNoteScalarFieldEnum[]
  }

  /**
   * Visit.checklists
   */
  export type Visit$checklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    where?: VisitChecklistWhereInput
    orderBy?: VisitChecklistOrderByWithRelationInput | VisitChecklistOrderByWithRelationInput[]
    cursor?: VisitChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitChecklistScalarFieldEnum | VisitChecklistScalarFieldEnum[]
  }

  /**
   * Visit.incidents
   */
  export type Visit$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Visit.timesheetItems
   */
  export type Visit$timesheetItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    where?: TimesheetItemWhereInput
    orderBy?: TimesheetItemOrderByWithRelationInput | TimesheetItemOrderByWithRelationInput[]
    cursor?: TimesheetItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimesheetItemScalarFieldEnum | TimesheetItemScalarFieldEnum[]
  }

  /**
   * Visit.DailyEntry
   */
  export type Visit$DailyEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    where?: DailyEntryWhereInput
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    cursor?: DailyEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * Visit without action
   */
  export type VisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    baseRateHourly: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    baseRateHourly: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    baseRateHourly: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    baseRateHourly: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    baseRateHourly: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    baseRateHourly?: true
  }

  export type ServiceSumAggregateInputType = {
    baseRateHourly?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    baseRateHourly?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    baseRateHourly?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    baseRateHourly?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    baseRateHourly: Decimal | null
    isActive: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    baseRateHourly?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean | Service$visitsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    baseRateHourly?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    baseRateHourly?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visits?: boolean | Service$visitsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      visits: Prisma.$VisitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      baseRateHourly: Prisma.Decimal | null
      isActive: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visits<T extends Service$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Service$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly slug: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly baseRateHourly: FieldRef<"Service", 'Decimal'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.visits
   */
  export type Service$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
    orderBy?: VisitOrderByWithRelationInput | VisitOrderByWithRelationInput[]
    cursor?: VisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitScalarFieldEnum | VisitScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model VisitCheckEvent
   */

  export type AggregateVisitCheckEvent = {
    _count: VisitCheckEventCountAggregateOutputType | null
    _avg: VisitCheckEventAvgAggregateOutputType | null
    _sum: VisitCheckEventSumAggregateOutputType | null
    _min: VisitCheckEventMinAggregateOutputType | null
    _max: VisitCheckEventMaxAggregateOutputType | null
  }

  export type VisitCheckEventAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
    accuracyM: number | null
    computedDistanceM: number | null
  }

  export type VisitCheckEventSumAggregateOutputType = {
    lat: number | null
    lng: number | null
    accuracyM: number | null
    computedDistanceM: number | null
  }

  export type VisitCheckEventMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    pswId: string | null
    eventType: $Enums.EventType | null
    lat: number | null
    lng: number | null
    accuracyM: number | null
    computedDistanceM: number | null
    deviceTimeIso: Date | null
    serverTime: Date | null
    result: $Enums.EventResult | null
    rejectReason: string | null
    isOverride: boolean | null
    overrideByUserId: string | null
    overrideReason: string | null
    createdAt: Date | null
  }

  export type VisitCheckEventMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    pswId: string | null
    eventType: $Enums.EventType | null
    lat: number | null
    lng: number | null
    accuracyM: number | null
    computedDistanceM: number | null
    deviceTimeIso: Date | null
    serverTime: Date | null
    result: $Enums.EventResult | null
    rejectReason: string | null
    isOverride: boolean | null
    overrideByUserId: string | null
    overrideReason: string | null
    createdAt: Date | null
  }

  export type VisitCheckEventCountAggregateOutputType = {
    id: number
    visitId: number
    pswId: number
    eventType: number
    lat: number
    lng: number
    accuracyM: number
    computedDistanceM: number
    deviceTimeIso: number
    serverTime: number
    result: number
    rejectReason: number
    isOverride: number
    overrideByUserId: number
    overrideReason: number
    createdAt: number
    _all: number
  }


  export type VisitCheckEventAvgAggregateInputType = {
    lat?: true
    lng?: true
    accuracyM?: true
    computedDistanceM?: true
  }

  export type VisitCheckEventSumAggregateInputType = {
    lat?: true
    lng?: true
    accuracyM?: true
    computedDistanceM?: true
  }

  export type VisitCheckEventMinAggregateInputType = {
    id?: true
    visitId?: true
    pswId?: true
    eventType?: true
    lat?: true
    lng?: true
    accuracyM?: true
    computedDistanceM?: true
    deviceTimeIso?: true
    serverTime?: true
    result?: true
    rejectReason?: true
    isOverride?: true
    overrideByUserId?: true
    overrideReason?: true
    createdAt?: true
  }

  export type VisitCheckEventMaxAggregateInputType = {
    id?: true
    visitId?: true
    pswId?: true
    eventType?: true
    lat?: true
    lng?: true
    accuracyM?: true
    computedDistanceM?: true
    deviceTimeIso?: true
    serverTime?: true
    result?: true
    rejectReason?: true
    isOverride?: true
    overrideByUserId?: true
    overrideReason?: true
    createdAt?: true
  }

  export type VisitCheckEventCountAggregateInputType = {
    id?: true
    visitId?: true
    pswId?: true
    eventType?: true
    lat?: true
    lng?: true
    accuracyM?: true
    computedDistanceM?: true
    deviceTimeIso?: true
    serverTime?: true
    result?: true
    rejectReason?: true
    isOverride?: true
    overrideByUserId?: true
    overrideReason?: true
    createdAt?: true
    _all?: true
  }

  export type VisitCheckEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitCheckEvent to aggregate.
     */
    where?: VisitCheckEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCheckEvents to fetch.
     */
    orderBy?: VisitCheckEventOrderByWithRelationInput | VisitCheckEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitCheckEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCheckEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCheckEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitCheckEvents
    **/
    _count?: true | VisitCheckEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitCheckEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitCheckEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitCheckEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitCheckEventMaxAggregateInputType
  }

  export type GetVisitCheckEventAggregateType<T extends VisitCheckEventAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitCheckEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitCheckEvent[P]>
      : GetScalarType<T[P], AggregateVisitCheckEvent[P]>
  }




  export type VisitCheckEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitCheckEventWhereInput
    orderBy?: VisitCheckEventOrderByWithAggregationInput | VisitCheckEventOrderByWithAggregationInput[]
    by: VisitCheckEventScalarFieldEnum[] | VisitCheckEventScalarFieldEnum
    having?: VisitCheckEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitCheckEventCountAggregateInputType | true
    _avg?: VisitCheckEventAvgAggregateInputType
    _sum?: VisitCheckEventSumAggregateInputType
    _min?: VisitCheckEventMinAggregateInputType
    _max?: VisitCheckEventMaxAggregateInputType
  }

  export type VisitCheckEventGroupByOutputType = {
    id: string
    visitId: string
    pswId: string
    eventType: $Enums.EventType
    lat: number | null
    lng: number | null
    accuracyM: number | null
    computedDistanceM: number | null
    deviceTimeIso: Date | null
    serverTime: Date | null
    result: $Enums.EventResult
    rejectReason: string | null
    isOverride: boolean | null
    overrideByUserId: string | null
    overrideReason: string | null
    createdAt: Date
    _count: VisitCheckEventCountAggregateOutputType | null
    _avg: VisitCheckEventAvgAggregateOutputType | null
    _sum: VisitCheckEventSumAggregateOutputType | null
    _min: VisitCheckEventMinAggregateOutputType | null
    _max: VisitCheckEventMaxAggregateOutputType | null
  }

  type GetVisitCheckEventGroupByPayload<T extends VisitCheckEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitCheckEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitCheckEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitCheckEventGroupByOutputType[P]>
            : GetScalarType<T[P], VisitCheckEventGroupByOutputType[P]>
        }
      >
    >


  export type VisitCheckEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    pswId?: boolean
    eventType?: boolean
    lat?: boolean
    lng?: boolean
    accuracyM?: boolean
    computedDistanceM?: boolean
    deviceTimeIso?: boolean
    serverTime?: boolean
    result?: boolean
    rejectReason?: boolean
    isOverride?: boolean
    overrideByUserId?: boolean
    overrideReason?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    pswProfile?: boolean | PswProfileDefaultArgs<ExtArgs>
    overriddenBy?: boolean | VisitCheckEvent$overriddenByArgs<ExtArgs>
  }, ExtArgs["result"]["visitCheckEvent"]>

  export type VisitCheckEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    pswId?: boolean
    eventType?: boolean
    lat?: boolean
    lng?: boolean
    accuracyM?: boolean
    computedDistanceM?: boolean
    deviceTimeIso?: boolean
    serverTime?: boolean
    result?: boolean
    rejectReason?: boolean
    isOverride?: boolean
    overrideByUserId?: boolean
    overrideReason?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    pswProfile?: boolean | PswProfileDefaultArgs<ExtArgs>
    overriddenBy?: boolean | VisitCheckEvent$overriddenByArgs<ExtArgs>
  }, ExtArgs["result"]["visitCheckEvent"]>

  export type VisitCheckEventSelectScalar = {
    id?: boolean
    visitId?: boolean
    pswId?: boolean
    eventType?: boolean
    lat?: boolean
    lng?: boolean
    accuracyM?: boolean
    computedDistanceM?: boolean
    deviceTimeIso?: boolean
    serverTime?: boolean
    result?: boolean
    rejectReason?: boolean
    isOverride?: boolean
    overrideByUserId?: boolean
    overrideReason?: boolean
    createdAt?: boolean
  }

  export type VisitCheckEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    pswProfile?: boolean | PswProfileDefaultArgs<ExtArgs>
    overriddenBy?: boolean | VisitCheckEvent$overriddenByArgs<ExtArgs>
  }
  export type VisitCheckEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    pswProfile?: boolean | PswProfileDefaultArgs<ExtArgs>
    overriddenBy?: boolean | VisitCheckEvent$overriddenByArgs<ExtArgs>
  }

  export type $VisitCheckEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitCheckEvent"
    objects: {
      visit: Prisma.$VisitPayload<ExtArgs>
      pswProfile: Prisma.$PswProfilePayload<ExtArgs>
      overriddenBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      pswId: string
      eventType: $Enums.EventType
      lat: number | null
      lng: number | null
      accuracyM: number | null
      computedDistanceM: number | null
      deviceTimeIso: Date | null
      serverTime: Date | null
      result: $Enums.EventResult
      rejectReason: string | null
      isOverride: boolean | null
      overrideByUserId: string | null
      overrideReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["visitCheckEvent"]>
    composites: {}
  }

  type VisitCheckEventGetPayload<S extends boolean | null | undefined | VisitCheckEventDefaultArgs> = $Result.GetResult<Prisma.$VisitCheckEventPayload, S>

  type VisitCheckEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitCheckEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitCheckEventCountAggregateInputType | true
    }

  export interface VisitCheckEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitCheckEvent'], meta: { name: 'VisitCheckEvent' } }
    /**
     * Find zero or one VisitCheckEvent that matches the filter.
     * @param {VisitCheckEventFindUniqueArgs} args - Arguments to find a VisitCheckEvent
     * @example
     * // Get one VisitCheckEvent
     * const visitCheckEvent = await prisma.visitCheckEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitCheckEventFindUniqueArgs>(args: SelectSubset<T, VisitCheckEventFindUniqueArgs<ExtArgs>>): Prisma__VisitCheckEventClient<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisitCheckEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitCheckEventFindUniqueOrThrowArgs} args - Arguments to find a VisitCheckEvent
     * @example
     * // Get one VisitCheckEvent
     * const visitCheckEvent = await prisma.visitCheckEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitCheckEventFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitCheckEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitCheckEventClient<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisitCheckEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCheckEventFindFirstArgs} args - Arguments to find a VisitCheckEvent
     * @example
     * // Get one VisitCheckEvent
     * const visitCheckEvent = await prisma.visitCheckEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitCheckEventFindFirstArgs>(args?: SelectSubset<T, VisitCheckEventFindFirstArgs<ExtArgs>>): Prisma__VisitCheckEventClient<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisitCheckEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCheckEventFindFirstOrThrowArgs} args - Arguments to find a VisitCheckEvent
     * @example
     * // Get one VisitCheckEvent
     * const visitCheckEvent = await prisma.visitCheckEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitCheckEventFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitCheckEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitCheckEventClient<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisitCheckEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCheckEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitCheckEvents
     * const visitCheckEvents = await prisma.visitCheckEvent.findMany()
     * 
     * // Get first 10 VisitCheckEvents
     * const visitCheckEvents = await prisma.visitCheckEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitCheckEventWithIdOnly = await prisma.visitCheckEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitCheckEventFindManyArgs>(args?: SelectSubset<T, VisitCheckEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisitCheckEvent.
     * @param {VisitCheckEventCreateArgs} args - Arguments to create a VisitCheckEvent.
     * @example
     * // Create one VisitCheckEvent
     * const VisitCheckEvent = await prisma.visitCheckEvent.create({
     *   data: {
     *     // ... data to create a VisitCheckEvent
     *   }
     * })
     * 
     */
    create<T extends VisitCheckEventCreateArgs>(args: SelectSubset<T, VisitCheckEventCreateArgs<ExtArgs>>): Prisma__VisitCheckEventClient<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisitCheckEvents.
     * @param {VisitCheckEventCreateManyArgs} args - Arguments to create many VisitCheckEvents.
     * @example
     * // Create many VisitCheckEvents
     * const visitCheckEvent = await prisma.visitCheckEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitCheckEventCreateManyArgs>(args?: SelectSubset<T, VisitCheckEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitCheckEvents and returns the data saved in the database.
     * @param {VisitCheckEventCreateManyAndReturnArgs} args - Arguments to create many VisitCheckEvents.
     * @example
     * // Create many VisitCheckEvents
     * const visitCheckEvent = await prisma.visitCheckEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitCheckEvents and only return the `id`
     * const visitCheckEventWithIdOnly = await prisma.visitCheckEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitCheckEventCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitCheckEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisitCheckEvent.
     * @param {VisitCheckEventDeleteArgs} args - Arguments to delete one VisitCheckEvent.
     * @example
     * // Delete one VisitCheckEvent
     * const VisitCheckEvent = await prisma.visitCheckEvent.delete({
     *   where: {
     *     // ... filter to delete one VisitCheckEvent
     *   }
     * })
     * 
     */
    delete<T extends VisitCheckEventDeleteArgs>(args: SelectSubset<T, VisitCheckEventDeleteArgs<ExtArgs>>): Prisma__VisitCheckEventClient<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisitCheckEvent.
     * @param {VisitCheckEventUpdateArgs} args - Arguments to update one VisitCheckEvent.
     * @example
     * // Update one VisitCheckEvent
     * const visitCheckEvent = await prisma.visitCheckEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitCheckEventUpdateArgs>(args: SelectSubset<T, VisitCheckEventUpdateArgs<ExtArgs>>): Prisma__VisitCheckEventClient<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisitCheckEvents.
     * @param {VisitCheckEventDeleteManyArgs} args - Arguments to filter VisitCheckEvents to delete.
     * @example
     * // Delete a few VisitCheckEvents
     * const { count } = await prisma.visitCheckEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitCheckEventDeleteManyArgs>(args?: SelectSubset<T, VisitCheckEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitCheckEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCheckEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitCheckEvents
     * const visitCheckEvent = await prisma.visitCheckEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitCheckEventUpdateManyArgs>(args: SelectSubset<T, VisitCheckEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitCheckEvent.
     * @param {VisitCheckEventUpsertArgs} args - Arguments to update or create a VisitCheckEvent.
     * @example
     * // Update or create a VisitCheckEvent
     * const visitCheckEvent = await prisma.visitCheckEvent.upsert({
     *   create: {
     *     // ... data to create a VisitCheckEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitCheckEvent we want to update
     *   }
     * })
     */
    upsert<T extends VisitCheckEventUpsertArgs>(args: SelectSubset<T, VisitCheckEventUpsertArgs<ExtArgs>>): Prisma__VisitCheckEventClient<$Result.GetResult<Prisma.$VisitCheckEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisitCheckEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCheckEventCountArgs} args - Arguments to filter VisitCheckEvents to count.
     * @example
     * // Count the number of VisitCheckEvents
     * const count = await prisma.visitCheckEvent.count({
     *   where: {
     *     // ... the filter for the VisitCheckEvents we want to count
     *   }
     * })
    **/
    count<T extends VisitCheckEventCountArgs>(
      args?: Subset<T, VisitCheckEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitCheckEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitCheckEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCheckEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitCheckEventAggregateArgs>(args: Subset<T, VisitCheckEventAggregateArgs>): Prisma.PrismaPromise<GetVisitCheckEventAggregateType<T>>

    /**
     * Group by VisitCheckEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCheckEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitCheckEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitCheckEventGroupByArgs['orderBy'] }
        : { orderBy?: VisitCheckEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitCheckEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitCheckEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitCheckEvent model
   */
  readonly fields: VisitCheckEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitCheckEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitCheckEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends VisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisitDefaultArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pswProfile<T extends PswProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PswProfileDefaultArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    overriddenBy<T extends VisitCheckEvent$overriddenByArgs<ExtArgs> = {}>(args?: Subset<T, VisitCheckEvent$overriddenByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitCheckEvent model
   */ 
  interface VisitCheckEventFieldRefs {
    readonly id: FieldRef<"VisitCheckEvent", 'String'>
    readonly visitId: FieldRef<"VisitCheckEvent", 'String'>
    readonly pswId: FieldRef<"VisitCheckEvent", 'String'>
    readonly eventType: FieldRef<"VisitCheckEvent", 'EventType'>
    readonly lat: FieldRef<"VisitCheckEvent", 'Float'>
    readonly lng: FieldRef<"VisitCheckEvent", 'Float'>
    readonly accuracyM: FieldRef<"VisitCheckEvent", 'Float'>
    readonly computedDistanceM: FieldRef<"VisitCheckEvent", 'Float'>
    readonly deviceTimeIso: FieldRef<"VisitCheckEvent", 'DateTime'>
    readonly serverTime: FieldRef<"VisitCheckEvent", 'DateTime'>
    readonly result: FieldRef<"VisitCheckEvent", 'EventResult'>
    readonly rejectReason: FieldRef<"VisitCheckEvent", 'String'>
    readonly isOverride: FieldRef<"VisitCheckEvent", 'Boolean'>
    readonly overrideByUserId: FieldRef<"VisitCheckEvent", 'String'>
    readonly overrideReason: FieldRef<"VisitCheckEvent", 'String'>
    readonly createdAt: FieldRef<"VisitCheckEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitCheckEvent findUnique
   */
  export type VisitCheckEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    /**
     * Filter, which VisitCheckEvent to fetch.
     */
    where: VisitCheckEventWhereUniqueInput
  }

  /**
   * VisitCheckEvent findUniqueOrThrow
   */
  export type VisitCheckEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    /**
     * Filter, which VisitCheckEvent to fetch.
     */
    where: VisitCheckEventWhereUniqueInput
  }

  /**
   * VisitCheckEvent findFirst
   */
  export type VisitCheckEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    /**
     * Filter, which VisitCheckEvent to fetch.
     */
    where?: VisitCheckEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCheckEvents to fetch.
     */
    orderBy?: VisitCheckEventOrderByWithRelationInput | VisitCheckEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitCheckEvents.
     */
    cursor?: VisitCheckEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCheckEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCheckEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitCheckEvents.
     */
    distinct?: VisitCheckEventScalarFieldEnum | VisitCheckEventScalarFieldEnum[]
  }

  /**
   * VisitCheckEvent findFirstOrThrow
   */
  export type VisitCheckEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    /**
     * Filter, which VisitCheckEvent to fetch.
     */
    where?: VisitCheckEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCheckEvents to fetch.
     */
    orderBy?: VisitCheckEventOrderByWithRelationInput | VisitCheckEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitCheckEvents.
     */
    cursor?: VisitCheckEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCheckEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCheckEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitCheckEvents.
     */
    distinct?: VisitCheckEventScalarFieldEnum | VisitCheckEventScalarFieldEnum[]
  }

  /**
   * VisitCheckEvent findMany
   */
  export type VisitCheckEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    /**
     * Filter, which VisitCheckEvents to fetch.
     */
    where?: VisitCheckEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCheckEvents to fetch.
     */
    orderBy?: VisitCheckEventOrderByWithRelationInput | VisitCheckEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitCheckEvents.
     */
    cursor?: VisitCheckEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCheckEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCheckEvents.
     */
    skip?: number
    distinct?: VisitCheckEventScalarFieldEnum | VisitCheckEventScalarFieldEnum[]
  }

  /**
   * VisitCheckEvent create
   */
  export type VisitCheckEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitCheckEvent.
     */
    data: XOR<VisitCheckEventCreateInput, VisitCheckEventUncheckedCreateInput>
  }

  /**
   * VisitCheckEvent createMany
   */
  export type VisitCheckEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitCheckEvents.
     */
    data: VisitCheckEventCreateManyInput | VisitCheckEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitCheckEvent createManyAndReturn
   */
  export type VisitCheckEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisitCheckEvents.
     */
    data: VisitCheckEventCreateManyInput | VisitCheckEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitCheckEvent update
   */
  export type VisitCheckEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitCheckEvent.
     */
    data: XOR<VisitCheckEventUpdateInput, VisitCheckEventUncheckedUpdateInput>
    /**
     * Choose, which VisitCheckEvent to update.
     */
    where: VisitCheckEventWhereUniqueInput
  }

  /**
   * VisitCheckEvent updateMany
   */
  export type VisitCheckEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitCheckEvents.
     */
    data: XOR<VisitCheckEventUpdateManyMutationInput, VisitCheckEventUncheckedUpdateManyInput>
    /**
     * Filter which VisitCheckEvents to update
     */
    where?: VisitCheckEventWhereInput
  }

  /**
   * VisitCheckEvent upsert
   */
  export type VisitCheckEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitCheckEvent to update in case it exists.
     */
    where: VisitCheckEventWhereUniqueInput
    /**
     * In case the VisitCheckEvent found by the `where` argument doesn't exist, create a new VisitCheckEvent with this data.
     */
    create: XOR<VisitCheckEventCreateInput, VisitCheckEventUncheckedCreateInput>
    /**
     * In case the VisitCheckEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitCheckEventUpdateInput, VisitCheckEventUncheckedUpdateInput>
  }

  /**
   * VisitCheckEvent delete
   */
  export type VisitCheckEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
    /**
     * Filter which VisitCheckEvent to delete.
     */
    where: VisitCheckEventWhereUniqueInput
  }

  /**
   * VisitCheckEvent deleteMany
   */
  export type VisitCheckEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitCheckEvents to delete
     */
    where?: VisitCheckEventWhereInput
  }

  /**
   * VisitCheckEvent.overriddenBy
   */
  export type VisitCheckEvent$overriddenByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * VisitCheckEvent without action
   */
  export type VisitCheckEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCheckEvent
     */
    select?: VisitCheckEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCheckEventInclude<ExtArgs> | null
  }


  /**
   * Model VisitNote
   */

  export type AggregateVisitNote = {
    _count: VisitNoteCountAggregateOutputType | null
    _min: VisitNoteMinAggregateOutputType | null
    _max: VisitNoteMaxAggregateOutputType | null
  }

  export type VisitNoteMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    pswId: string | null
    noteText: string | null
    createdAt: Date | null
  }

  export type VisitNoteMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    pswId: string | null
    noteText: string | null
    createdAt: Date | null
  }

  export type VisitNoteCountAggregateOutputType = {
    id: number
    visitId: number
    pswId: number
    noteText: number
    createdAt: number
    _all: number
  }


  export type VisitNoteMinAggregateInputType = {
    id?: true
    visitId?: true
    pswId?: true
    noteText?: true
    createdAt?: true
  }

  export type VisitNoteMaxAggregateInputType = {
    id?: true
    visitId?: true
    pswId?: true
    noteText?: true
    createdAt?: true
  }

  export type VisitNoteCountAggregateInputType = {
    id?: true
    visitId?: true
    pswId?: true
    noteText?: true
    createdAt?: true
    _all?: true
  }

  export type VisitNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitNote to aggregate.
     */
    where?: VisitNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitNotes to fetch.
     */
    orderBy?: VisitNoteOrderByWithRelationInput | VisitNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitNotes
    **/
    _count?: true | VisitNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitNoteMaxAggregateInputType
  }

  export type GetVisitNoteAggregateType<T extends VisitNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitNote[P]>
      : GetScalarType<T[P], AggregateVisitNote[P]>
  }




  export type VisitNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitNoteWhereInput
    orderBy?: VisitNoteOrderByWithAggregationInput | VisitNoteOrderByWithAggregationInput[]
    by: VisitNoteScalarFieldEnum[] | VisitNoteScalarFieldEnum
    having?: VisitNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitNoteCountAggregateInputType | true
    _min?: VisitNoteMinAggregateInputType
    _max?: VisitNoteMaxAggregateInputType
  }

  export type VisitNoteGroupByOutputType = {
    id: string
    visitId: string
    pswId: string
    noteText: string
    createdAt: Date
    _count: VisitNoteCountAggregateOutputType | null
    _min: VisitNoteMinAggregateOutputType | null
    _max: VisitNoteMaxAggregateOutputType | null
  }

  type GetVisitNoteGroupByPayload<T extends VisitNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitNoteGroupByOutputType[P]>
            : GetScalarType<T[P], VisitNoteGroupByOutputType[P]>
        }
      >
    >


  export type VisitNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    pswId?: boolean
    noteText?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitNote"]>

  export type VisitNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    pswId?: boolean
    noteText?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitNote"]>

  export type VisitNoteSelectScalar = {
    id?: boolean
    visitId?: boolean
    pswId?: boolean
    noteText?: boolean
    createdAt?: boolean
  }

  export type VisitNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
  }
  export type VisitNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
  }

  export type $VisitNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitNote"
    objects: {
      visit: Prisma.$VisitPayload<ExtArgs>
      psw: Prisma.$PswProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      pswId: string
      noteText: string
      createdAt: Date
    }, ExtArgs["result"]["visitNote"]>
    composites: {}
  }

  type VisitNoteGetPayload<S extends boolean | null | undefined | VisitNoteDefaultArgs> = $Result.GetResult<Prisma.$VisitNotePayload, S>

  type VisitNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitNoteCountAggregateInputType | true
    }

  export interface VisitNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitNote'], meta: { name: 'VisitNote' } }
    /**
     * Find zero or one VisitNote that matches the filter.
     * @param {VisitNoteFindUniqueArgs} args - Arguments to find a VisitNote
     * @example
     * // Get one VisitNote
     * const visitNote = await prisma.visitNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitNoteFindUniqueArgs>(args: SelectSubset<T, VisitNoteFindUniqueArgs<ExtArgs>>): Prisma__VisitNoteClient<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisitNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitNoteFindUniqueOrThrowArgs} args - Arguments to find a VisitNote
     * @example
     * // Get one VisitNote
     * const visitNote = await prisma.visitNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitNoteClient<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisitNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitNoteFindFirstArgs} args - Arguments to find a VisitNote
     * @example
     * // Get one VisitNote
     * const visitNote = await prisma.visitNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitNoteFindFirstArgs>(args?: SelectSubset<T, VisitNoteFindFirstArgs<ExtArgs>>): Prisma__VisitNoteClient<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisitNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitNoteFindFirstOrThrowArgs} args - Arguments to find a VisitNote
     * @example
     * // Get one VisitNote
     * const visitNote = await prisma.visitNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitNoteClient<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisitNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitNotes
     * const visitNotes = await prisma.visitNote.findMany()
     * 
     * // Get first 10 VisitNotes
     * const visitNotes = await prisma.visitNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitNoteWithIdOnly = await prisma.visitNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitNoteFindManyArgs>(args?: SelectSubset<T, VisitNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisitNote.
     * @param {VisitNoteCreateArgs} args - Arguments to create a VisitNote.
     * @example
     * // Create one VisitNote
     * const VisitNote = await prisma.visitNote.create({
     *   data: {
     *     // ... data to create a VisitNote
     *   }
     * })
     * 
     */
    create<T extends VisitNoteCreateArgs>(args: SelectSubset<T, VisitNoteCreateArgs<ExtArgs>>): Prisma__VisitNoteClient<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisitNotes.
     * @param {VisitNoteCreateManyArgs} args - Arguments to create many VisitNotes.
     * @example
     * // Create many VisitNotes
     * const visitNote = await prisma.visitNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitNoteCreateManyArgs>(args?: SelectSubset<T, VisitNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitNotes and returns the data saved in the database.
     * @param {VisitNoteCreateManyAndReturnArgs} args - Arguments to create many VisitNotes.
     * @example
     * // Create many VisitNotes
     * const visitNote = await prisma.visitNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitNotes and only return the `id`
     * const visitNoteWithIdOnly = await prisma.visitNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisitNote.
     * @param {VisitNoteDeleteArgs} args - Arguments to delete one VisitNote.
     * @example
     * // Delete one VisitNote
     * const VisitNote = await prisma.visitNote.delete({
     *   where: {
     *     // ... filter to delete one VisitNote
     *   }
     * })
     * 
     */
    delete<T extends VisitNoteDeleteArgs>(args: SelectSubset<T, VisitNoteDeleteArgs<ExtArgs>>): Prisma__VisitNoteClient<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisitNote.
     * @param {VisitNoteUpdateArgs} args - Arguments to update one VisitNote.
     * @example
     * // Update one VisitNote
     * const visitNote = await prisma.visitNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitNoteUpdateArgs>(args: SelectSubset<T, VisitNoteUpdateArgs<ExtArgs>>): Prisma__VisitNoteClient<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisitNotes.
     * @param {VisitNoteDeleteManyArgs} args - Arguments to filter VisitNotes to delete.
     * @example
     * // Delete a few VisitNotes
     * const { count } = await prisma.visitNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitNoteDeleteManyArgs>(args?: SelectSubset<T, VisitNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitNotes
     * const visitNote = await prisma.visitNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitNoteUpdateManyArgs>(args: SelectSubset<T, VisitNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitNote.
     * @param {VisitNoteUpsertArgs} args - Arguments to update or create a VisitNote.
     * @example
     * // Update or create a VisitNote
     * const visitNote = await prisma.visitNote.upsert({
     *   create: {
     *     // ... data to create a VisitNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitNote we want to update
     *   }
     * })
     */
    upsert<T extends VisitNoteUpsertArgs>(args: SelectSubset<T, VisitNoteUpsertArgs<ExtArgs>>): Prisma__VisitNoteClient<$Result.GetResult<Prisma.$VisitNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisitNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitNoteCountArgs} args - Arguments to filter VisitNotes to count.
     * @example
     * // Count the number of VisitNotes
     * const count = await prisma.visitNote.count({
     *   where: {
     *     // ... the filter for the VisitNotes we want to count
     *   }
     * })
    **/
    count<T extends VisitNoteCountArgs>(
      args?: Subset<T, VisitNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitNoteAggregateArgs>(args: Subset<T, VisitNoteAggregateArgs>): Prisma.PrismaPromise<GetVisitNoteAggregateType<T>>

    /**
     * Group by VisitNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitNoteGroupByArgs['orderBy'] }
        : { orderBy?: VisitNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitNote model
   */
  readonly fields: VisitNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends VisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisitDefaultArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    psw<T extends PswProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PswProfileDefaultArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitNote model
   */ 
  interface VisitNoteFieldRefs {
    readonly id: FieldRef<"VisitNote", 'String'>
    readonly visitId: FieldRef<"VisitNote", 'String'>
    readonly pswId: FieldRef<"VisitNote", 'String'>
    readonly noteText: FieldRef<"VisitNote", 'String'>
    readonly createdAt: FieldRef<"VisitNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitNote findUnique
   */
  export type VisitNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    /**
     * Filter, which VisitNote to fetch.
     */
    where: VisitNoteWhereUniqueInput
  }

  /**
   * VisitNote findUniqueOrThrow
   */
  export type VisitNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    /**
     * Filter, which VisitNote to fetch.
     */
    where: VisitNoteWhereUniqueInput
  }

  /**
   * VisitNote findFirst
   */
  export type VisitNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    /**
     * Filter, which VisitNote to fetch.
     */
    where?: VisitNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitNotes to fetch.
     */
    orderBy?: VisitNoteOrderByWithRelationInput | VisitNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitNotes.
     */
    cursor?: VisitNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitNotes.
     */
    distinct?: VisitNoteScalarFieldEnum | VisitNoteScalarFieldEnum[]
  }

  /**
   * VisitNote findFirstOrThrow
   */
  export type VisitNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    /**
     * Filter, which VisitNote to fetch.
     */
    where?: VisitNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitNotes to fetch.
     */
    orderBy?: VisitNoteOrderByWithRelationInput | VisitNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitNotes.
     */
    cursor?: VisitNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitNotes.
     */
    distinct?: VisitNoteScalarFieldEnum | VisitNoteScalarFieldEnum[]
  }

  /**
   * VisitNote findMany
   */
  export type VisitNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    /**
     * Filter, which VisitNotes to fetch.
     */
    where?: VisitNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitNotes to fetch.
     */
    orderBy?: VisitNoteOrderByWithRelationInput | VisitNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitNotes.
     */
    cursor?: VisitNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitNotes.
     */
    skip?: number
    distinct?: VisitNoteScalarFieldEnum | VisitNoteScalarFieldEnum[]
  }

  /**
   * VisitNote create
   */
  export type VisitNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitNote.
     */
    data: XOR<VisitNoteCreateInput, VisitNoteUncheckedCreateInput>
  }

  /**
   * VisitNote createMany
   */
  export type VisitNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitNotes.
     */
    data: VisitNoteCreateManyInput | VisitNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitNote createManyAndReturn
   */
  export type VisitNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisitNotes.
     */
    data: VisitNoteCreateManyInput | VisitNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitNote update
   */
  export type VisitNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitNote.
     */
    data: XOR<VisitNoteUpdateInput, VisitNoteUncheckedUpdateInput>
    /**
     * Choose, which VisitNote to update.
     */
    where: VisitNoteWhereUniqueInput
  }

  /**
   * VisitNote updateMany
   */
  export type VisitNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitNotes.
     */
    data: XOR<VisitNoteUpdateManyMutationInput, VisitNoteUncheckedUpdateManyInput>
    /**
     * Filter which VisitNotes to update
     */
    where?: VisitNoteWhereInput
  }

  /**
   * VisitNote upsert
   */
  export type VisitNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitNote to update in case it exists.
     */
    where: VisitNoteWhereUniqueInput
    /**
     * In case the VisitNote found by the `where` argument doesn't exist, create a new VisitNote with this data.
     */
    create: XOR<VisitNoteCreateInput, VisitNoteUncheckedCreateInput>
    /**
     * In case the VisitNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitNoteUpdateInput, VisitNoteUncheckedUpdateInput>
  }

  /**
   * VisitNote delete
   */
  export type VisitNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
    /**
     * Filter which VisitNote to delete.
     */
    where: VisitNoteWhereUniqueInput
  }

  /**
   * VisitNote deleteMany
   */
  export type VisitNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitNotes to delete
     */
    where?: VisitNoteWhereInput
  }

  /**
   * VisitNote without action
   */
  export type VisitNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitNote
     */
    select?: VisitNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitNoteInclude<ExtArgs> | null
  }


  /**
   * Model VisitChecklist
   */

  export type AggregateVisitChecklist = {
    _count: VisitChecklistCountAggregateOutputType | null
    _min: VisitChecklistMinAggregateOutputType | null
    _max: VisitChecklistMaxAggregateOutputType | null
  }

  export type VisitChecklistMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    pswId: string | null
    createdAt: Date | null
  }

  export type VisitChecklistMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    pswId: string | null
    createdAt: Date | null
  }

  export type VisitChecklistCountAggregateOutputType = {
    id: number
    visitId: number
    pswId: number
    checklistJson: number
    createdAt: number
    _all: number
  }


  export type VisitChecklistMinAggregateInputType = {
    id?: true
    visitId?: true
    pswId?: true
    createdAt?: true
  }

  export type VisitChecklistMaxAggregateInputType = {
    id?: true
    visitId?: true
    pswId?: true
    createdAt?: true
  }

  export type VisitChecklistCountAggregateInputType = {
    id?: true
    visitId?: true
    pswId?: true
    checklistJson?: true
    createdAt?: true
    _all?: true
  }

  export type VisitChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitChecklist to aggregate.
     */
    where?: VisitChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitChecklists to fetch.
     */
    orderBy?: VisitChecklistOrderByWithRelationInput | VisitChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitChecklists
    **/
    _count?: true | VisitChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitChecklistMaxAggregateInputType
  }

  export type GetVisitChecklistAggregateType<T extends VisitChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitChecklist[P]>
      : GetScalarType<T[P], AggregateVisitChecklist[P]>
  }




  export type VisitChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitChecklistWhereInput
    orderBy?: VisitChecklistOrderByWithAggregationInput | VisitChecklistOrderByWithAggregationInput[]
    by: VisitChecklistScalarFieldEnum[] | VisitChecklistScalarFieldEnum
    having?: VisitChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitChecklistCountAggregateInputType | true
    _min?: VisitChecklistMinAggregateInputType
    _max?: VisitChecklistMaxAggregateInputType
  }

  export type VisitChecklistGroupByOutputType = {
    id: string
    visitId: string
    pswId: string
    checklistJson: JsonValue
    createdAt: Date
    _count: VisitChecklistCountAggregateOutputType | null
    _min: VisitChecklistMinAggregateOutputType | null
    _max: VisitChecklistMaxAggregateOutputType | null
  }

  type GetVisitChecklistGroupByPayload<T extends VisitChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], VisitChecklistGroupByOutputType[P]>
        }
      >
    >


  export type VisitChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    pswId?: boolean
    checklistJson?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitChecklist"]>

  export type VisitChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    pswId?: boolean
    checklistJson?: boolean
    createdAt?: boolean
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitChecklist"]>

  export type VisitChecklistSelectScalar = {
    id?: boolean
    visitId?: boolean
    pswId?: boolean
    checklistJson?: boolean
    createdAt?: boolean
  }

  export type VisitChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
  }
  export type VisitChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | VisitDefaultArgs<ExtArgs>
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
  }

  export type $VisitChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitChecklist"
    objects: {
      visit: Prisma.$VisitPayload<ExtArgs>
      psw: Prisma.$PswProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string
      pswId: string
      checklistJson: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["visitChecklist"]>
    composites: {}
  }

  type VisitChecklistGetPayload<S extends boolean | null | undefined | VisitChecklistDefaultArgs> = $Result.GetResult<Prisma.$VisitChecklistPayload, S>

  type VisitChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitChecklistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitChecklistCountAggregateInputType | true
    }

  export interface VisitChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitChecklist'], meta: { name: 'VisitChecklist' } }
    /**
     * Find zero or one VisitChecklist that matches the filter.
     * @param {VisitChecklistFindUniqueArgs} args - Arguments to find a VisitChecklist
     * @example
     * // Get one VisitChecklist
     * const visitChecklist = await prisma.visitChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitChecklistFindUniqueArgs>(args: SelectSubset<T, VisitChecklistFindUniqueArgs<ExtArgs>>): Prisma__VisitChecklistClient<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisitChecklist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitChecklistFindUniqueOrThrowArgs} args - Arguments to find a VisitChecklist
     * @example
     * // Get one VisitChecklist
     * const visitChecklist = await prisma.visitChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitChecklistClient<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisitChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitChecklistFindFirstArgs} args - Arguments to find a VisitChecklist
     * @example
     * // Get one VisitChecklist
     * const visitChecklist = await prisma.visitChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitChecklistFindFirstArgs>(args?: SelectSubset<T, VisitChecklistFindFirstArgs<ExtArgs>>): Prisma__VisitChecklistClient<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisitChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitChecklistFindFirstOrThrowArgs} args - Arguments to find a VisitChecklist
     * @example
     * // Get one VisitChecklist
     * const visitChecklist = await prisma.visitChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitChecklistClient<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisitChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitChecklists
     * const visitChecklists = await prisma.visitChecklist.findMany()
     * 
     * // Get first 10 VisitChecklists
     * const visitChecklists = await prisma.visitChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitChecklistWithIdOnly = await prisma.visitChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitChecklistFindManyArgs>(args?: SelectSubset<T, VisitChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisitChecklist.
     * @param {VisitChecklistCreateArgs} args - Arguments to create a VisitChecklist.
     * @example
     * // Create one VisitChecklist
     * const VisitChecklist = await prisma.visitChecklist.create({
     *   data: {
     *     // ... data to create a VisitChecklist
     *   }
     * })
     * 
     */
    create<T extends VisitChecklistCreateArgs>(args: SelectSubset<T, VisitChecklistCreateArgs<ExtArgs>>): Prisma__VisitChecklistClient<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisitChecklists.
     * @param {VisitChecklistCreateManyArgs} args - Arguments to create many VisitChecklists.
     * @example
     * // Create many VisitChecklists
     * const visitChecklist = await prisma.visitChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitChecklistCreateManyArgs>(args?: SelectSubset<T, VisitChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitChecklists and returns the data saved in the database.
     * @param {VisitChecklistCreateManyAndReturnArgs} args - Arguments to create many VisitChecklists.
     * @example
     * // Create many VisitChecklists
     * const visitChecklist = await prisma.visitChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitChecklists and only return the `id`
     * const visitChecklistWithIdOnly = await prisma.visitChecklist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisitChecklist.
     * @param {VisitChecklistDeleteArgs} args - Arguments to delete one VisitChecklist.
     * @example
     * // Delete one VisitChecklist
     * const VisitChecklist = await prisma.visitChecklist.delete({
     *   where: {
     *     // ... filter to delete one VisitChecklist
     *   }
     * })
     * 
     */
    delete<T extends VisitChecklistDeleteArgs>(args: SelectSubset<T, VisitChecklistDeleteArgs<ExtArgs>>): Prisma__VisitChecklistClient<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisitChecklist.
     * @param {VisitChecklistUpdateArgs} args - Arguments to update one VisitChecklist.
     * @example
     * // Update one VisitChecklist
     * const visitChecklist = await prisma.visitChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitChecklistUpdateArgs>(args: SelectSubset<T, VisitChecklistUpdateArgs<ExtArgs>>): Prisma__VisitChecklistClient<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisitChecklists.
     * @param {VisitChecklistDeleteManyArgs} args - Arguments to filter VisitChecklists to delete.
     * @example
     * // Delete a few VisitChecklists
     * const { count } = await prisma.visitChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitChecklistDeleteManyArgs>(args?: SelectSubset<T, VisitChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitChecklists
     * const visitChecklist = await prisma.visitChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitChecklistUpdateManyArgs>(args: SelectSubset<T, VisitChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitChecklist.
     * @param {VisitChecklistUpsertArgs} args - Arguments to update or create a VisitChecklist.
     * @example
     * // Update or create a VisitChecklist
     * const visitChecklist = await prisma.visitChecklist.upsert({
     *   create: {
     *     // ... data to create a VisitChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitChecklist we want to update
     *   }
     * })
     */
    upsert<T extends VisitChecklistUpsertArgs>(args: SelectSubset<T, VisitChecklistUpsertArgs<ExtArgs>>): Prisma__VisitChecklistClient<$Result.GetResult<Prisma.$VisitChecklistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisitChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitChecklistCountArgs} args - Arguments to filter VisitChecklists to count.
     * @example
     * // Count the number of VisitChecklists
     * const count = await prisma.visitChecklist.count({
     *   where: {
     *     // ... the filter for the VisitChecklists we want to count
     *   }
     * })
    **/
    count<T extends VisitChecklistCountArgs>(
      args?: Subset<T, VisitChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitChecklistAggregateArgs>(args: Subset<T, VisitChecklistAggregateArgs>): Prisma.PrismaPromise<GetVisitChecklistAggregateType<T>>

    /**
     * Group by VisitChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitChecklistGroupByArgs['orderBy'] }
        : { orderBy?: VisitChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitChecklist model
   */
  readonly fields: VisitChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends VisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisitDefaultArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    psw<T extends PswProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PswProfileDefaultArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitChecklist model
   */ 
  interface VisitChecklistFieldRefs {
    readonly id: FieldRef<"VisitChecklist", 'String'>
    readonly visitId: FieldRef<"VisitChecklist", 'String'>
    readonly pswId: FieldRef<"VisitChecklist", 'String'>
    readonly checklistJson: FieldRef<"VisitChecklist", 'Json'>
    readonly createdAt: FieldRef<"VisitChecklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitChecklist findUnique
   */
  export type VisitChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    /**
     * Filter, which VisitChecklist to fetch.
     */
    where: VisitChecklistWhereUniqueInput
  }

  /**
   * VisitChecklist findUniqueOrThrow
   */
  export type VisitChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    /**
     * Filter, which VisitChecklist to fetch.
     */
    where: VisitChecklistWhereUniqueInput
  }

  /**
   * VisitChecklist findFirst
   */
  export type VisitChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    /**
     * Filter, which VisitChecklist to fetch.
     */
    where?: VisitChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitChecklists to fetch.
     */
    orderBy?: VisitChecklistOrderByWithRelationInput | VisitChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitChecklists.
     */
    cursor?: VisitChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitChecklists.
     */
    distinct?: VisitChecklistScalarFieldEnum | VisitChecklistScalarFieldEnum[]
  }

  /**
   * VisitChecklist findFirstOrThrow
   */
  export type VisitChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    /**
     * Filter, which VisitChecklist to fetch.
     */
    where?: VisitChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitChecklists to fetch.
     */
    orderBy?: VisitChecklistOrderByWithRelationInput | VisitChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitChecklists.
     */
    cursor?: VisitChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitChecklists.
     */
    distinct?: VisitChecklistScalarFieldEnum | VisitChecklistScalarFieldEnum[]
  }

  /**
   * VisitChecklist findMany
   */
  export type VisitChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    /**
     * Filter, which VisitChecklists to fetch.
     */
    where?: VisitChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitChecklists to fetch.
     */
    orderBy?: VisitChecklistOrderByWithRelationInput | VisitChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitChecklists.
     */
    cursor?: VisitChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitChecklists.
     */
    skip?: number
    distinct?: VisitChecklistScalarFieldEnum | VisitChecklistScalarFieldEnum[]
  }

  /**
   * VisitChecklist create
   */
  export type VisitChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitChecklist.
     */
    data: XOR<VisitChecklistCreateInput, VisitChecklistUncheckedCreateInput>
  }

  /**
   * VisitChecklist createMany
   */
  export type VisitChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitChecklists.
     */
    data: VisitChecklistCreateManyInput | VisitChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitChecklist createManyAndReturn
   */
  export type VisitChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisitChecklists.
     */
    data: VisitChecklistCreateManyInput | VisitChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitChecklist update
   */
  export type VisitChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitChecklist.
     */
    data: XOR<VisitChecklistUpdateInput, VisitChecklistUncheckedUpdateInput>
    /**
     * Choose, which VisitChecklist to update.
     */
    where: VisitChecklistWhereUniqueInput
  }

  /**
   * VisitChecklist updateMany
   */
  export type VisitChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitChecklists.
     */
    data: XOR<VisitChecklistUpdateManyMutationInput, VisitChecklistUncheckedUpdateManyInput>
    /**
     * Filter which VisitChecklists to update
     */
    where?: VisitChecklistWhereInput
  }

  /**
   * VisitChecklist upsert
   */
  export type VisitChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitChecklist to update in case it exists.
     */
    where: VisitChecklistWhereUniqueInput
    /**
     * In case the VisitChecklist found by the `where` argument doesn't exist, create a new VisitChecklist with this data.
     */
    create: XOR<VisitChecklistCreateInput, VisitChecklistUncheckedCreateInput>
    /**
     * In case the VisitChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitChecklistUpdateInput, VisitChecklistUncheckedUpdateInput>
  }

  /**
   * VisitChecklist delete
   */
  export type VisitChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
    /**
     * Filter which VisitChecklist to delete.
     */
    where: VisitChecklistWhereUniqueInput
  }

  /**
   * VisitChecklist deleteMany
   */
  export type VisitChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitChecklists to delete
     */
    where?: VisitChecklistWhereInput
  }

  /**
   * VisitChecklist without action
   */
  export type VisitChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitChecklist
     */
    select?: VisitChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitChecklistInclude<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    visitId: string | null
    reporterUserId: string | null
    type: $Enums.IncidentType | null
    description: string | null
    status: $Enums.IncidentStatus | null
    resolutionNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    visitId: string | null
    reporterUserId: string | null
    type: $Enums.IncidentType | null
    description: string | null
    status: $Enums.IncidentStatus | null
    resolutionNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    visitId: number
    reporterUserId: number
    type: number
    description: number
    status: number
    resolutionNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncidentMinAggregateInputType = {
    id?: true
    visitId?: true
    reporterUserId?: true
    type?: true
    description?: true
    status?: true
    resolutionNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    visitId?: true
    reporterUserId?: true
    type?: true
    description?: true
    status?: true
    resolutionNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    visitId?: true
    reporterUserId?: true
    type?: true
    description?: true
    status?: true
    resolutionNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    visitId: string | null
    reporterUserId: string
    type: $Enums.IncidentType
    description: string
    status: $Enums.IncidentStatus | null
    resolutionNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    reporterUserId?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    resolutionNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | Incident$visitArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitId?: boolean
    reporterUserId?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    resolutionNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visit?: boolean | Incident$visitArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectScalar = {
    id?: boolean
    visitId?: boolean
    reporterUserId?: boolean
    type?: boolean
    description?: boolean
    status?: boolean
    resolutionNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | Incident$visitArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visit?: boolean | Incident$visitArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      visit: Prisma.$VisitPayload<ExtArgs> | null
      reporter: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitId: string | null
      reporterUserId: string
      type: $Enums.IncidentType
      description: string
      status: $Enums.IncidentStatus | null
      resolutionNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidents and returns the data saved in the database.
     * @param {IncidentCreateManyAndReturnArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visit<T extends Incident$visitArgs<ExtArgs> = {}>(args?: Subset<T, Incident$visitArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */ 
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly visitId: FieldRef<"Incident", 'String'>
    readonly reporterUserId: FieldRef<"Incident", 'String'>
    readonly type: FieldRef<"Incident", 'IncidentType'>
    readonly description: FieldRef<"Incident", 'String'>
    readonly status: FieldRef<"Incident", 'IncidentStatus'>
    readonly resolutionNotes: FieldRef<"Incident", 'String'>
    readonly createdAt: FieldRef<"Incident", 'DateTime'>
    readonly updatedAt: FieldRef<"Incident", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident createManyAndReturn
   */
  export type IncidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident.visit
   */
  export type Incident$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model Timesheet
   */

  export type AggregateTimesheet = {
    _count: TimesheetCountAggregateOutputType | null
    _avg: TimesheetAvgAggregateOutputType | null
    _sum: TimesheetSumAggregateOutputType | null
    _min: TimesheetMinAggregateOutputType | null
    _max: TimesheetMaxAggregateOutputType | null
  }

  export type TimesheetAvgAggregateOutputType = {
    totalMinutes: number | null
  }

  export type TimesheetSumAggregateOutputType = {
    totalMinutes: number | null
  }

  export type TimesheetMinAggregateOutputType = {
    id: string | null
    pswId: string | null
    weekId: string | null
    totalMinutes: number | null
    status: $Enums.TimesheetStatus | null
    submittedAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimesheetMaxAggregateOutputType = {
    id: string | null
    pswId: string | null
    weekId: string | null
    totalMinutes: number | null
    status: $Enums.TimesheetStatus | null
    submittedAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimesheetCountAggregateOutputType = {
    id: number
    pswId: number
    weekId: number
    totalMinutes: number
    status: number
    submittedAt: number
    reviewedBy: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimesheetAvgAggregateInputType = {
    totalMinutes?: true
  }

  export type TimesheetSumAggregateInputType = {
    totalMinutes?: true
  }

  export type TimesheetMinAggregateInputType = {
    id?: true
    pswId?: true
    weekId?: true
    totalMinutes?: true
    status?: true
    submittedAt?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimesheetMaxAggregateInputType = {
    id?: true
    pswId?: true
    weekId?: true
    totalMinutes?: true
    status?: true
    submittedAt?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimesheetCountAggregateInputType = {
    id?: true
    pswId?: true
    weekId?: true
    totalMinutes?: true
    status?: true
    submittedAt?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimesheetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timesheet to aggregate.
     */
    where?: TimesheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timesheets to fetch.
     */
    orderBy?: TimesheetOrderByWithRelationInput | TimesheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimesheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timesheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timesheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Timesheets
    **/
    _count?: true | TimesheetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimesheetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimesheetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimesheetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimesheetMaxAggregateInputType
  }

  export type GetTimesheetAggregateType<T extends TimesheetAggregateArgs> = {
        [P in keyof T & keyof AggregateTimesheet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimesheet[P]>
      : GetScalarType<T[P], AggregateTimesheet[P]>
  }




  export type TimesheetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimesheetWhereInput
    orderBy?: TimesheetOrderByWithAggregationInput | TimesheetOrderByWithAggregationInput[]
    by: TimesheetScalarFieldEnum[] | TimesheetScalarFieldEnum
    having?: TimesheetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimesheetCountAggregateInputType | true
    _avg?: TimesheetAvgAggregateInputType
    _sum?: TimesheetSumAggregateInputType
    _min?: TimesheetMinAggregateInputType
    _max?: TimesheetMaxAggregateInputType
  }

  export type TimesheetGroupByOutputType = {
    id: string
    pswId: string
    weekId: string
    totalMinutes: number | null
    status: $Enums.TimesheetStatus | null
    submittedAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TimesheetCountAggregateOutputType | null
    _avg: TimesheetAvgAggregateOutputType | null
    _sum: TimesheetSumAggregateOutputType | null
    _min: TimesheetMinAggregateOutputType | null
    _max: TimesheetMaxAggregateOutputType | null
  }

  type GetTimesheetGroupByPayload<T extends TimesheetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimesheetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimesheetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimesheetGroupByOutputType[P]>
            : GetScalarType<T[P], TimesheetGroupByOutputType[P]>
        }
      >
    >


  export type TimesheetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pswId?: boolean
    weekId?: boolean
    totalMinutes?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
    reviewer?: boolean | Timesheet$reviewerArgs<ExtArgs>
    items?: boolean | Timesheet$itemsArgs<ExtArgs>
    _count?: boolean | TimesheetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timesheet"]>

  export type TimesheetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pswId?: boolean
    weekId?: boolean
    totalMinutes?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
    reviewer?: boolean | Timesheet$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["timesheet"]>

  export type TimesheetSelectScalar = {
    id?: boolean
    pswId?: boolean
    weekId?: boolean
    totalMinutes?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimesheetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
    reviewer?: boolean | Timesheet$reviewerArgs<ExtArgs>
    items?: boolean | Timesheet$itemsArgs<ExtArgs>
    _count?: boolean | TimesheetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TimesheetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
    reviewer?: boolean | Timesheet$reviewerArgs<ExtArgs>
  }

  export type $TimesheetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Timesheet"
    objects: {
      psw: Prisma.$PswProfilePayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$TimesheetItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pswId: string
      weekId: string
      totalMinutes: number | null
      status: $Enums.TimesheetStatus | null
      submittedAt: Date | null
      reviewedBy: string | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timesheet"]>
    composites: {}
  }

  type TimesheetGetPayload<S extends boolean | null | undefined | TimesheetDefaultArgs> = $Result.GetResult<Prisma.$TimesheetPayload, S>

  type TimesheetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimesheetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimesheetCountAggregateInputType | true
    }

  export interface TimesheetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Timesheet'], meta: { name: 'Timesheet' } }
    /**
     * Find zero or one Timesheet that matches the filter.
     * @param {TimesheetFindUniqueArgs} args - Arguments to find a Timesheet
     * @example
     * // Get one Timesheet
     * const timesheet = await prisma.timesheet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimesheetFindUniqueArgs>(args: SelectSubset<T, TimesheetFindUniqueArgs<ExtArgs>>): Prisma__TimesheetClient<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Timesheet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimesheetFindUniqueOrThrowArgs} args - Arguments to find a Timesheet
     * @example
     * // Get one Timesheet
     * const timesheet = await prisma.timesheet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimesheetFindUniqueOrThrowArgs>(args: SelectSubset<T, TimesheetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimesheetClient<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Timesheet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetFindFirstArgs} args - Arguments to find a Timesheet
     * @example
     * // Get one Timesheet
     * const timesheet = await prisma.timesheet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimesheetFindFirstArgs>(args?: SelectSubset<T, TimesheetFindFirstArgs<ExtArgs>>): Prisma__TimesheetClient<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Timesheet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetFindFirstOrThrowArgs} args - Arguments to find a Timesheet
     * @example
     * // Get one Timesheet
     * const timesheet = await prisma.timesheet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimesheetFindFirstOrThrowArgs>(args?: SelectSubset<T, TimesheetFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimesheetClient<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Timesheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timesheets
     * const timesheets = await prisma.timesheet.findMany()
     * 
     * // Get first 10 Timesheets
     * const timesheets = await prisma.timesheet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timesheetWithIdOnly = await prisma.timesheet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimesheetFindManyArgs>(args?: SelectSubset<T, TimesheetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Timesheet.
     * @param {TimesheetCreateArgs} args - Arguments to create a Timesheet.
     * @example
     * // Create one Timesheet
     * const Timesheet = await prisma.timesheet.create({
     *   data: {
     *     // ... data to create a Timesheet
     *   }
     * })
     * 
     */
    create<T extends TimesheetCreateArgs>(args: SelectSubset<T, TimesheetCreateArgs<ExtArgs>>): Prisma__TimesheetClient<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Timesheets.
     * @param {TimesheetCreateManyArgs} args - Arguments to create many Timesheets.
     * @example
     * // Create many Timesheets
     * const timesheet = await prisma.timesheet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimesheetCreateManyArgs>(args?: SelectSubset<T, TimesheetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Timesheets and returns the data saved in the database.
     * @param {TimesheetCreateManyAndReturnArgs} args - Arguments to create many Timesheets.
     * @example
     * // Create many Timesheets
     * const timesheet = await prisma.timesheet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Timesheets and only return the `id`
     * const timesheetWithIdOnly = await prisma.timesheet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimesheetCreateManyAndReturnArgs>(args?: SelectSubset<T, TimesheetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Timesheet.
     * @param {TimesheetDeleteArgs} args - Arguments to delete one Timesheet.
     * @example
     * // Delete one Timesheet
     * const Timesheet = await prisma.timesheet.delete({
     *   where: {
     *     // ... filter to delete one Timesheet
     *   }
     * })
     * 
     */
    delete<T extends TimesheetDeleteArgs>(args: SelectSubset<T, TimesheetDeleteArgs<ExtArgs>>): Prisma__TimesheetClient<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Timesheet.
     * @param {TimesheetUpdateArgs} args - Arguments to update one Timesheet.
     * @example
     * // Update one Timesheet
     * const timesheet = await prisma.timesheet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimesheetUpdateArgs>(args: SelectSubset<T, TimesheetUpdateArgs<ExtArgs>>): Prisma__TimesheetClient<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Timesheets.
     * @param {TimesheetDeleteManyArgs} args - Arguments to filter Timesheets to delete.
     * @example
     * // Delete a few Timesheets
     * const { count } = await prisma.timesheet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimesheetDeleteManyArgs>(args?: SelectSubset<T, TimesheetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timesheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timesheets
     * const timesheet = await prisma.timesheet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimesheetUpdateManyArgs>(args: SelectSubset<T, TimesheetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Timesheet.
     * @param {TimesheetUpsertArgs} args - Arguments to update or create a Timesheet.
     * @example
     * // Update or create a Timesheet
     * const timesheet = await prisma.timesheet.upsert({
     *   create: {
     *     // ... data to create a Timesheet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timesheet we want to update
     *   }
     * })
     */
    upsert<T extends TimesheetUpsertArgs>(args: SelectSubset<T, TimesheetUpsertArgs<ExtArgs>>): Prisma__TimesheetClient<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Timesheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetCountArgs} args - Arguments to filter Timesheets to count.
     * @example
     * // Count the number of Timesheets
     * const count = await prisma.timesheet.count({
     *   where: {
     *     // ... the filter for the Timesheets we want to count
     *   }
     * })
    **/
    count<T extends TimesheetCountArgs>(
      args?: Subset<T, TimesheetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimesheetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timesheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimesheetAggregateArgs>(args: Subset<T, TimesheetAggregateArgs>): Prisma.PrismaPromise<GetTimesheetAggregateType<T>>

    /**
     * Group by Timesheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimesheetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimesheetGroupByArgs['orderBy'] }
        : { orderBy?: TimesheetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimesheetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimesheetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Timesheet model
   */
  readonly fields: TimesheetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Timesheet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimesheetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    psw<T extends PswProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PswProfileDefaultArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviewer<T extends Timesheet$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, Timesheet$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Timesheet$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Timesheet$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Timesheet model
   */ 
  interface TimesheetFieldRefs {
    readonly id: FieldRef<"Timesheet", 'String'>
    readonly pswId: FieldRef<"Timesheet", 'String'>
    readonly weekId: FieldRef<"Timesheet", 'String'>
    readonly totalMinutes: FieldRef<"Timesheet", 'Int'>
    readonly status: FieldRef<"Timesheet", 'TimesheetStatus'>
    readonly submittedAt: FieldRef<"Timesheet", 'DateTime'>
    readonly reviewedBy: FieldRef<"Timesheet", 'String'>
    readonly reviewedAt: FieldRef<"Timesheet", 'DateTime'>
    readonly createdAt: FieldRef<"Timesheet", 'DateTime'>
    readonly updatedAt: FieldRef<"Timesheet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Timesheet findUnique
   */
  export type TimesheetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    /**
     * Filter, which Timesheet to fetch.
     */
    where: TimesheetWhereUniqueInput
  }

  /**
   * Timesheet findUniqueOrThrow
   */
  export type TimesheetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    /**
     * Filter, which Timesheet to fetch.
     */
    where: TimesheetWhereUniqueInput
  }

  /**
   * Timesheet findFirst
   */
  export type TimesheetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    /**
     * Filter, which Timesheet to fetch.
     */
    where?: TimesheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timesheets to fetch.
     */
    orderBy?: TimesheetOrderByWithRelationInput | TimesheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timesheets.
     */
    cursor?: TimesheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timesheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timesheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timesheets.
     */
    distinct?: TimesheetScalarFieldEnum | TimesheetScalarFieldEnum[]
  }

  /**
   * Timesheet findFirstOrThrow
   */
  export type TimesheetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    /**
     * Filter, which Timesheet to fetch.
     */
    where?: TimesheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timesheets to fetch.
     */
    orderBy?: TimesheetOrderByWithRelationInput | TimesheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timesheets.
     */
    cursor?: TimesheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timesheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timesheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timesheets.
     */
    distinct?: TimesheetScalarFieldEnum | TimesheetScalarFieldEnum[]
  }

  /**
   * Timesheet findMany
   */
  export type TimesheetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    /**
     * Filter, which Timesheets to fetch.
     */
    where?: TimesheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timesheets to fetch.
     */
    orderBy?: TimesheetOrderByWithRelationInput | TimesheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Timesheets.
     */
    cursor?: TimesheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timesheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timesheets.
     */
    skip?: number
    distinct?: TimesheetScalarFieldEnum | TimesheetScalarFieldEnum[]
  }

  /**
   * Timesheet create
   */
  export type TimesheetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    /**
     * The data needed to create a Timesheet.
     */
    data: XOR<TimesheetCreateInput, TimesheetUncheckedCreateInput>
  }

  /**
   * Timesheet createMany
   */
  export type TimesheetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Timesheets.
     */
    data: TimesheetCreateManyInput | TimesheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Timesheet createManyAndReturn
   */
  export type TimesheetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Timesheets.
     */
    data: TimesheetCreateManyInput | TimesheetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Timesheet update
   */
  export type TimesheetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    /**
     * The data needed to update a Timesheet.
     */
    data: XOR<TimesheetUpdateInput, TimesheetUncheckedUpdateInput>
    /**
     * Choose, which Timesheet to update.
     */
    where: TimesheetWhereUniqueInput
  }

  /**
   * Timesheet updateMany
   */
  export type TimesheetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Timesheets.
     */
    data: XOR<TimesheetUpdateManyMutationInput, TimesheetUncheckedUpdateManyInput>
    /**
     * Filter which Timesheets to update
     */
    where?: TimesheetWhereInput
  }

  /**
   * Timesheet upsert
   */
  export type TimesheetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    /**
     * The filter to search for the Timesheet to update in case it exists.
     */
    where: TimesheetWhereUniqueInput
    /**
     * In case the Timesheet found by the `where` argument doesn't exist, create a new Timesheet with this data.
     */
    create: XOR<TimesheetCreateInput, TimesheetUncheckedCreateInput>
    /**
     * In case the Timesheet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimesheetUpdateInput, TimesheetUncheckedUpdateInput>
  }

  /**
   * Timesheet delete
   */
  export type TimesheetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
    /**
     * Filter which Timesheet to delete.
     */
    where: TimesheetWhereUniqueInput
  }

  /**
   * Timesheet deleteMany
   */
  export type TimesheetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timesheets to delete
     */
    where?: TimesheetWhereInput
  }

  /**
   * Timesheet.reviewer
   */
  export type Timesheet$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Timesheet.items
   */
  export type Timesheet$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    where?: TimesheetItemWhereInput
    orderBy?: TimesheetItemOrderByWithRelationInput | TimesheetItemOrderByWithRelationInput[]
    cursor?: TimesheetItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimesheetItemScalarFieldEnum | TimesheetItemScalarFieldEnum[]
  }

  /**
   * Timesheet without action
   */
  export type TimesheetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timesheet
     */
    select?: TimesheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetInclude<ExtArgs> | null
  }


  /**
   * Model TimesheetItem
   */

  export type AggregateTimesheetItem = {
    _count: TimesheetItemCountAggregateOutputType | null
    _avg: TimesheetItemAvgAggregateOutputType | null
    _sum: TimesheetItemSumAggregateOutputType | null
    _min: TimesheetItemMinAggregateOutputType | null
    _max: TimesheetItemMaxAggregateOutputType | null
  }

  export type TimesheetItemAvgAggregateOutputType = {
    minutes: number | null
  }

  export type TimesheetItemSumAggregateOutputType = {
    minutes: number | null
  }

  export type TimesheetItemMinAggregateOutputType = {
    id: string | null
    timesheetId: string | null
    visitId: string | null
    minutes: number | null
    createdAt: Date | null
  }

  export type TimesheetItemMaxAggregateOutputType = {
    id: string | null
    timesheetId: string | null
    visitId: string | null
    minutes: number | null
    createdAt: Date | null
  }

  export type TimesheetItemCountAggregateOutputType = {
    id: number
    timesheetId: number
    visitId: number
    minutes: number
    createdAt: number
    _all: number
  }


  export type TimesheetItemAvgAggregateInputType = {
    minutes?: true
  }

  export type TimesheetItemSumAggregateInputType = {
    minutes?: true
  }

  export type TimesheetItemMinAggregateInputType = {
    id?: true
    timesheetId?: true
    visitId?: true
    minutes?: true
    createdAt?: true
  }

  export type TimesheetItemMaxAggregateInputType = {
    id?: true
    timesheetId?: true
    visitId?: true
    minutes?: true
    createdAt?: true
  }

  export type TimesheetItemCountAggregateInputType = {
    id?: true
    timesheetId?: true
    visitId?: true
    minutes?: true
    createdAt?: true
    _all?: true
  }

  export type TimesheetItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimesheetItem to aggregate.
     */
    where?: TimesheetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimesheetItems to fetch.
     */
    orderBy?: TimesheetItemOrderByWithRelationInput | TimesheetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimesheetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimesheetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimesheetItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimesheetItems
    **/
    _count?: true | TimesheetItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimesheetItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimesheetItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimesheetItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimesheetItemMaxAggregateInputType
  }

  export type GetTimesheetItemAggregateType<T extends TimesheetItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTimesheetItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimesheetItem[P]>
      : GetScalarType<T[P], AggregateTimesheetItem[P]>
  }




  export type TimesheetItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimesheetItemWhereInput
    orderBy?: TimesheetItemOrderByWithAggregationInput | TimesheetItemOrderByWithAggregationInput[]
    by: TimesheetItemScalarFieldEnum[] | TimesheetItemScalarFieldEnum
    having?: TimesheetItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimesheetItemCountAggregateInputType | true
    _avg?: TimesheetItemAvgAggregateInputType
    _sum?: TimesheetItemSumAggregateInputType
    _min?: TimesheetItemMinAggregateInputType
    _max?: TimesheetItemMaxAggregateInputType
  }

  export type TimesheetItemGroupByOutputType = {
    id: string
    timesheetId: string
    visitId: string
    minutes: number
    createdAt: Date
    _count: TimesheetItemCountAggregateOutputType | null
    _avg: TimesheetItemAvgAggregateOutputType | null
    _sum: TimesheetItemSumAggregateOutputType | null
    _min: TimesheetItemMinAggregateOutputType | null
    _max: TimesheetItemMaxAggregateOutputType | null
  }

  type GetTimesheetItemGroupByPayload<T extends TimesheetItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimesheetItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimesheetItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimesheetItemGroupByOutputType[P]>
            : GetScalarType<T[P], TimesheetItemGroupByOutputType[P]>
        }
      >
    >


  export type TimesheetItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timesheetId?: boolean
    visitId?: boolean
    minutes?: boolean
    createdAt?: boolean
    timesheet?: boolean | TimesheetDefaultArgs<ExtArgs>
    visit?: boolean | VisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timesheetItem"]>

  export type TimesheetItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timesheetId?: boolean
    visitId?: boolean
    minutes?: boolean
    createdAt?: boolean
    timesheet?: boolean | TimesheetDefaultArgs<ExtArgs>
    visit?: boolean | VisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timesheetItem"]>

  export type TimesheetItemSelectScalar = {
    id?: boolean
    timesheetId?: boolean
    visitId?: boolean
    minutes?: boolean
    createdAt?: boolean
  }

  export type TimesheetItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timesheet?: boolean | TimesheetDefaultArgs<ExtArgs>
    visit?: boolean | VisitDefaultArgs<ExtArgs>
  }
  export type TimesheetItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timesheet?: boolean | TimesheetDefaultArgs<ExtArgs>
    visit?: boolean | VisitDefaultArgs<ExtArgs>
  }

  export type $TimesheetItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimesheetItem"
    objects: {
      timesheet: Prisma.$TimesheetPayload<ExtArgs>
      visit: Prisma.$VisitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timesheetId: string
      visitId: string
      minutes: number
      createdAt: Date
    }, ExtArgs["result"]["timesheetItem"]>
    composites: {}
  }

  type TimesheetItemGetPayload<S extends boolean | null | undefined | TimesheetItemDefaultArgs> = $Result.GetResult<Prisma.$TimesheetItemPayload, S>

  type TimesheetItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimesheetItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimesheetItemCountAggregateInputType | true
    }

  export interface TimesheetItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimesheetItem'], meta: { name: 'TimesheetItem' } }
    /**
     * Find zero or one TimesheetItem that matches the filter.
     * @param {TimesheetItemFindUniqueArgs} args - Arguments to find a TimesheetItem
     * @example
     * // Get one TimesheetItem
     * const timesheetItem = await prisma.timesheetItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimesheetItemFindUniqueArgs>(args: SelectSubset<T, TimesheetItemFindUniqueArgs<ExtArgs>>): Prisma__TimesheetItemClient<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimesheetItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimesheetItemFindUniqueOrThrowArgs} args - Arguments to find a TimesheetItem
     * @example
     * // Get one TimesheetItem
     * const timesheetItem = await prisma.timesheetItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimesheetItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TimesheetItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimesheetItemClient<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimesheetItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetItemFindFirstArgs} args - Arguments to find a TimesheetItem
     * @example
     * // Get one TimesheetItem
     * const timesheetItem = await prisma.timesheetItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimesheetItemFindFirstArgs>(args?: SelectSubset<T, TimesheetItemFindFirstArgs<ExtArgs>>): Prisma__TimesheetItemClient<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimesheetItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetItemFindFirstOrThrowArgs} args - Arguments to find a TimesheetItem
     * @example
     * // Get one TimesheetItem
     * const timesheetItem = await prisma.timesheetItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimesheetItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TimesheetItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimesheetItemClient<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimesheetItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimesheetItems
     * const timesheetItems = await prisma.timesheetItem.findMany()
     * 
     * // Get first 10 TimesheetItems
     * const timesheetItems = await prisma.timesheetItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timesheetItemWithIdOnly = await prisma.timesheetItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimesheetItemFindManyArgs>(args?: SelectSubset<T, TimesheetItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimesheetItem.
     * @param {TimesheetItemCreateArgs} args - Arguments to create a TimesheetItem.
     * @example
     * // Create one TimesheetItem
     * const TimesheetItem = await prisma.timesheetItem.create({
     *   data: {
     *     // ... data to create a TimesheetItem
     *   }
     * })
     * 
     */
    create<T extends TimesheetItemCreateArgs>(args: SelectSubset<T, TimesheetItemCreateArgs<ExtArgs>>): Prisma__TimesheetItemClient<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimesheetItems.
     * @param {TimesheetItemCreateManyArgs} args - Arguments to create many TimesheetItems.
     * @example
     * // Create many TimesheetItems
     * const timesheetItem = await prisma.timesheetItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimesheetItemCreateManyArgs>(args?: SelectSubset<T, TimesheetItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimesheetItems and returns the data saved in the database.
     * @param {TimesheetItemCreateManyAndReturnArgs} args - Arguments to create many TimesheetItems.
     * @example
     * // Create many TimesheetItems
     * const timesheetItem = await prisma.timesheetItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimesheetItems and only return the `id`
     * const timesheetItemWithIdOnly = await prisma.timesheetItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimesheetItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TimesheetItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimesheetItem.
     * @param {TimesheetItemDeleteArgs} args - Arguments to delete one TimesheetItem.
     * @example
     * // Delete one TimesheetItem
     * const TimesheetItem = await prisma.timesheetItem.delete({
     *   where: {
     *     // ... filter to delete one TimesheetItem
     *   }
     * })
     * 
     */
    delete<T extends TimesheetItemDeleteArgs>(args: SelectSubset<T, TimesheetItemDeleteArgs<ExtArgs>>): Prisma__TimesheetItemClient<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimesheetItem.
     * @param {TimesheetItemUpdateArgs} args - Arguments to update one TimesheetItem.
     * @example
     * // Update one TimesheetItem
     * const timesheetItem = await prisma.timesheetItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimesheetItemUpdateArgs>(args: SelectSubset<T, TimesheetItemUpdateArgs<ExtArgs>>): Prisma__TimesheetItemClient<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimesheetItems.
     * @param {TimesheetItemDeleteManyArgs} args - Arguments to filter TimesheetItems to delete.
     * @example
     * // Delete a few TimesheetItems
     * const { count } = await prisma.timesheetItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimesheetItemDeleteManyArgs>(args?: SelectSubset<T, TimesheetItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimesheetItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimesheetItems
     * const timesheetItem = await prisma.timesheetItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimesheetItemUpdateManyArgs>(args: SelectSubset<T, TimesheetItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimesheetItem.
     * @param {TimesheetItemUpsertArgs} args - Arguments to update or create a TimesheetItem.
     * @example
     * // Update or create a TimesheetItem
     * const timesheetItem = await prisma.timesheetItem.upsert({
     *   create: {
     *     // ... data to create a TimesheetItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimesheetItem we want to update
     *   }
     * })
     */
    upsert<T extends TimesheetItemUpsertArgs>(args: SelectSubset<T, TimesheetItemUpsertArgs<ExtArgs>>): Prisma__TimesheetItemClient<$Result.GetResult<Prisma.$TimesheetItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimesheetItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetItemCountArgs} args - Arguments to filter TimesheetItems to count.
     * @example
     * // Count the number of TimesheetItems
     * const count = await prisma.timesheetItem.count({
     *   where: {
     *     // ... the filter for the TimesheetItems we want to count
     *   }
     * })
    **/
    count<T extends TimesheetItemCountArgs>(
      args?: Subset<T, TimesheetItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimesheetItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimesheetItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimesheetItemAggregateArgs>(args: Subset<T, TimesheetItemAggregateArgs>): Prisma.PrismaPromise<GetTimesheetItemAggregateType<T>>

    /**
     * Group by TimesheetItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimesheetItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimesheetItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimesheetItemGroupByArgs['orderBy'] }
        : { orderBy?: TimesheetItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimesheetItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimesheetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimesheetItem model
   */
  readonly fields: TimesheetItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimesheetItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimesheetItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    timesheet<T extends TimesheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimesheetDefaultArgs<ExtArgs>>): Prisma__TimesheetClient<$Result.GetResult<Prisma.$TimesheetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    visit<T extends VisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisitDefaultArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimesheetItem model
   */ 
  interface TimesheetItemFieldRefs {
    readonly id: FieldRef<"TimesheetItem", 'String'>
    readonly timesheetId: FieldRef<"TimesheetItem", 'String'>
    readonly visitId: FieldRef<"TimesheetItem", 'String'>
    readonly minutes: FieldRef<"TimesheetItem", 'Int'>
    readonly createdAt: FieldRef<"TimesheetItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimesheetItem findUnique
   */
  export type TimesheetItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    /**
     * Filter, which TimesheetItem to fetch.
     */
    where: TimesheetItemWhereUniqueInput
  }

  /**
   * TimesheetItem findUniqueOrThrow
   */
  export type TimesheetItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    /**
     * Filter, which TimesheetItem to fetch.
     */
    where: TimesheetItemWhereUniqueInput
  }

  /**
   * TimesheetItem findFirst
   */
  export type TimesheetItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    /**
     * Filter, which TimesheetItem to fetch.
     */
    where?: TimesheetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimesheetItems to fetch.
     */
    orderBy?: TimesheetItemOrderByWithRelationInput | TimesheetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimesheetItems.
     */
    cursor?: TimesheetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimesheetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimesheetItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimesheetItems.
     */
    distinct?: TimesheetItemScalarFieldEnum | TimesheetItemScalarFieldEnum[]
  }

  /**
   * TimesheetItem findFirstOrThrow
   */
  export type TimesheetItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    /**
     * Filter, which TimesheetItem to fetch.
     */
    where?: TimesheetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimesheetItems to fetch.
     */
    orderBy?: TimesheetItemOrderByWithRelationInput | TimesheetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimesheetItems.
     */
    cursor?: TimesheetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimesheetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimesheetItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimesheetItems.
     */
    distinct?: TimesheetItemScalarFieldEnum | TimesheetItemScalarFieldEnum[]
  }

  /**
   * TimesheetItem findMany
   */
  export type TimesheetItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    /**
     * Filter, which TimesheetItems to fetch.
     */
    where?: TimesheetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimesheetItems to fetch.
     */
    orderBy?: TimesheetItemOrderByWithRelationInput | TimesheetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimesheetItems.
     */
    cursor?: TimesheetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimesheetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimesheetItems.
     */
    skip?: number
    distinct?: TimesheetItemScalarFieldEnum | TimesheetItemScalarFieldEnum[]
  }

  /**
   * TimesheetItem create
   */
  export type TimesheetItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TimesheetItem.
     */
    data: XOR<TimesheetItemCreateInput, TimesheetItemUncheckedCreateInput>
  }

  /**
   * TimesheetItem createMany
   */
  export type TimesheetItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimesheetItems.
     */
    data: TimesheetItemCreateManyInput | TimesheetItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimesheetItem createManyAndReturn
   */
  export type TimesheetItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimesheetItems.
     */
    data: TimesheetItemCreateManyInput | TimesheetItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimesheetItem update
   */
  export type TimesheetItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TimesheetItem.
     */
    data: XOR<TimesheetItemUpdateInput, TimesheetItemUncheckedUpdateInput>
    /**
     * Choose, which TimesheetItem to update.
     */
    where: TimesheetItemWhereUniqueInput
  }

  /**
   * TimesheetItem updateMany
   */
  export type TimesheetItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimesheetItems.
     */
    data: XOR<TimesheetItemUpdateManyMutationInput, TimesheetItemUncheckedUpdateManyInput>
    /**
     * Filter which TimesheetItems to update
     */
    where?: TimesheetItemWhereInput
  }

  /**
   * TimesheetItem upsert
   */
  export type TimesheetItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TimesheetItem to update in case it exists.
     */
    where: TimesheetItemWhereUniqueInput
    /**
     * In case the TimesheetItem found by the `where` argument doesn't exist, create a new TimesheetItem with this data.
     */
    create: XOR<TimesheetItemCreateInput, TimesheetItemUncheckedCreateInput>
    /**
     * In case the TimesheetItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimesheetItemUpdateInput, TimesheetItemUncheckedUpdateInput>
  }

  /**
   * TimesheetItem delete
   */
  export type TimesheetItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
    /**
     * Filter which TimesheetItem to delete.
     */
    where: TimesheetItemWhereUniqueInput
  }

  /**
   * TimesheetItem deleteMany
   */
  export type TimesheetItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimesheetItems to delete
     */
    where?: TimesheetItemWhereInput
  }

  /**
   * TimesheetItem without action
   */
  export type TimesheetItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimesheetItem
     */
    select?: TimesheetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimesheetItemInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    status: $Enums.InvoiceStatus | null
    currency: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    stripeInvoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    status: $Enums.InvoiceStatus | null
    currency: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    stripeInvoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    clientId: number
    status: number
    currency: number
    subtotal: number
    tax: number
    total: number
    stripeInvoiceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    clientId?: true
    status?: true
    currency?: true
    subtotal?: true
    tax?: true
    total?: true
    stripeInvoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    clientId?: true
    status?: true
    currency?: true
    subtotal?: true
    tax?: true
    total?: true
    stripeInvoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    clientId?: true
    status?: true
    currency?: true
    subtotal?: true
    tax?: true
    total?: true
    stripeInvoiceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    clientId: string
    status: $Enums.InvoiceStatus | null
    currency: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    stripeInvoiceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    status?: boolean
    currency?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    stripeInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    status?: boolean
    currency?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    stripeInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    clientId?: boolean
    status?: boolean
    currency?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    stripeInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      client: Prisma.$ClientProfilePayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      status: $Enums.InvoiceStatus | null
      currency: string | null
      subtotal: Prisma.Decimal | null
      tax: Prisma.Decimal | null
      total: Prisma.Decimal | null
      stripeInvoiceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly clientId: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly tax: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly stripeInvoiceId: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    stripePaymentIntentId: string | null
    amount: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    stripePaymentIntentId: string | null
    amount: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    stripePaymentIntentId: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    stripePaymentIntentId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    stripePaymentIntentId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    stripePaymentIntentId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    invoiceId: string
    stripePaymentIntentId: string | null
    amount: Decimal | null
    status: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    stripePaymentIntentId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    stripePaymentIntentId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    stripePaymentIntentId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      stripePaymentIntentId: string | null
      amount: Prisma.Decimal | null
      status: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly stripePaymentIntentId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model MessageThread
   */

  export type AggregateMessageThread = {
    _count: MessageThreadCountAggregateOutputType | null
    _min: MessageThreadMinAggregateOutputType | null
    _max: MessageThreadMaxAggregateOutputType | null
  }

  export type MessageThreadMinAggregateOutputType = {
    id: string | null
    threadType: string | null
    clientId: string | null
    pswId: string | null
    createdAt: Date | null
  }

  export type MessageThreadMaxAggregateOutputType = {
    id: string | null
    threadType: string | null
    clientId: string | null
    pswId: string | null
    createdAt: Date | null
  }

  export type MessageThreadCountAggregateOutputType = {
    id: number
    threadType: number
    clientId: number
    pswId: number
    createdAt: number
    _all: number
  }


  export type MessageThreadMinAggregateInputType = {
    id?: true
    threadType?: true
    clientId?: true
    pswId?: true
    createdAt?: true
  }

  export type MessageThreadMaxAggregateInputType = {
    id?: true
    threadType?: true
    clientId?: true
    pswId?: true
    createdAt?: true
  }

  export type MessageThreadCountAggregateInputType = {
    id?: true
    threadType?: true
    clientId?: true
    pswId?: true
    createdAt?: true
    _all?: true
  }

  export type MessageThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThread to aggregate.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageThreads
    **/
    _count?: true | MessageThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageThreadMaxAggregateInputType
  }

  export type GetMessageThreadAggregateType<T extends MessageThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageThread[P]>
      : GetScalarType<T[P], AggregateMessageThread[P]>
  }




  export type MessageThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageThreadWhereInput
    orderBy?: MessageThreadOrderByWithAggregationInput | MessageThreadOrderByWithAggregationInput[]
    by: MessageThreadScalarFieldEnum[] | MessageThreadScalarFieldEnum
    having?: MessageThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageThreadCountAggregateInputType | true
    _min?: MessageThreadMinAggregateInputType
    _max?: MessageThreadMaxAggregateInputType
  }

  export type MessageThreadGroupByOutputType = {
    id: string
    threadType: string
    clientId: string | null
    pswId: string | null
    createdAt: Date
    _count: MessageThreadCountAggregateOutputType | null
    _min: MessageThreadMinAggregateOutputType | null
    _max: MessageThreadMaxAggregateOutputType | null
  }

  type GetMessageThreadGroupByPayload<T extends MessageThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageThreadGroupByOutputType[P]>
            : GetScalarType<T[P], MessageThreadGroupByOutputType[P]>
        }
      >
    >


  export type MessageThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadType?: boolean
    clientId?: boolean
    pswId?: boolean
    createdAt?: boolean
    client?: boolean | MessageThread$clientArgs<ExtArgs>
    psw?: boolean | MessageThread$pswArgs<ExtArgs>
    messages?: boolean | MessageThread$messagesArgs<ExtArgs>
    _count?: boolean | MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageThread"]>

  export type MessageThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadType?: boolean
    clientId?: boolean
    pswId?: boolean
    createdAt?: boolean
    client?: boolean | MessageThread$clientArgs<ExtArgs>
    psw?: boolean | MessageThread$pswArgs<ExtArgs>
  }, ExtArgs["result"]["messageThread"]>

  export type MessageThreadSelectScalar = {
    id?: boolean
    threadType?: boolean
    clientId?: boolean
    pswId?: boolean
    createdAt?: boolean
  }

  export type MessageThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | MessageThread$clientArgs<ExtArgs>
    psw?: boolean | MessageThread$pswArgs<ExtArgs>
    messages?: boolean | MessageThread$messagesArgs<ExtArgs>
    _count?: boolean | MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | MessageThread$clientArgs<ExtArgs>
    psw?: boolean | MessageThread$pswArgs<ExtArgs>
  }

  export type $MessageThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageThread"
    objects: {
      client: Prisma.$ClientProfilePayload<ExtArgs> | null
      psw: Prisma.$PswProfilePayload<ExtArgs> | null
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadType: string
      clientId: string | null
      pswId: string | null
      createdAt: Date
    }, ExtArgs["result"]["messageThread"]>
    composites: {}
  }

  type MessageThreadGetPayload<S extends boolean | null | undefined | MessageThreadDefaultArgs> = $Result.GetResult<Prisma.$MessageThreadPayload, S>

  type MessageThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageThreadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageThreadCountAggregateInputType | true
    }

  export interface MessageThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageThread'], meta: { name: 'MessageThread' } }
    /**
     * Find zero or one MessageThread that matches the filter.
     * @param {MessageThreadFindUniqueArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageThreadFindUniqueArgs>(args: SelectSubset<T, MessageThreadFindUniqueArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageThread that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageThreadFindUniqueOrThrowArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindFirstArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageThreadFindFirstArgs>(args?: SelectSubset<T, MessageThreadFindFirstArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindFirstOrThrowArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageThreads
     * const messageThreads = await prisma.messageThread.findMany()
     * 
     * // Get first 10 MessageThreads
     * const messageThreads = await prisma.messageThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageThreadWithIdOnly = await prisma.messageThread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageThreadFindManyArgs>(args?: SelectSubset<T, MessageThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageThread.
     * @param {MessageThreadCreateArgs} args - Arguments to create a MessageThread.
     * @example
     * // Create one MessageThread
     * const MessageThread = await prisma.messageThread.create({
     *   data: {
     *     // ... data to create a MessageThread
     *   }
     * })
     * 
     */
    create<T extends MessageThreadCreateArgs>(args: SelectSubset<T, MessageThreadCreateArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageThreads.
     * @param {MessageThreadCreateManyArgs} args - Arguments to create many MessageThreads.
     * @example
     * // Create many MessageThreads
     * const messageThread = await prisma.messageThread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageThreadCreateManyArgs>(args?: SelectSubset<T, MessageThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageThreads and returns the data saved in the database.
     * @param {MessageThreadCreateManyAndReturnArgs} args - Arguments to create many MessageThreads.
     * @example
     * // Create many MessageThreads
     * const messageThread = await prisma.messageThread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageThreads and only return the `id`
     * const messageThreadWithIdOnly = await prisma.messageThread.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageThread.
     * @param {MessageThreadDeleteArgs} args - Arguments to delete one MessageThread.
     * @example
     * // Delete one MessageThread
     * const MessageThread = await prisma.messageThread.delete({
     *   where: {
     *     // ... filter to delete one MessageThread
     *   }
     * })
     * 
     */
    delete<T extends MessageThreadDeleteArgs>(args: SelectSubset<T, MessageThreadDeleteArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageThread.
     * @param {MessageThreadUpdateArgs} args - Arguments to update one MessageThread.
     * @example
     * // Update one MessageThread
     * const messageThread = await prisma.messageThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageThreadUpdateArgs>(args: SelectSubset<T, MessageThreadUpdateArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageThreads.
     * @param {MessageThreadDeleteManyArgs} args - Arguments to filter MessageThreads to delete.
     * @example
     * // Delete a few MessageThreads
     * const { count } = await prisma.messageThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageThreadDeleteManyArgs>(args?: SelectSubset<T, MessageThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageThreads
     * const messageThread = await prisma.messageThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageThreadUpdateManyArgs>(args: SelectSubset<T, MessageThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageThread.
     * @param {MessageThreadUpsertArgs} args - Arguments to update or create a MessageThread.
     * @example
     * // Update or create a MessageThread
     * const messageThread = await prisma.messageThread.upsert({
     *   create: {
     *     // ... data to create a MessageThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageThread we want to update
     *   }
     * })
     */
    upsert<T extends MessageThreadUpsertArgs>(args: SelectSubset<T, MessageThreadUpsertArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadCountArgs} args - Arguments to filter MessageThreads to count.
     * @example
     * // Count the number of MessageThreads
     * const count = await prisma.messageThread.count({
     *   where: {
     *     // ... the filter for the MessageThreads we want to count
     *   }
     * })
    **/
    count<T extends MessageThreadCountArgs>(
      args?: Subset<T, MessageThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageThreadAggregateArgs>(args: Subset<T, MessageThreadAggregateArgs>): Prisma.PrismaPromise<GetMessageThreadAggregateType<T>>

    /**
     * Group by MessageThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageThreadGroupByArgs['orderBy'] }
        : { orderBy?: MessageThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageThread model
   */
  readonly fields: MessageThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends MessageThread$clientArgs<ExtArgs> = {}>(args?: Subset<T, MessageThread$clientArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    psw<T extends MessageThread$pswArgs<ExtArgs> = {}>(args?: Subset<T, MessageThread$pswArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    messages<T extends MessageThread$messagesArgs<ExtArgs> = {}>(args?: Subset<T, MessageThread$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageThread model
   */ 
  interface MessageThreadFieldRefs {
    readonly id: FieldRef<"MessageThread", 'String'>
    readonly threadType: FieldRef<"MessageThread", 'String'>
    readonly clientId: FieldRef<"MessageThread", 'String'>
    readonly pswId: FieldRef<"MessageThread", 'String'>
    readonly createdAt: FieldRef<"MessageThread", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageThread findUnique
   */
  export type MessageThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread findUniqueOrThrow
   */
  export type MessageThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread findFirst
   */
  export type MessageThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreads.
     */
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * MessageThread findFirstOrThrow
   */
  export type MessageThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreads.
     */
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * MessageThread findMany
   */
  export type MessageThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThreads to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * MessageThread create
   */
  export type MessageThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageThread.
     */
    data: XOR<MessageThreadCreateInput, MessageThreadUncheckedCreateInput>
  }

  /**
   * MessageThread createMany
   */
  export type MessageThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageThreads.
     */
    data: MessageThreadCreateManyInput | MessageThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageThread createManyAndReturn
   */
  export type MessageThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageThreads.
     */
    data: MessageThreadCreateManyInput | MessageThreadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageThread update
   */
  export type MessageThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageThread.
     */
    data: XOR<MessageThreadUpdateInput, MessageThreadUncheckedUpdateInput>
    /**
     * Choose, which MessageThread to update.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread updateMany
   */
  export type MessageThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageThreads.
     */
    data: XOR<MessageThreadUpdateManyMutationInput, MessageThreadUncheckedUpdateManyInput>
    /**
     * Filter which MessageThreads to update
     */
    where?: MessageThreadWhereInput
  }

  /**
   * MessageThread upsert
   */
  export type MessageThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageThread to update in case it exists.
     */
    where: MessageThreadWhereUniqueInput
    /**
     * In case the MessageThread found by the `where` argument doesn't exist, create a new MessageThread with this data.
     */
    create: XOR<MessageThreadCreateInput, MessageThreadUncheckedCreateInput>
    /**
     * In case the MessageThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageThreadUpdateInput, MessageThreadUncheckedUpdateInput>
  }

  /**
   * MessageThread delete
   */
  export type MessageThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter which MessageThread to delete.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread deleteMany
   */
  export type MessageThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThreads to delete
     */
    where?: MessageThreadWhereInput
  }

  /**
   * MessageThread.client
   */
  export type MessageThread$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    where?: ClientProfileWhereInput
  }

  /**
   * MessageThread.psw
   */
  export type MessageThread$pswArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswProfile
     */
    select?: PswProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswProfileInclude<ExtArgs> | null
    where?: PswProfileWhereInput
  }

  /**
   * MessageThread.messages
   */
  export type MessageThread$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * MessageThread without action
   */
  export type MessageThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    senderUserId: string | null
    bodyText: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    senderUserId: string | null
    bodyText: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    threadId: number
    senderUserId: number
    bodyText: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    threadId?: true
    senderUserId?: true
    bodyText?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    threadId?: true
    senderUserId?: true
    bodyText?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    threadId?: true
    senderUserId?: true
    bodyText?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    threadId: string
    senderUserId: string
    bodyText: string
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderUserId?: boolean
    bodyText?: boolean
    createdAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderUserId?: boolean
    bodyText?: boolean
    createdAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    threadId?: boolean
    senderUserId?: boolean
    bodyText?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      thread: Prisma.$MessageThreadPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      senderUserId: string
      bodyText: string
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thread<T extends MessageThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageThreadDefaultArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly threadId: FieldRef<"Message", 'String'>
    readonly senderUserId: FieldRef<"Message", 'String'>
    readonly bodyText: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorUserId: string | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorUserId: string | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorUserId: number
    action: number
    resourceType: number
    resourceId: number
    metadataJson: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorUserId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorUserId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorUserId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    metadataJson?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorUserId: string | null
    action: string
    resourceType: string
    resourceId: string | null
    metadataJson: JsonValue | null
    ipAddress: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorUserId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    metadataJson?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorUserId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    metadataJson?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorUserId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    metadataJson?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorUserId: string | null
      action: string
      resourceType: string
      resourceId: string | null
      metadataJson: Prisma.JsonValue | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorUserId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resourceType: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly metadataJson: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    message: string | null
    source: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    message: string | null
    source: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    fullName: number
    email: number
    phone: number
    message: number
    source: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    message?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    message?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    message?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    fullName: string
    email: string
    phone: string | null
    message: string | null
    source: string
    status: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    message?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    message?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    message?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      email: string
      phone: string | null
      message: string | null
      source: string
      status: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */ 
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly fullName: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly message: FieldRef<"Lead", 'String'>
    readonly source: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    contentHtml: string | null
    status: string | null
    publishedAt: Date | null
    authorUserId: string | null
    featureImageDocId: string | null
    seoTitle: string | null
    seoDescription: string | null
    canonicalUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    contentHtml: string | null
    status: string | null
    publishedAt: Date | null
    authorUserId: string | null
    featureImageDocId: string | null
    seoTitle: string | null
    seoDescription: string | null
    canonicalUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    excerpt: number
    contentHtml: number
    status: number
    publishedAt: number
    authorUserId: number
    featureImageDocId: number
    seoTitle: number
    seoDescription: number
    canonicalUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    contentHtml?: true
    status?: true
    publishedAt?: true
    authorUserId?: true
    featureImageDocId?: true
    seoTitle?: true
    seoDescription?: true
    canonicalUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    contentHtml?: true
    status?: true
    publishedAt?: true
    authorUserId?: true
    featureImageDocId?: true
    seoTitle?: true
    seoDescription?: true
    canonicalUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    contentHtml?: true
    status?: true
    publishedAt?: true
    authorUserId?: true
    featureImageDocId?: true
    seoTitle?: true
    seoDescription?: true
    canonicalUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    slug: string
    excerpt: string | null
    contentHtml: string | null
    status: string | null
    publishedAt: Date | null
    authorUserId: string | null
    featureImageDocId: string | null
    seoTitle: string | null
    seoDescription: string | null
    canonicalUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    contentHtml?: boolean
    status?: boolean
    publishedAt?: boolean
    authorUserId?: boolean
    featureImageDocId?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    canonicalUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | BlogPost$authorArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    contentHtml?: boolean
    status?: boolean
    publishedAt?: boolean
    authorUserId?: boolean
    featureImageDocId?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    canonicalUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | BlogPost$authorArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    contentHtml?: boolean
    status?: boolean
    publishedAt?: boolean
    authorUserId?: boolean
    featureImageDocId?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    canonicalUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | BlogPost$authorArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | BlogPost$authorArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      author: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      excerpt: string | null
      contentHtml: string | null
      status: string | null
      publishedAt: Date | null
      authorUserId: string | null
      featureImageDocId: string | null
      seoTitle: string | null
      seoDescription: string | null
      canonicalUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends BlogPost$authorArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */ 
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly contentHtml: FieldRef<"BlogPost", 'String'>
    readonly status: FieldRef<"BlogPost", 'String'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly authorUserId: FieldRef<"BlogPost", 'String'>
    readonly featureImageDocId: FieldRef<"BlogPost", 'String'>
    readonly seoTitle: FieldRef<"BlogPost", 'String'>
    readonly seoDescription: FieldRef<"BlogPost", 'String'>
    readonly canonicalUrl: FieldRef<"BlogPost", 'String'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost.author
   */
  export type BlogPost$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model PswDocument
   */

  export type AggregatePswDocument = {
    _count: PswDocumentCountAggregateOutputType | null
    _min: PswDocumentMinAggregateOutputType | null
    _max: PswDocumentMaxAggregateOutputType | null
  }

  export type PswDocumentMinAggregateOutputType = {
    id: string | null
    pswId: string | null
    docType: string | null
    fileKey: string | null
    status: $Enums.DocStatus | null
    expiryDate: Date | null
    verifiedBy: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PswDocumentMaxAggregateOutputType = {
    id: string | null
    pswId: string | null
    docType: string | null
    fileKey: string | null
    status: $Enums.DocStatus | null
    expiryDate: Date | null
    verifiedBy: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PswDocumentCountAggregateOutputType = {
    id: number
    pswId: number
    docType: number
    fileKey: number
    status: number
    expiryDate: number
    verifiedBy: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PswDocumentMinAggregateInputType = {
    id?: true
    pswId?: true
    docType?: true
    fileKey?: true
    status?: true
    expiryDate?: true
    verifiedBy?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PswDocumentMaxAggregateInputType = {
    id?: true
    pswId?: true
    docType?: true
    fileKey?: true
    status?: true
    expiryDate?: true
    verifiedBy?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PswDocumentCountAggregateInputType = {
    id?: true
    pswId?: true
    docType?: true
    fileKey?: true
    status?: true
    expiryDate?: true
    verifiedBy?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PswDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PswDocument to aggregate.
     */
    where?: PswDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PswDocuments to fetch.
     */
    orderBy?: PswDocumentOrderByWithRelationInput | PswDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PswDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PswDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PswDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PswDocuments
    **/
    _count?: true | PswDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PswDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PswDocumentMaxAggregateInputType
  }

  export type GetPswDocumentAggregateType<T extends PswDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregatePswDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePswDocument[P]>
      : GetScalarType<T[P], AggregatePswDocument[P]>
  }




  export type PswDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PswDocumentWhereInput
    orderBy?: PswDocumentOrderByWithAggregationInput | PswDocumentOrderByWithAggregationInput[]
    by: PswDocumentScalarFieldEnum[] | PswDocumentScalarFieldEnum
    having?: PswDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PswDocumentCountAggregateInputType | true
    _min?: PswDocumentMinAggregateInputType
    _max?: PswDocumentMaxAggregateInputType
  }

  export type PswDocumentGroupByOutputType = {
    id: string
    pswId: string
    docType: string
    fileKey: string
    status: $Enums.DocStatus | null
    expiryDate: Date | null
    verifiedBy: string | null
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PswDocumentCountAggregateOutputType | null
    _min: PswDocumentMinAggregateOutputType | null
    _max: PswDocumentMaxAggregateOutputType | null
  }

  type GetPswDocumentGroupByPayload<T extends PswDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PswDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PswDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PswDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], PswDocumentGroupByOutputType[P]>
        }
      >
    >


  export type PswDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pswId?: boolean
    docType?: boolean
    fileKey?: boolean
    status?: boolean
    expiryDate?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
    verifier?: boolean | PswDocument$verifierArgs<ExtArgs>
  }, ExtArgs["result"]["pswDocument"]>

  export type PswDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pswId?: boolean
    docType?: boolean
    fileKey?: boolean
    status?: boolean
    expiryDate?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
    verifier?: boolean | PswDocument$verifierArgs<ExtArgs>
  }, ExtArgs["result"]["pswDocument"]>

  export type PswDocumentSelectScalar = {
    id?: boolean
    pswId?: boolean
    docType?: boolean
    fileKey?: boolean
    status?: boolean
    expiryDate?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PswDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
    verifier?: boolean | PswDocument$verifierArgs<ExtArgs>
  }
  export type PswDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    psw?: boolean | PswProfileDefaultArgs<ExtArgs>
    verifier?: boolean | PswDocument$verifierArgs<ExtArgs>
  }

  export type $PswDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PswDocument"
    objects: {
      psw: Prisma.$PswProfilePayload<ExtArgs>
      verifier: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pswId: string
      docType: string
      fileKey: string
      status: $Enums.DocStatus | null
      expiryDate: Date | null
      verifiedBy: string | null
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pswDocument"]>
    composites: {}
  }

  type PswDocumentGetPayload<S extends boolean | null | undefined | PswDocumentDefaultArgs> = $Result.GetResult<Prisma.$PswDocumentPayload, S>

  type PswDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PswDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PswDocumentCountAggregateInputType | true
    }

  export interface PswDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PswDocument'], meta: { name: 'PswDocument' } }
    /**
     * Find zero or one PswDocument that matches the filter.
     * @param {PswDocumentFindUniqueArgs} args - Arguments to find a PswDocument
     * @example
     * // Get one PswDocument
     * const pswDocument = await prisma.pswDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PswDocumentFindUniqueArgs>(args: SelectSubset<T, PswDocumentFindUniqueArgs<ExtArgs>>): Prisma__PswDocumentClient<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PswDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PswDocumentFindUniqueOrThrowArgs} args - Arguments to find a PswDocument
     * @example
     * // Get one PswDocument
     * const pswDocument = await prisma.pswDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PswDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, PswDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PswDocumentClient<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PswDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswDocumentFindFirstArgs} args - Arguments to find a PswDocument
     * @example
     * // Get one PswDocument
     * const pswDocument = await prisma.pswDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PswDocumentFindFirstArgs>(args?: SelectSubset<T, PswDocumentFindFirstArgs<ExtArgs>>): Prisma__PswDocumentClient<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PswDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswDocumentFindFirstOrThrowArgs} args - Arguments to find a PswDocument
     * @example
     * // Get one PswDocument
     * const pswDocument = await prisma.pswDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PswDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, PswDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PswDocumentClient<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PswDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PswDocuments
     * const pswDocuments = await prisma.pswDocument.findMany()
     * 
     * // Get first 10 PswDocuments
     * const pswDocuments = await prisma.pswDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pswDocumentWithIdOnly = await prisma.pswDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PswDocumentFindManyArgs>(args?: SelectSubset<T, PswDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PswDocument.
     * @param {PswDocumentCreateArgs} args - Arguments to create a PswDocument.
     * @example
     * // Create one PswDocument
     * const PswDocument = await prisma.pswDocument.create({
     *   data: {
     *     // ... data to create a PswDocument
     *   }
     * })
     * 
     */
    create<T extends PswDocumentCreateArgs>(args: SelectSubset<T, PswDocumentCreateArgs<ExtArgs>>): Prisma__PswDocumentClient<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PswDocuments.
     * @param {PswDocumentCreateManyArgs} args - Arguments to create many PswDocuments.
     * @example
     * // Create many PswDocuments
     * const pswDocument = await prisma.pswDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PswDocumentCreateManyArgs>(args?: SelectSubset<T, PswDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PswDocuments and returns the data saved in the database.
     * @param {PswDocumentCreateManyAndReturnArgs} args - Arguments to create many PswDocuments.
     * @example
     * // Create many PswDocuments
     * const pswDocument = await prisma.pswDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PswDocuments and only return the `id`
     * const pswDocumentWithIdOnly = await prisma.pswDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PswDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, PswDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PswDocument.
     * @param {PswDocumentDeleteArgs} args - Arguments to delete one PswDocument.
     * @example
     * // Delete one PswDocument
     * const PswDocument = await prisma.pswDocument.delete({
     *   where: {
     *     // ... filter to delete one PswDocument
     *   }
     * })
     * 
     */
    delete<T extends PswDocumentDeleteArgs>(args: SelectSubset<T, PswDocumentDeleteArgs<ExtArgs>>): Prisma__PswDocumentClient<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PswDocument.
     * @param {PswDocumentUpdateArgs} args - Arguments to update one PswDocument.
     * @example
     * // Update one PswDocument
     * const pswDocument = await prisma.pswDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PswDocumentUpdateArgs>(args: SelectSubset<T, PswDocumentUpdateArgs<ExtArgs>>): Prisma__PswDocumentClient<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PswDocuments.
     * @param {PswDocumentDeleteManyArgs} args - Arguments to filter PswDocuments to delete.
     * @example
     * // Delete a few PswDocuments
     * const { count } = await prisma.pswDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PswDocumentDeleteManyArgs>(args?: SelectSubset<T, PswDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PswDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PswDocuments
     * const pswDocument = await prisma.pswDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PswDocumentUpdateManyArgs>(args: SelectSubset<T, PswDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PswDocument.
     * @param {PswDocumentUpsertArgs} args - Arguments to update or create a PswDocument.
     * @example
     * // Update or create a PswDocument
     * const pswDocument = await prisma.pswDocument.upsert({
     *   create: {
     *     // ... data to create a PswDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PswDocument we want to update
     *   }
     * })
     */
    upsert<T extends PswDocumentUpsertArgs>(args: SelectSubset<T, PswDocumentUpsertArgs<ExtArgs>>): Prisma__PswDocumentClient<$Result.GetResult<Prisma.$PswDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PswDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswDocumentCountArgs} args - Arguments to filter PswDocuments to count.
     * @example
     * // Count the number of PswDocuments
     * const count = await prisma.pswDocument.count({
     *   where: {
     *     // ... the filter for the PswDocuments we want to count
     *   }
     * })
    **/
    count<T extends PswDocumentCountArgs>(
      args?: Subset<T, PswDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PswDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PswDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PswDocumentAggregateArgs>(args: Subset<T, PswDocumentAggregateArgs>): Prisma.PrismaPromise<GetPswDocumentAggregateType<T>>

    /**
     * Group by PswDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PswDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PswDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PswDocumentGroupByArgs['orderBy'] }
        : { orderBy?: PswDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PswDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPswDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PswDocument model
   */
  readonly fields: PswDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PswDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PswDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    psw<T extends PswProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PswProfileDefaultArgs<ExtArgs>>): Prisma__PswProfileClient<$Result.GetResult<Prisma.$PswProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    verifier<T extends PswDocument$verifierArgs<ExtArgs> = {}>(args?: Subset<T, PswDocument$verifierArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PswDocument model
   */ 
  interface PswDocumentFieldRefs {
    readonly id: FieldRef<"PswDocument", 'String'>
    readonly pswId: FieldRef<"PswDocument", 'String'>
    readonly docType: FieldRef<"PswDocument", 'String'>
    readonly fileKey: FieldRef<"PswDocument", 'String'>
    readonly status: FieldRef<"PswDocument", 'DocStatus'>
    readonly expiryDate: FieldRef<"PswDocument", 'DateTime'>
    readonly verifiedBy: FieldRef<"PswDocument", 'String'>
    readonly verifiedAt: FieldRef<"PswDocument", 'DateTime'>
    readonly createdAt: FieldRef<"PswDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"PswDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PswDocument findUnique
   */
  export type PswDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PswDocument to fetch.
     */
    where: PswDocumentWhereUniqueInput
  }

  /**
   * PswDocument findUniqueOrThrow
   */
  export type PswDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PswDocument to fetch.
     */
    where: PswDocumentWhereUniqueInput
  }

  /**
   * PswDocument findFirst
   */
  export type PswDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PswDocument to fetch.
     */
    where?: PswDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PswDocuments to fetch.
     */
    orderBy?: PswDocumentOrderByWithRelationInput | PswDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PswDocuments.
     */
    cursor?: PswDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PswDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PswDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PswDocuments.
     */
    distinct?: PswDocumentScalarFieldEnum | PswDocumentScalarFieldEnum[]
  }

  /**
   * PswDocument findFirstOrThrow
   */
  export type PswDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PswDocument to fetch.
     */
    where?: PswDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PswDocuments to fetch.
     */
    orderBy?: PswDocumentOrderByWithRelationInput | PswDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PswDocuments.
     */
    cursor?: PswDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PswDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PswDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PswDocuments.
     */
    distinct?: PswDocumentScalarFieldEnum | PswDocumentScalarFieldEnum[]
  }

  /**
   * PswDocument findMany
   */
  export type PswDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PswDocuments to fetch.
     */
    where?: PswDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PswDocuments to fetch.
     */
    orderBy?: PswDocumentOrderByWithRelationInput | PswDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PswDocuments.
     */
    cursor?: PswDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PswDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PswDocuments.
     */
    skip?: number
    distinct?: PswDocumentScalarFieldEnum | PswDocumentScalarFieldEnum[]
  }

  /**
   * PswDocument create
   */
  export type PswDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a PswDocument.
     */
    data: XOR<PswDocumentCreateInput, PswDocumentUncheckedCreateInput>
  }

  /**
   * PswDocument createMany
   */
  export type PswDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PswDocuments.
     */
    data: PswDocumentCreateManyInput | PswDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PswDocument createManyAndReturn
   */
  export type PswDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PswDocuments.
     */
    data: PswDocumentCreateManyInput | PswDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PswDocument update
   */
  export type PswDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a PswDocument.
     */
    data: XOR<PswDocumentUpdateInput, PswDocumentUncheckedUpdateInput>
    /**
     * Choose, which PswDocument to update.
     */
    where: PswDocumentWhereUniqueInput
  }

  /**
   * PswDocument updateMany
   */
  export type PswDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PswDocuments.
     */
    data: XOR<PswDocumentUpdateManyMutationInput, PswDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PswDocuments to update
     */
    where?: PswDocumentWhereInput
  }

  /**
   * PswDocument upsert
   */
  export type PswDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the PswDocument to update in case it exists.
     */
    where: PswDocumentWhereUniqueInput
    /**
     * In case the PswDocument found by the `where` argument doesn't exist, create a new PswDocument with this data.
     */
    create: XOR<PswDocumentCreateInput, PswDocumentUncheckedCreateInput>
    /**
     * In case the PswDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PswDocumentUpdateInput, PswDocumentUncheckedUpdateInput>
  }

  /**
   * PswDocument delete
   */
  export type PswDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
    /**
     * Filter which PswDocument to delete.
     */
    where: PswDocumentWhereUniqueInput
  }

  /**
   * PswDocument deleteMany
   */
  export type PswDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PswDocuments to delete
     */
    where?: PswDocumentWhereInput
  }

  /**
   * PswDocument.verifier
   */
  export type PswDocument$verifierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PswDocument without action
   */
  export type PswDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PswDocument
     */
    select?: PswDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PswDocumentInclude<ExtArgs> | null
  }


  /**
   * Model FAQ
   */

  export type AggregateFAQ = {
    _count: FAQCountAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  export type FAQMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FAQMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FAQCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FAQMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FAQMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FAQCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQ to aggregate.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQS
    **/
    _count?: true | FAQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQMaxAggregateInputType
  }

  export type GetFAQAggregateType<T extends FAQAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQ[P]>
      : GetScalarType<T[P], AggregateFAQ[P]>
  }




  export type FAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithAggregationInput | FAQOrderByWithAggregationInput[]
    by: FAQScalarFieldEnum[] | FAQScalarFieldEnum
    having?: FAQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQCountAggregateInputType | true
    _min?: FAQMinAggregateInputType
    _max?: FAQMaxAggregateInputType
  }

  export type FAQGroupByOutputType = {
    id: string
    question: string
    answer: string
    category: string
    createdAt: Date
    updatedAt: Date
    _count: FAQCountAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  type GetFAQGroupByPayload<T extends FAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQGroupByOutputType[P]>
            : GetScalarType<T[P], FAQGroupByOutputType[P]>
        }
      >
    >


  export type FAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQ"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fAQ"]>
    composites: {}
  }

  type FAQGetPayload<S extends boolean | null | undefined | FAQDefaultArgs> = $Result.GetResult<Prisma.$FAQPayload, S>

  type FAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FAQFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FAQCountAggregateInputType | true
    }

  export interface FAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQ'], meta: { name: 'FAQ' } }
    /**
     * Find zero or one FAQ that matches the filter.
     * @param {FAQFindUniqueArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQFindUniqueArgs>(args: SelectSubset<T, FAQFindUniqueArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FAQ that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FAQFindUniqueOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQFindFirstArgs>(args?: SelectSubset<T, FAQFindFirstArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQ.findMany()
     * 
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQWithIdOnly = await prisma.fAQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQFindManyArgs>(args?: SelectSubset<T, FAQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FAQ.
     * @param {FAQCreateArgs} args - Arguments to create a FAQ.
     * @example
     * // Create one FAQ
     * const FAQ = await prisma.fAQ.create({
     *   data: {
     *     // ... data to create a FAQ
     *   }
     * })
     * 
     */
    create<T extends FAQCreateArgs>(args: SelectSubset<T, FAQCreateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FAQS.
     * @param {FAQCreateManyArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQCreateManyArgs>(args?: SelectSubset<T, FAQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQS and returns the data saved in the database.
     * @param {FAQCreateManyAndReturnArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FAQ.
     * @param {FAQDeleteArgs} args - Arguments to delete one FAQ.
     * @example
     * // Delete one FAQ
     * const FAQ = await prisma.fAQ.delete({
     *   where: {
     *     // ... filter to delete one FAQ
     *   }
     * })
     * 
     */
    delete<T extends FAQDeleteArgs>(args: SelectSubset<T, FAQDeleteArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FAQ.
     * @param {FAQUpdateArgs} args - Arguments to update one FAQ.
     * @example
     * // Update one FAQ
     * const fAQ = await prisma.fAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQUpdateArgs>(args: SelectSubset<T, FAQUpdateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FAQS.
     * @param {FAQDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQDeleteManyArgs>(args?: SelectSubset<T, FAQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQUpdateManyArgs>(args: SelectSubset<T, FAQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FAQ.
     * @param {FAQUpsertArgs} args - Arguments to update or create a FAQ.
     * @example
     * // Update or create a FAQ
     * const fAQ = await prisma.fAQ.upsert({
     *   create: {
     *     // ... data to create a FAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQ we want to update
     *   }
     * })
     */
    upsert<T extends FAQUpsertArgs>(args: SelectSubset<T, FAQUpsertArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQ.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
    **/
    count<T extends FAQCountArgs>(
      args?: Subset<T, FAQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAggregateArgs>(args: Subset<T, FAQAggregateArgs>): Prisma.PrismaPromise<GetFAQAggregateType<T>>

    /**
     * Group by FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQGroupByArgs['orderBy'] }
        : { orderBy?: FAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQ model
   */
  readonly fields: FAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQ model
   */ 
  interface FAQFieldRefs {
    readonly id: FieldRef<"FAQ", 'String'>
    readonly question: FieldRef<"FAQ", 'String'>
    readonly answer: FieldRef<"FAQ", 'String'>
    readonly category: FieldRef<"FAQ", 'String'>
    readonly createdAt: FieldRef<"FAQ", 'DateTime'>
    readonly updatedAt: FieldRef<"FAQ", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FAQ findUnique
   */
  export type FAQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findUniqueOrThrow
   */
  export type FAQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findFirst
   */
  export type FAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findFirstOrThrow
   */
  export type FAQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findMany
   */
  export type FAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ create
   */
  export type FAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * The data needed to create a FAQ.
     */
    data: XOR<FAQCreateInput, FAQUncheckedCreateInput>
  }

  /**
   * FAQ createMany
   */
  export type FAQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ createManyAndReturn
   */
  export type FAQCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ update
   */
  export type FAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * The data needed to update a FAQ.
     */
    data: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
    /**
     * Choose, which FAQ to update.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ updateMany
   */
  export type FAQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
  }

  /**
   * FAQ upsert
   */
  export type FAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * The filter to search for the FAQ to update in case it exists.
     */
    where: FAQWhereUniqueInput
    /**
     * In case the FAQ found by the `where` argument doesn't exist, create a new FAQ with this data.
     */
    create: XOR<FAQCreateInput, FAQUncheckedCreateInput>
    /**
     * In case the FAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
  }

  /**
   * FAQ delete
   */
  export type FAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter which FAQ to delete.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ deleteMany
   */
  export type FAQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQWhereInput
  }

  /**
   * FAQ without action
   */
  export type FAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
  }


  /**
   * Model DailyEntry
   */

  export type AggregateDailyEntry = {
    _count: DailyEntryCountAggregateOutputType | null
    _avg: DailyEntryAvgAggregateOutputType | null
    _sum: DailyEntrySumAggregateOutputType | null
    _min: DailyEntryMinAggregateOutputType | null
    _max: DailyEntryMaxAggregateOutputType | null
  }

  export type DailyEntryAvgAggregateOutputType = {
    mood: number | null
  }

  export type DailyEntrySumAggregateOutputType = {
    mood: number | null
  }

  export type DailyEntryMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    staffId: string | null
    visitId: string | null
    mood: number | null
    notes: string | null
    signature: string | null
    status: $Enums.DailyEntryStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyEntryMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    staffId: string | null
    visitId: string | null
    mood: number | null
    notes: string | null
    signature: string | null
    status: $Enums.DailyEntryStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyEntryCountAggregateOutputType = {
    id: number
    clientId: number
    staffId: number
    visitId: number
    adlData: number
    medication: number
    mood: number
    vitals: number
    notes: number
    signature: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyEntryAvgAggregateInputType = {
    mood?: true
  }

  export type DailyEntrySumAggregateInputType = {
    mood?: true
  }

  export type DailyEntryMinAggregateInputType = {
    id?: true
    clientId?: true
    staffId?: true
    visitId?: true
    mood?: true
    notes?: true
    signature?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyEntryMaxAggregateInputType = {
    id?: true
    clientId?: true
    staffId?: true
    visitId?: true
    mood?: true
    notes?: true
    signature?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyEntryCountAggregateInputType = {
    id?: true
    clientId?: true
    staffId?: true
    visitId?: true
    adlData?: true
    medication?: true
    mood?: true
    vitals?: true
    notes?: true
    signature?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyEntry to aggregate.
     */
    where?: DailyEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEntries to fetch.
     */
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyEntries
    **/
    _count?: true | DailyEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyEntryMaxAggregateInputType
  }

  export type GetDailyEntryAggregateType<T extends DailyEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyEntry[P]>
      : GetScalarType<T[P], AggregateDailyEntry[P]>
  }




  export type DailyEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyEntryWhereInput
    orderBy?: DailyEntryOrderByWithAggregationInput | DailyEntryOrderByWithAggregationInput[]
    by: DailyEntryScalarFieldEnum[] | DailyEntryScalarFieldEnum
    having?: DailyEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyEntryCountAggregateInputType | true
    _avg?: DailyEntryAvgAggregateInputType
    _sum?: DailyEntrySumAggregateInputType
    _min?: DailyEntryMinAggregateInputType
    _max?: DailyEntryMaxAggregateInputType
  }

  export type DailyEntryGroupByOutputType = {
    id: string
    clientId: string
    staffId: string
    visitId: string | null
    adlData: JsonValue
    medication: JsonValue | null
    mood: number | null
    vitals: JsonValue | null
    notes: string | null
    signature: string | null
    status: $Enums.DailyEntryStatus
    createdAt: Date
    updatedAt: Date
    _count: DailyEntryCountAggregateOutputType | null
    _avg: DailyEntryAvgAggregateOutputType | null
    _sum: DailyEntrySumAggregateOutputType | null
    _min: DailyEntryMinAggregateOutputType | null
    _max: DailyEntryMaxAggregateOutputType | null
  }

  type GetDailyEntryGroupByPayload<T extends DailyEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyEntryGroupByOutputType[P]>
            : GetScalarType<T[P], DailyEntryGroupByOutputType[P]>
        }
      >
    >


  export type DailyEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffId?: boolean
    visitId?: boolean
    adlData?: boolean
    medication?: boolean
    mood?: boolean
    vitals?: boolean
    notes?: boolean
    signature?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    visit?: boolean | DailyEntry$visitArgs<ExtArgs>
  }, ExtArgs["result"]["dailyEntry"]>

  export type DailyEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffId?: boolean
    visitId?: boolean
    adlData?: boolean
    medication?: boolean
    mood?: boolean
    vitals?: boolean
    notes?: boolean
    signature?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    visit?: boolean | DailyEntry$visitArgs<ExtArgs>
  }, ExtArgs["result"]["dailyEntry"]>

  export type DailyEntrySelectScalar = {
    id?: boolean
    clientId?: boolean
    staffId?: boolean
    visitId?: boolean
    adlData?: boolean
    medication?: boolean
    mood?: boolean
    vitals?: boolean
    notes?: boolean
    signature?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    visit?: boolean | DailyEntry$visitArgs<ExtArgs>
  }
  export type DailyEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    visit?: boolean | DailyEntry$visitArgs<ExtArgs>
  }

  export type $DailyEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyEntry"
    objects: {
      client: Prisma.$ClientProfilePayload<ExtArgs>
      staff: Prisma.$UserPayload<ExtArgs>
      visit: Prisma.$VisitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      staffId: string
      visitId: string | null
      adlData: Prisma.JsonValue
      medication: Prisma.JsonValue | null
      mood: number | null
      vitals: Prisma.JsonValue | null
      notes: string | null
      signature: string | null
      status: $Enums.DailyEntryStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyEntry"]>
    composites: {}
  }

  type DailyEntryGetPayload<S extends boolean | null | undefined | DailyEntryDefaultArgs> = $Result.GetResult<Prisma.$DailyEntryPayload, S>

  type DailyEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyEntryCountAggregateInputType | true
    }

  export interface DailyEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyEntry'], meta: { name: 'DailyEntry' } }
    /**
     * Find zero or one DailyEntry that matches the filter.
     * @param {DailyEntryFindUniqueArgs} args - Arguments to find a DailyEntry
     * @example
     * // Get one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyEntryFindUniqueArgs>(args: SelectSubset<T, DailyEntryFindUniqueArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyEntryFindUniqueOrThrowArgs} args - Arguments to find a DailyEntry
     * @example
     * // Get one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryFindFirstArgs} args - Arguments to find a DailyEntry
     * @example
     * // Get one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyEntryFindFirstArgs>(args?: SelectSubset<T, DailyEntryFindFirstArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryFindFirstOrThrowArgs} args - Arguments to find a DailyEntry
     * @example
     * // Get one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyEntries
     * const dailyEntries = await prisma.dailyEntry.findMany()
     * 
     * // Get first 10 DailyEntries
     * const dailyEntries = await prisma.dailyEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyEntryWithIdOnly = await prisma.dailyEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyEntryFindManyArgs>(args?: SelectSubset<T, DailyEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyEntry.
     * @param {DailyEntryCreateArgs} args - Arguments to create a DailyEntry.
     * @example
     * // Create one DailyEntry
     * const DailyEntry = await prisma.dailyEntry.create({
     *   data: {
     *     // ... data to create a DailyEntry
     *   }
     * })
     * 
     */
    create<T extends DailyEntryCreateArgs>(args: SelectSubset<T, DailyEntryCreateArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyEntries.
     * @param {DailyEntryCreateManyArgs} args - Arguments to create many DailyEntries.
     * @example
     * // Create many DailyEntries
     * const dailyEntry = await prisma.dailyEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyEntryCreateManyArgs>(args?: SelectSubset<T, DailyEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyEntries and returns the data saved in the database.
     * @param {DailyEntryCreateManyAndReturnArgs} args - Arguments to create many DailyEntries.
     * @example
     * // Create many DailyEntries
     * const dailyEntry = await prisma.dailyEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyEntries and only return the `id`
     * const dailyEntryWithIdOnly = await prisma.dailyEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyEntry.
     * @param {DailyEntryDeleteArgs} args - Arguments to delete one DailyEntry.
     * @example
     * // Delete one DailyEntry
     * const DailyEntry = await prisma.dailyEntry.delete({
     *   where: {
     *     // ... filter to delete one DailyEntry
     *   }
     * })
     * 
     */
    delete<T extends DailyEntryDeleteArgs>(args: SelectSubset<T, DailyEntryDeleteArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyEntry.
     * @param {DailyEntryUpdateArgs} args - Arguments to update one DailyEntry.
     * @example
     * // Update one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyEntryUpdateArgs>(args: SelectSubset<T, DailyEntryUpdateArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyEntries.
     * @param {DailyEntryDeleteManyArgs} args - Arguments to filter DailyEntries to delete.
     * @example
     * // Delete a few DailyEntries
     * const { count } = await prisma.dailyEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyEntryDeleteManyArgs>(args?: SelectSubset<T, DailyEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyEntries
     * const dailyEntry = await prisma.dailyEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyEntryUpdateManyArgs>(args: SelectSubset<T, DailyEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyEntry.
     * @param {DailyEntryUpsertArgs} args - Arguments to update or create a DailyEntry.
     * @example
     * // Update or create a DailyEntry
     * const dailyEntry = await prisma.dailyEntry.upsert({
     *   create: {
     *     // ... data to create a DailyEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyEntry we want to update
     *   }
     * })
     */
    upsert<T extends DailyEntryUpsertArgs>(args: SelectSubset<T, DailyEntryUpsertArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryCountArgs} args - Arguments to filter DailyEntries to count.
     * @example
     * // Count the number of DailyEntries
     * const count = await prisma.dailyEntry.count({
     *   where: {
     *     // ... the filter for the DailyEntries we want to count
     *   }
     * })
    **/
    count<T extends DailyEntryCountArgs>(
      args?: Subset<T, DailyEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyEntryAggregateArgs>(args: Subset<T, DailyEntryAggregateArgs>): Prisma.PrismaPromise<GetDailyEntryAggregateType<T>>

    /**
     * Group by DailyEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyEntryGroupByArgs['orderBy'] }
        : { orderBy?: DailyEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyEntry model
   */
  readonly fields: DailyEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    staff<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    visit<T extends DailyEntry$visitArgs<ExtArgs> = {}>(args?: Subset<T, DailyEntry$visitArgs<ExtArgs>>): Prisma__VisitClient<$Result.GetResult<Prisma.$VisitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyEntry model
   */ 
  interface DailyEntryFieldRefs {
    readonly id: FieldRef<"DailyEntry", 'String'>
    readonly clientId: FieldRef<"DailyEntry", 'String'>
    readonly staffId: FieldRef<"DailyEntry", 'String'>
    readonly visitId: FieldRef<"DailyEntry", 'String'>
    readonly adlData: FieldRef<"DailyEntry", 'Json'>
    readonly medication: FieldRef<"DailyEntry", 'Json'>
    readonly mood: FieldRef<"DailyEntry", 'Int'>
    readonly vitals: FieldRef<"DailyEntry", 'Json'>
    readonly notes: FieldRef<"DailyEntry", 'String'>
    readonly signature: FieldRef<"DailyEntry", 'String'>
    readonly status: FieldRef<"DailyEntry", 'DailyEntryStatus'>
    readonly createdAt: FieldRef<"DailyEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyEntry findUnique
   */
  export type DailyEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntry to fetch.
     */
    where: DailyEntryWhereUniqueInput
  }

  /**
   * DailyEntry findUniqueOrThrow
   */
  export type DailyEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntry to fetch.
     */
    where: DailyEntryWhereUniqueInput
  }

  /**
   * DailyEntry findFirst
   */
  export type DailyEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntry to fetch.
     */
    where?: DailyEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEntries to fetch.
     */
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyEntries.
     */
    cursor?: DailyEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyEntries.
     */
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * DailyEntry findFirstOrThrow
   */
  export type DailyEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntry to fetch.
     */
    where?: DailyEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEntries to fetch.
     */
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyEntries.
     */
    cursor?: DailyEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyEntries.
     */
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * DailyEntry findMany
   */
  export type DailyEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntries to fetch.
     */
    where?: DailyEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEntries to fetch.
     */
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyEntries.
     */
    cursor?: DailyEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEntries.
     */
    skip?: number
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * DailyEntry create
   */
  export type DailyEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyEntry.
     */
    data: XOR<DailyEntryCreateInput, DailyEntryUncheckedCreateInput>
  }

  /**
   * DailyEntry createMany
   */
  export type DailyEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyEntries.
     */
    data: DailyEntryCreateManyInput | DailyEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyEntry createManyAndReturn
   */
  export type DailyEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyEntries.
     */
    data: DailyEntryCreateManyInput | DailyEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyEntry update
   */
  export type DailyEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyEntry.
     */
    data: XOR<DailyEntryUpdateInput, DailyEntryUncheckedUpdateInput>
    /**
     * Choose, which DailyEntry to update.
     */
    where: DailyEntryWhereUniqueInput
  }

  /**
   * DailyEntry updateMany
   */
  export type DailyEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyEntries.
     */
    data: XOR<DailyEntryUpdateManyMutationInput, DailyEntryUncheckedUpdateManyInput>
    /**
     * Filter which DailyEntries to update
     */
    where?: DailyEntryWhereInput
  }

  /**
   * DailyEntry upsert
   */
  export type DailyEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyEntry to update in case it exists.
     */
    where: DailyEntryWhereUniqueInput
    /**
     * In case the DailyEntry found by the `where` argument doesn't exist, create a new DailyEntry with this data.
     */
    create: XOR<DailyEntryCreateInput, DailyEntryUncheckedCreateInput>
    /**
     * In case the DailyEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyEntryUpdateInput, DailyEntryUncheckedUpdateInput>
  }

  /**
   * DailyEntry delete
   */
  export type DailyEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter which DailyEntry to delete.
     */
    where: DailyEntryWhereUniqueInput
  }

  /**
   * DailyEntry deleteMany
   */
  export type DailyEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyEntries to delete
     */
    where?: DailyEntryWhereInput
  }

  /**
   * DailyEntry.visit
   */
  export type DailyEntry$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visit
     */
    select?: VisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitInclude<ExtArgs> | null
    where?: VisitWhereInput
  }

  /**
   * DailyEntry without action
   */
  export type DailyEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    role: 'role',
    email: 'email',
    phone: 'phone',
    passwordHash: 'passwordHash',
    status: 'status',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    dob: 'dob',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    province: 'province',
    postalCode: 'postalCode',
    lat: 'lat',
    lng: 'lng',
    emergencyName: 'emergencyName',
    emergencyPhone: 'emergencyPhone',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientProfileScalarFieldEnum = (typeof ClientProfileScalarFieldEnum)[keyof typeof ClientProfileScalarFieldEnum]


  export const PswProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    bio: 'bio',
    languages: 'languages',
    serviceAreas: 'serviceAreas',
    availability: 'availability',
    isApproved: 'isApproved',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PswProfileScalarFieldEnum = (typeof PswProfileScalarFieldEnum)[keyof typeof PswProfileScalarFieldEnum]


  export const VisitScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    serviceId: 'serviceId',
    requestedStartAt: 'requestedStartAt',
    durationMinutes: 'durationMinutes',
    status: 'status',
    assignedPswId: 'assignedPswId',
    serviceAddressLine1: 'serviceAddressLine1',
    serviceAddressLine2: 'serviceAddressLine2',
    serviceCity: 'serviceCity',
    serviceProvince: 'serviceProvince',
    servicePostalCode: 'servicePostalCode',
    serviceLat: 'serviceLat',
    serviceLng: 'serviceLng',
    clientNotes: 'clientNotes',
    coordinatorNotes: 'coordinatorNotes',
    cancellationReason: 'cancellationReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitScalarFieldEnum = (typeof VisitScalarFieldEnum)[keyof typeof VisitScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    baseRateHourly: 'baseRateHourly',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const VisitCheckEventScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    pswId: 'pswId',
    eventType: 'eventType',
    lat: 'lat',
    lng: 'lng',
    accuracyM: 'accuracyM',
    computedDistanceM: 'computedDistanceM',
    deviceTimeIso: 'deviceTimeIso',
    serverTime: 'serverTime',
    result: 'result',
    rejectReason: 'rejectReason',
    isOverride: 'isOverride',
    overrideByUserId: 'overrideByUserId',
    overrideReason: 'overrideReason',
    createdAt: 'createdAt'
  };

  export type VisitCheckEventScalarFieldEnum = (typeof VisitCheckEventScalarFieldEnum)[keyof typeof VisitCheckEventScalarFieldEnum]


  export const VisitNoteScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    pswId: 'pswId',
    noteText: 'noteText',
    createdAt: 'createdAt'
  };

  export type VisitNoteScalarFieldEnum = (typeof VisitNoteScalarFieldEnum)[keyof typeof VisitNoteScalarFieldEnum]


  export const VisitChecklistScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    pswId: 'pswId',
    checklistJson: 'checklistJson',
    createdAt: 'createdAt'
  };

  export type VisitChecklistScalarFieldEnum = (typeof VisitChecklistScalarFieldEnum)[keyof typeof VisitChecklistScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    visitId: 'visitId',
    reporterUserId: 'reporterUserId',
    type: 'type',
    description: 'description',
    status: 'status',
    resolutionNotes: 'resolutionNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const TimesheetScalarFieldEnum: {
    id: 'id',
    pswId: 'pswId',
    weekId: 'weekId',
    totalMinutes: 'totalMinutes',
    status: 'status',
    submittedAt: 'submittedAt',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimesheetScalarFieldEnum = (typeof TimesheetScalarFieldEnum)[keyof typeof TimesheetScalarFieldEnum]


  export const TimesheetItemScalarFieldEnum: {
    id: 'id',
    timesheetId: 'timesheetId',
    visitId: 'visitId',
    minutes: 'minutes',
    createdAt: 'createdAt'
  };

  export type TimesheetItemScalarFieldEnum = (typeof TimesheetItemScalarFieldEnum)[keyof typeof TimesheetItemScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    status: 'status',
    currency: 'currency',
    subtotal: 'subtotal',
    tax: 'tax',
    total: 'total',
    stripeInvoiceId: 'stripeInvoiceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    stripePaymentIntentId: 'stripePaymentIntentId',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const MessageThreadScalarFieldEnum: {
    id: 'id',
    threadType: 'threadType',
    clientId: 'clientId',
    pswId: 'pswId',
    createdAt: 'createdAt'
  };

  export type MessageThreadScalarFieldEnum = (typeof MessageThreadScalarFieldEnum)[keyof typeof MessageThreadScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    senderUserId: 'senderUserId',
    bodyText: 'bodyText',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorUserId: 'actorUserId',
    action: 'action',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    metadataJson: 'metadataJson',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    email: 'email',
    phone: 'phone',
    message: 'message',
    source: 'source',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    excerpt: 'excerpt',
    contentHtml: 'contentHtml',
    status: 'status',
    publishedAt: 'publishedAt',
    authorUserId: 'authorUserId',
    featureImageDocId: 'featureImageDocId',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription',
    canonicalUrl: 'canonicalUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const PswDocumentScalarFieldEnum: {
    id: 'id',
    pswId: 'pswId',
    docType: 'docType',
    fileKey: 'fileKey',
    status: 'status',
    expiryDate: 'expiryDate',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PswDocumentScalarFieldEnum = (typeof PswDocumentScalarFieldEnum)[keyof typeof PswDocumentScalarFieldEnum]


  export const FAQScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FAQScalarFieldEnum = (typeof FAQScalarFieldEnum)[keyof typeof FAQScalarFieldEnum]


  export const DailyEntryScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    staffId: 'staffId',
    visitId: 'visitId',
    adlData: 'adlData',
    medication: 'medication',
    mood: 'mood',
    vitals: 'vitals',
    notes: 'notes',
    signature: 'signature',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyEntryScalarFieldEnum = (typeof DailyEntryScalarFieldEnum)[keyof typeof DailyEntryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'VisitStatus'
   */
  export type EnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus'>
    


  /**
   * Reference to a field of type 'VisitStatus[]'
   */
  export type ListEnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'EventResult'
   */
  export type EnumEventResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventResult'>
    


  /**
   * Reference to a field of type 'EventResult[]'
   */
  export type ListEnumEventResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventResult[]'>
    


  /**
   * Reference to a field of type 'IncidentType'
   */
  export type EnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType'>
    


  /**
   * Reference to a field of type 'IncidentType[]'
   */
  export type ListEnumIncidentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentType[]'>
    


  /**
   * Reference to a field of type 'IncidentStatus'
   */
  export type EnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus'>
    


  /**
   * Reference to a field of type 'IncidentStatus[]'
   */
  export type ListEnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus[]'>
    


  /**
   * Reference to a field of type 'TimesheetStatus'
   */
  export type EnumTimesheetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimesheetStatus'>
    


  /**
   * Reference to a field of type 'TimesheetStatus[]'
   */
  export type ListEnumTimesheetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimesheetStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'DocStatus'
   */
  export type EnumDocStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocStatus'>
    


  /**
   * Reference to a field of type 'DocStatus[]'
   */
  export type ListEnumDocStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocStatus[]'>
    


  /**
   * Reference to a field of type 'DailyEntryStatus'
   */
  export type EnumDailyEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DailyEntryStatus'>
    


  /**
   * Reference to a field of type 'DailyEntryStatus[]'
   */
  export type ListEnumDailyEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DailyEntryStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    status?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clientProfile?: XOR<ClientProfileNullableRelationFilter, ClientProfileWhereInput> | null
    pswProfile?: XOR<PswProfileNullableRelationFilter, PswProfileWhereInput> | null
    verifiedDocs?: PswDocumentListRelationFilter
    reportedIncidents?: IncidentListRelationFilter
    reviewedTimesheets?: TimesheetListRelationFilter
    sentMessages?: MessageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    VisitCheckEvent?: VisitCheckEventListRelationFilter
    DailyEntry?: DailyEntryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    status?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientProfile?: ClientProfileOrderByWithRelationInput
    pswProfile?: PswProfileOrderByWithRelationInput
    verifiedDocs?: PswDocumentOrderByRelationAggregateInput
    reportedIncidents?: IncidentOrderByRelationAggregateInput
    reviewedTimesheets?: TimesheetOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
    VisitCheckEvent?: VisitCheckEventOrderByRelationAggregateInput
    DailyEntry?: DailyEntryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumRoleFilter<"User"> | $Enums.Role
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    status?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clientProfile?: XOR<ClientProfileNullableRelationFilter, ClientProfileWhereInput> | null
    pswProfile?: XOR<PswProfileNullableRelationFilter, PswProfileWhereInput> | null
    verifiedDocs?: PswDocumentListRelationFilter
    reportedIncidents?: IncidentListRelationFilter
    reviewedTimesheets?: TimesheetListRelationFilter
    sentMessages?: MessageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    VisitCheckEvent?: VisitCheckEventListRelationFilter
    DailyEntry?: DailyEntryListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    status?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    status?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClientProfileWhereInput = {
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    id?: StringFilter<"ClientProfile"> | string
    userId?: StringFilter<"ClientProfile"> | string
    fullName?: StringFilter<"ClientProfile"> | string
    dob?: DateTimeNullableFilter<"ClientProfile"> | Date | string | null
    addressLine1?: StringNullableFilter<"ClientProfile"> | string | null
    addressLine2?: StringNullableFilter<"ClientProfile"> | string | null
    city?: StringNullableFilter<"ClientProfile"> | string | null
    province?: StringNullableFilter<"ClientProfile"> | string | null
    postalCode?: StringNullableFilter<"ClientProfile"> | string | null
    lat?: FloatNullableFilter<"ClientProfile"> | number | null
    lng?: FloatNullableFilter<"ClientProfile"> | number | null
    emergencyName?: StringNullableFilter<"ClientProfile"> | string | null
    emergencyPhone?: StringNullableFilter<"ClientProfile"> | string | null
    preferences?: JsonNullableFilter<"ClientProfile">
    createdAt?: DateTimeFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ClientProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    visits?: VisitListRelationFilter
    invoices?: InvoiceListRelationFilter
    messageThreads?: MessageThreadListRelationFilter
    DailyEntry?: DailyEntryListRelationFilter
  }

  export type ClientProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    dob?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    emergencyName?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    visits?: VisitOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    messageThreads?: MessageThreadOrderByRelationAggregateInput
    DailyEntry?: DailyEntryOrderByRelationAggregateInput
  }

  export type ClientProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    fullName?: StringFilter<"ClientProfile"> | string
    dob?: DateTimeNullableFilter<"ClientProfile"> | Date | string | null
    addressLine1?: StringNullableFilter<"ClientProfile"> | string | null
    addressLine2?: StringNullableFilter<"ClientProfile"> | string | null
    city?: StringNullableFilter<"ClientProfile"> | string | null
    province?: StringNullableFilter<"ClientProfile"> | string | null
    postalCode?: StringNullableFilter<"ClientProfile"> | string | null
    lat?: FloatNullableFilter<"ClientProfile"> | number | null
    lng?: FloatNullableFilter<"ClientProfile"> | number | null
    emergencyName?: StringNullableFilter<"ClientProfile"> | string | null
    emergencyPhone?: StringNullableFilter<"ClientProfile"> | string | null
    preferences?: JsonNullableFilter<"ClientProfile">
    createdAt?: DateTimeFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ClientProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    visits?: VisitListRelationFilter
    invoices?: InvoiceListRelationFilter
    messageThreads?: MessageThreadListRelationFilter
    DailyEntry?: DailyEntryListRelationFilter
  }, "id" | "userId">

  export type ClientProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    dob?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    emergencyName?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientProfileCountOrderByAggregateInput
    _avg?: ClientProfileAvgOrderByAggregateInput
    _max?: ClientProfileMaxOrderByAggregateInput
    _min?: ClientProfileMinOrderByAggregateInput
    _sum?: ClientProfileSumOrderByAggregateInput
  }

  export type ClientProfileScalarWhereWithAggregatesInput = {
    AND?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    OR?: ClientProfileScalarWhereWithAggregatesInput[]
    NOT?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientProfile"> | string
    userId?: StringWithAggregatesFilter<"ClientProfile"> | string
    fullName?: StringWithAggregatesFilter<"ClientProfile"> | string
    dob?: DateTimeNullableWithAggregatesFilter<"ClientProfile"> | Date | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    province?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    lat?: FloatNullableWithAggregatesFilter<"ClientProfile"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"ClientProfile"> | number | null
    emergencyName?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    emergencyPhone?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    preferences?: JsonNullableWithAggregatesFilter<"ClientProfile">
    createdAt?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
  }

  export type PswProfileWhereInput = {
    AND?: PswProfileWhereInput | PswProfileWhereInput[]
    OR?: PswProfileWhereInput[]
    NOT?: PswProfileWhereInput | PswProfileWhereInput[]
    id?: StringFilter<"PswProfile"> | string
    userId?: StringFilter<"PswProfile"> | string
    fullName?: StringFilter<"PswProfile"> | string
    bio?: StringNullableFilter<"PswProfile"> | string | null
    languages?: StringNullableListFilter<"PswProfile">
    serviceAreas?: StringNullableListFilter<"PswProfile">
    availability?: JsonNullableFilter<"PswProfile">
    isApproved?: BoolFilter<"PswProfile"> | boolean
    approvedAt?: DateTimeNullableFilter<"PswProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"PswProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PswProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    documents?: PswDocumentListRelationFilter
    assignedVisits?: VisitListRelationFilter
    checkEvents?: VisitCheckEventListRelationFilter
    notes?: VisitNoteListRelationFilter
    checklists?: VisitChecklistListRelationFilter
    timesheets?: TimesheetListRelationFilter
    messageThreads?: MessageThreadListRelationFilter
  }

  export type PswProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    bio?: SortOrderInput | SortOrder
    languages?: SortOrder
    serviceAreas?: SortOrder
    availability?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    documents?: PswDocumentOrderByRelationAggregateInput
    assignedVisits?: VisitOrderByRelationAggregateInput
    checkEvents?: VisitCheckEventOrderByRelationAggregateInput
    notes?: VisitNoteOrderByRelationAggregateInput
    checklists?: VisitChecklistOrderByRelationAggregateInput
    timesheets?: TimesheetOrderByRelationAggregateInput
    messageThreads?: MessageThreadOrderByRelationAggregateInput
  }

  export type PswProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PswProfileWhereInput | PswProfileWhereInput[]
    OR?: PswProfileWhereInput[]
    NOT?: PswProfileWhereInput | PswProfileWhereInput[]
    fullName?: StringFilter<"PswProfile"> | string
    bio?: StringNullableFilter<"PswProfile"> | string | null
    languages?: StringNullableListFilter<"PswProfile">
    serviceAreas?: StringNullableListFilter<"PswProfile">
    availability?: JsonNullableFilter<"PswProfile">
    isApproved?: BoolFilter<"PswProfile"> | boolean
    approvedAt?: DateTimeNullableFilter<"PswProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"PswProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PswProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    documents?: PswDocumentListRelationFilter
    assignedVisits?: VisitListRelationFilter
    checkEvents?: VisitCheckEventListRelationFilter
    notes?: VisitNoteListRelationFilter
    checklists?: VisitChecklistListRelationFilter
    timesheets?: TimesheetListRelationFilter
    messageThreads?: MessageThreadListRelationFilter
  }, "id" | "userId">

  export type PswProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    bio?: SortOrderInput | SortOrder
    languages?: SortOrder
    serviceAreas?: SortOrder
    availability?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PswProfileCountOrderByAggregateInput
    _max?: PswProfileMaxOrderByAggregateInput
    _min?: PswProfileMinOrderByAggregateInput
  }

  export type PswProfileScalarWhereWithAggregatesInput = {
    AND?: PswProfileScalarWhereWithAggregatesInput | PswProfileScalarWhereWithAggregatesInput[]
    OR?: PswProfileScalarWhereWithAggregatesInput[]
    NOT?: PswProfileScalarWhereWithAggregatesInput | PswProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PswProfile"> | string
    userId?: StringWithAggregatesFilter<"PswProfile"> | string
    fullName?: StringWithAggregatesFilter<"PswProfile"> | string
    bio?: StringNullableWithAggregatesFilter<"PswProfile"> | string | null
    languages?: StringNullableListFilter<"PswProfile">
    serviceAreas?: StringNullableListFilter<"PswProfile">
    availability?: JsonNullableWithAggregatesFilter<"PswProfile">
    isApproved?: BoolWithAggregatesFilter<"PswProfile"> | boolean
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PswProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PswProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PswProfile"> | Date | string
  }

  export type VisitWhereInput = {
    AND?: VisitWhereInput | VisitWhereInput[]
    OR?: VisitWhereInput[]
    NOT?: VisitWhereInput | VisitWhereInput[]
    id?: StringFilter<"Visit"> | string
    clientId?: StringFilter<"Visit"> | string
    serviceId?: StringFilter<"Visit"> | string
    requestedStartAt?: DateTimeFilter<"Visit"> | Date | string
    durationMinutes?: IntFilter<"Visit"> | number
    status?: EnumVisitStatusNullableFilter<"Visit"> | $Enums.VisitStatus | null
    assignedPswId?: StringNullableFilter<"Visit"> | string | null
    serviceAddressLine1?: StringNullableFilter<"Visit"> | string | null
    serviceAddressLine2?: StringNullableFilter<"Visit"> | string | null
    serviceCity?: StringNullableFilter<"Visit"> | string | null
    serviceProvince?: StringNullableFilter<"Visit"> | string | null
    servicePostalCode?: StringNullableFilter<"Visit"> | string | null
    serviceLat?: FloatNullableFilter<"Visit"> | number | null
    serviceLng?: FloatNullableFilter<"Visit"> | number | null
    clientNotes?: StringNullableFilter<"Visit"> | string | null
    coordinatorNotes?: StringNullableFilter<"Visit"> | string | null
    cancellationReason?: StringNullableFilter<"Visit"> | string | null
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    updatedAt?: DateTimeFilter<"Visit"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    psw?: XOR<PswProfileNullableRelationFilter, PswProfileWhereInput> | null
    checkEvents?: VisitCheckEventListRelationFilter
    notes?: VisitNoteListRelationFilter
    checklists?: VisitChecklistListRelationFilter
    incidents?: IncidentListRelationFilter
    timesheetItems?: TimesheetItemListRelationFilter
    DailyEntry?: DailyEntryListRelationFilter
  }

  export type VisitOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    requestedStartAt?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrderInput | SortOrder
    assignedPswId?: SortOrderInput | SortOrder
    serviceAddressLine1?: SortOrderInput | SortOrder
    serviceAddressLine2?: SortOrderInput | SortOrder
    serviceCity?: SortOrderInput | SortOrder
    serviceProvince?: SortOrderInput | SortOrder
    servicePostalCode?: SortOrderInput | SortOrder
    serviceLat?: SortOrderInput | SortOrder
    serviceLng?: SortOrderInput | SortOrder
    clientNotes?: SortOrderInput | SortOrder
    coordinatorNotes?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientProfileOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    psw?: PswProfileOrderByWithRelationInput
    checkEvents?: VisitCheckEventOrderByRelationAggregateInput
    notes?: VisitNoteOrderByRelationAggregateInput
    checklists?: VisitChecklistOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
    timesheetItems?: TimesheetItemOrderByRelationAggregateInput
    DailyEntry?: DailyEntryOrderByRelationAggregateInput
  }

  export type VisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitWhereInput | VisitWhereInput[]
    OR?: VisitWhereInput[]
    NOT?: VisitWhereInput | VisitWhereInput[]
    clientId?: StringFilter<"Visit"> | string
    serviceId?: StringFilter<"Visit"> | string
    requestedStartAt?: DateTimeFilter<"Visit"> | Date | string
    durationMinutes?: IntFilter<"Visit"> | number
    status?: EnumVisitStatusNullableFilter<"Visit"> | $Enums.VisitStatus | null
    assignedPswId?: StringNullableFilter<"Visit"> | string | null
    serviceAddressLine1?: StringNullableFilter<"Visit"> | string | null
    serviceAddressLine2?: StringNullableFilter<"Visit"> | string | null
    serviceCity?: StringNullableFilter<"Visit"> | string | null
    serviceProvince?: StringNullableFilter<"Visit"> | string | null
    servicePostalCode?: StringNullableFilter<"Visit"> | string | null
    serviceLat?: FloatNullableFilter<"Visit"> | number | null
    serviceLng?: FloatNullableFilter<"Visit"> | number | null
    clientNotes?: StringNullableFilter<"Visit"> | string | null
    coordinatorNotes?: StringNullableFilter<"Visit"> | string | null
    cancellationReason?: StringNullableFilter<"Visit"> | string | null
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    updatedAt?: DateTimeFilter<"Visit"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    psw?: XOR<PswProfileNullableRelationFilter, PswProfileWhereInput> | null
    checkEvents?: VisitCheckEventListRelationFilter
    notes?: VisitNoteListRelationFilter
    checklists?: VisitChecklistListRelationFilter
    incidents?: IncidentListRelationFilter
    timesheetItems?: TimesheetItemListRelationFilter
    DailyEntry?: DailyEntryListRelationFilter
  }, "id">

  export type VisitOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    requestedStartAt?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrderInput | SortOrder
    assignedPswId?: SortOrderInput | SortOrder
    serviceAddressLine1?: SortOrderInput | SortOrder
    serviceAddressLine2?: SortOrderInput | SortOrder
    serviceCity?: SortOrderInput | SortOrder
    serviceProvince?: SortOrderInput | SortOrder
    servicePostalCode?: SortOrderInput | SortOrder
    serviceLat?: SortOrderInput | SortOrder
    serviceLng?: SortOrderInput | SortOrder
    clientNotes?: SortOrderInput | SortOrder
    coordinatorNotes?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitCountOrderByAggregateInput
    _avg?: VisitAvgOrderByAggregateInput
    _max?: VisitMaxOrderByAggregateInput
    _min?: VisitMinOrderByAggregateInput
    _sum?: VisitSumOrderByAggregateInput
  }

  export type VisitScalarWhereWithAggregatesInput = {
    AND?: VisitScalarWhereWithAggregatesInput | VisitScalarWhereWithAggregatesInput[]
    OR?: VisitScalarWhereWithAggregatesInput[]
    NOT?: VisitScalarWhereWithAggregatesInput | VisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Visit"> | string
    clientId?: StringWithAggregatesFilter<"Visit"> | string
    serviceId?: StringWithAggregatesFilter<"Visit"> | string
    requestedStartAt?: DateTimeWithAggregatesFilter<"Visit"> | Date | string
    durationMinutes?: IntWithAggregatesFilter<"Visit"> | number
    status?: EnumVisitStatusNullableWithAggregatesFilter<"Visit"> | $Enums.VisitStatus | null
    assignedPswId?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    serviceAddressLine1?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    serviceAddressLine2?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    serviceCity?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    serviceProvince?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    servicePostalCode?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    serviceLat?: FloatNullableWithAggregatesFilter<"Visit"> | number | null
    serviceLng?: FloatNullableWithAggregatesFilter<"Visit"> | number | null
    clientNotes?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    coordinatorNotes?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Visit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Visit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Visit"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    baseRateHourly?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolNullableFilter<"Service"> | boolean | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    visits?: VisitListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    baseRateHourly?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: VisitOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    baseRateHourly?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolNullableFilter<"Service"> | boolean | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    visits?: VisitListRelationFilter
  }, "id" | "slug">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    baseRateHourly?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    slug?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    baseRateHourly?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolNullableWithAggregatesFilter<"Service"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type VisitCheckEventWhereInput = {
    AND?: VisitCheckEventWhereInput | VisitCheckEventWhereInput[]
    OR?: VisitCheckEventWhereInput[]
    NOT?: VisitCheckEventWhereInput | VisitCheckEventWhereInput[]
    id?: StringFilter<"VisitCheckEvent"> | string
    visitId?: StringFilter<"VisitCheckEvent"> | string
    pswId?: StringFilter<"VisitCheckEvent"> | string
    eventType?: EnumEventTypeFilter<"VisitCheckEvent"> | $Enums.EventType
    lat?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    lng?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    accuracyM?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    computedDistanceM?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    deviceTimeIso?: DateTimeNullableFilter<"VisitCheckEvent"> | Date | string | null
    serverTime?: DateTimeNullableFilter<"VisitCheckEvent"> | Date | string | null
    result?: EnumEventResultFilter<"VisitCheckEvent"> | $Enums.EventResult
    rejectReason?: StringNullableFilter<"VisitCheckEvent"> | string | null
    isOverride?: BoolNullableFilter<"VisitCheckEvent"> | boolean | null
    overrideByUserId?: StringNullableFilter<"VisitCheckEvent"> | string | null
    overrideReason?: StringNullableFilter<"VisitCheckEvent"> | string | null
    createdAt?: DateTimeFilter<"VisitCheckEvent"> | Date | string
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
    pswProfile?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
    overriddenBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type VisitCheckEventOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    eventType?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    accuracyM?: SortOrderInput | SortOrder
    computedDistanceM?: SortOrderInput | SortOrder
    deviceTimeIso?: SortOrderInput | SortOrder
    serverTime?: SortOrderInput | SortOrder
    result?: SortOrder
    rejectReason?: SortOrderInput | SortOrder
    isOverride?: SortOrderInput | SortOrder
    overrideByUserId?: SortOrderInput | SortOrder
    overrideReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    visit?: VisitOrderByWithRelationInput
    pswProfile?: PswProfileOrderByWithRelationInput
    overriddenBy?: UserOrderByWithRelationInput
  }

  export type VisitCheckEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitCheckEventWhereInput | VisitCheckEventWhereInput[]
    OR?: VisitCheckEventWhereInput[]
    NOT?: VisitCheckEventWhereInput | VisitCheckEventWhereInput[]
    visitId?: StringFilter<"VisitCheckEvent"> | string
    pswId?: StringFilter<"VisitCheckEvent"> | string
    eventType?: EnumEventTypeFilter<"VisitCheckEvent"> | $Enums.EventType
    lat?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    lng?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    accuracyM?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    computedDistanceM?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    deviceTimeIso?: DateTimeNullableFilter<"VisitCheckEvent"> | Date | string | null
    serverTime?: DateTimeNullableFilter<"VisitCheckEvent"> | Date | string | null
    result?: EnumEventResultFilter<"VisitCheckEvent"> | $Enums.EventResult
    rejectReason?: StringNullableFilter<"VisitCheckEvent"> | string | null
    isOverride?: BoolNullableFilter<"VisitCheckEvent"> | boolean | null
    overrideByUserId?: StringNullableFilter<"VisitCheckEvent"> | string | null
    overrideReason?: StringNullableFilter<"VisitCheckEvent"> | string | null
    createdAt?: DateTimeFilter<"VisitCheckEvent"> | Date | string
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
    pswProfile?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
    overriddenBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type VisitCheckEventOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    eventType?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    accuracyM?: SortOrderInput | SortOrder
    computedDistanceM?: SortOrderInput | SortOrder
    deviceTimeIso?: SortOrderInput | SortOrder
    serverTime?: SortOrderInput | SortOrder
    result?: SortOrder
    rejectReason?: SortOrderInput | SortOrder
    isOverride?: SortOrderInput | SortOrder
    overrideByUserId?: SortOrderInput | SortOrder
    overrideReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VisitCheckEventCountOrderByAggregateInput
    _avg?: VisitCheckEventAvgOrderByAggregateInput
    _max?: VisitCheckEventMaxOrderByAggregateInput
    _min?: VisitCheckEventMinOrderByAggregateInput
    _sum?: VisitCheckEventSumOrderByAggregateInput
  }

  export type VisitCheckEventScalarWhereWithAggregatesInput = {
    AND?: VisitCheckEventScalarWhereWithAggregatesInput | VisitCheckEventScalarWhereWithAggregatesInput[]
    OR?: VisitCheckEventScalarWhereWithAggregatesInput[]
    NOT?: VisitCheckEventScalarWhereWithAggregatesInput | VisitCheckEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitCheckEvent"> | string
    visitId?: StringWithAggregatesFilter<"VisitCheckEvent"> | string
    pswId?: StringWithAggregatesFilter<"VisitCheckEvent"> | string
    eventType?: EnumEventTypeWithAggregatesFilter<"VisitCheckEvent"> | $Enums.EventType
    lat?: FloatNullableWithAggregatesFilter<"VisitCheckEvent"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"VisitCheckEvent"> | number | null
    accuracyM?: FloatNullableWithAggregatesFilter<"VisitCheckEvent"> | number | null
    computedDistanceM?: FloatNullableWithAggregatesFilter<"VisitCheckEvent"> | number | null
    deviceTimeIso?: DateTimeNullableWithAggregatesFilter<"VisitCheckEvent"> | Date | string | null
    serverTime?: DateTimeNullableWithAggregatesFilter<"VisitCheckEvent"> | Date | string | null
    result?: EnumEventResultWithAggregatesFilter<"VisitCheckEvent"> | $Enums.EventResult
    rejectReason?: StringNullableWithAggregatesFilter<"VisitCheckEvent"> | string | null
    isOverride?: BoolNullableWithAggregatesFilter<"VisitCheckEvent"> | boolean | null
    overrideByUserId?: StringNullableWithAggregatesFilter<"VisitCheckEvent"> | string | null
    overrideReason?: StringNullableWithAggregatesFilter<"VisitCheckEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VisitCheckEvent"> | Date | string
  }

  export type VisitNoteWhereInput = {
    AND?: VisitNoteWhereInput | VisitNoteWhereInput[]
    OR?: VisitNoteWhereInput[]
    NOT?: VisitNoteWhereInput | VisitNoteWhereInput[]
    id?: StringFilter<"VisitNote"> | string
    visitId?: StringFilter<"VisitNote"> | string
    pswId?: StringFilter<"VisitNote"> | string
    noteText?: StringFilter<"VisitNote"> | string
    createdAt?: DateTimeFilter<"VisitNote"> | Date | string
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
    psw?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
  }

  export type VisitNoteOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    noteText?: SortOrder
    createdAt?: SortOrder
    visit?: VisitOrderByWithRelationInput
    psw?: PswProfileOrderByWithRelationInput
  }

  export type VisitNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitNoteWhereInput | VisitNoteWhereInput[]
    OR?: VisitNoteWhereInput[]
    NOT?: VisitNoteWhereInput | VisitNoteWhereInput[]
    visitId?: StringFilter<"VisitNote"> | string
    pswId?: StringFilter<"VisitNote"> | string
    noteText?: StringFilter<"VisitNote"> | string
    createdAt?: DateTimeFilter<"VisitNote"> | Date | string
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
    psw?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
  }, "id">

  export type VisitNoteOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    noteText?: SortOrder
    createdAt?: SortOrder
    _count?: VisitNoteCountOrderByAggregateInput
    _max?: VisitNoteMaxOrderByAggregateInput
    _min?: VisitNoteMinOrderByAggregateInput
  }

  export type VisitNoteScalarWhereWithAggregatesInput = {
    AND?: VisitNoteScalarWhereWithAggregatesInput | VisitNoteScalarWhereWithAggregatesInput[]
    OR?: VisitNoteScalarWhereWithAggregatesInput[]
    NOT?: VisitNoteScalarWhereWithAggregatesInput | VisitNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitNote"> | string
    visitId?: StringWithAggregatesFilter<"VisitNote"> | string
    pswId?: StringWithAggregatesFilter<"VisitNote"> | string
    noteText?: StringWithAggregatesFilter<"VisitNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VisitNote"> | Date | string
  }

  export type VisitChecklistWhereInput = {
    AND?: VisitChecklistWhereInput | VisitChecklistWhereInput[]
    OR?: VisitChecklistWhereInput[]
    NOT?: VisitChecklistWhereInput | VisitChecklistWhereInput[]
    id?: StringFilter<"VisitChecklist"> | string
    visitId?: StringFilter<"VisitChecklist"> | string
    pswId?: StringFilter<"VisitChecklist"> | string
    checklistJson?: JsonFilter<"VisitChecklist">
    createdAt?: DateTimeFilter<"VisitChecklist"> | Date | string
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
    psw?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
  }

  export type VisitChecklistOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    checklistJson?: SortOrder
    createdAt?: SortOrder
    visit?: VisitOrderByWithRelationInput
    psw?: PswProfileOrderByWithRelationInput
  }

  export type VisitChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitChecklistWhereInput | VisitChecklistWhereInput[]
    OR?: VisitChecklistWhereInput[]
    NOT?: VisitChecklistWhereInput | VisitChecklistWhereInput[]
    visitId?: StringFilter<"VisitChecklist"> | string
    pswId?: StringFilter<"VisitChecklist"> | string
    checklistJson?: JsonFilter<"VisitChecklist">
    createdAt?: DateTimeFilter<"VisitChecklist"> | Date | string
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
    psw?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
  }, "id">

  export type VisitChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    checklistJson?: SortOrder
    createdAt?: SortOrder
    _count?: VisitChecklistCountOrderByAggregateInput
    _max?: VisitChecklistMaxOrderByAggregateInput
    _min?: VisitChecklistMinOrderByAggregateInput
  }

  export type VisitChecklistScalarWhereWithAggregatesInput = {
    AND?: VisitChecklistScalarWhereWithAggregatesInput | VisitChecklistScalarWhereWithAggregatesInput[]
    OR?: VisitChecklistScalarWhereWithAggregatesInput[]
    NOT?: VisitChecklistScalarWhereWithAggregatesInput | VisitChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitChecklist"> | string
    visitId?: StringWithAggregatesFilter<"VisitChecklist"> | string
    pswId?: StringWithAggregatesFilter<"VisitChecklist"> | string
    checklistJson?: JsonWithAggregatesFilter<"VisitChecklist">
    createdAt?: DateTimeWithAggregatesFilter<"VisitChecklist"> | Date | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    visitId?: StringNullableFilter<"Incident"> | string | null
    reporterUserId?: StringFilter<"Incident"> | string
    type?: EnumIncidentTypeFilter<"Incident"> | $Enums.IncidentType
    description?: StringFilter<"Incident"> | string
    status?: EnumIncidentStatusNullableFilter<"Incident"> | $Enums.IncidentStatus | null
    resolutionNotes?: StringNullableFilter<"Incident"> | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    visit?: XOR<VisitNullableRelationFilter, VisitWhereInput> | null
    reporter?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    visitId?: SortOrderInput | SortOrder
    reporterUserId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrderInput | SortOrder
    resolutionNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visit?: VisitOrderByWithRelationInput
    reporter?: UserOrderByWithRelationInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    visitId?: StringNullableFilter<"Incident"> | string | null
    reporterUserId?: StringFilter<"Incident"> | string
    type?: EnumIncidentTypeFilter<"Incident"> | $Enums.IncidentType
    description?: StringFilter<"Incident"> | string
    status?: EnumIncidentStatusNullableFilter<"Incident"> | $Enums.IncidentStatus | null
    resolutionNotes?: StringNullableFilter<"Incident"> | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    visit?: XOR<VisitNullableRelationFilter, VisitWhereInput> | null
    reporter?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    visitId?: SortOrderInput | SortOrder
    reporterUserId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrderInput | SortOrder
    resolutionNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    visitId?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    reporterUserId?: StringWithAggregatesFilter<"Incident"> | string
    type?: EnumIncidentTypeWithAggregatesFilter<"Incident"> | $Enums.IncidentType
    description?: StringWithAggregatesFilter<"Incident"> | string
    status?: EnumIncidentStatusNullableWithAggregatesFilter<"Incident"> | $Enums.IncidentStatus | null
    resolutionNotes?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
  }

  export type TimesheetWhereInput = {
    AND?: TimesheetWhereInput | TimesheetWhereInput[]
    OR?: TimesheetWhereInput[]
    NOT?: TimesheetWhereInput | TimesheetWhereInput[]
    id?: StringFilter<"Timesheet"> | string
    pswId?: StringFilter<"Timesheet"> | string
    weekId?: StringFilter<"Timesheet"> | string
    totalMinutes?: IntNullableFilter<"Timesheet"> | number | null
    status?: EnumTimesheetStatusNullableFilter<"Timesheet"> | $Enums.TimesheetStatus | null
    submittedAt?: DateTimeNullableFilter<"Timesheet"> | Date | string | null
    reviewedBy?: StringNullableFilter<"Timesheet"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Timesheet"> | Date | string | null
    createdAt?: DateTimeFilter<"Timesheet"> | Date | string
    updatedAt?: DateTimeFilter<"Timesheet"> | Date | string
    psw?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
    reviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: TimesheetItemListRelationFilter
  }

  export type TimesheetOrderByWithRelationInput = {
    id?: SortOrder
    pswId?: SortOrder
    weekId?: SortOrder
    totalMinutes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    psw?: PswProfileOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    items?: TimesheetItemOrderByRelationAggregateInput
  }

  export type TimesheetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimesheetWhereInput | TimesheetWhereInput[]
    OR?: TimesheetWhereInput[]
    NOT?: TimesheetWhereInput | TimesheetWhereInput[]
    pswId?: StringFilter<"Timesheet"> | string
    weekId?: StringFilter<"Timesheet"> | string
    totalMinutes?: IntNullableFilter<"Timesheet"> | number | null
    status?: EnumTimesheetStatusNullableFilter<"Timesheet"> | $Enums.TimesheetStatus | null
    submittedAt?: DateTimeNullableFilter<"Timesheet"> | Date | string | null
    reviewedBy?: StringNullableFilter<"Timesheet"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Timesheet"> | Date | string | null
    createdAt?: DateTimeFilter<"Timesheet"> | Date | string
    updatedAt?: DateTimeFilter<"Timesheet"> | Date | string
    psw?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
    reviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    items?: TimesheetItemListRelationFilter
  }, "id">

  export type TimesheetOrderByWithAggregationInput = {
    id?: SortOrder
    pswId?: SortOrder
    weekId?: SortOrder
    totalMinutes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimesheetCountOrderByAggregateInput
    _avg?: TimesheetAvgOrderByAggregateInput
    _max?: TimesheetMaxOrderByAggregateInput
    _min?: TimesheetMinOrderByAggregateInput
    _sum?: TimesheetSumOrderByAggregateInput
  }

  export type TimesheetScalarWhereWithAggregatesInput = {
    AND?: TimesheetScalarWhereWithAggregatesInput | TimesheetScalarWhereWithAggregatesInput[]
    OR?: TimesheetScalarWhereWithAggregatesInput[]
    NOT?: TimesheetScalarWhereWithAggregatesInput | TimesheetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Timesheet"> | string
    pswId?: StringWithAggregatesFilter<"Timesheet"> | string
    weekId?: StringWithAggregatesFilter<"Timesheet"> | string
    totalMinutes?: IntNullableWithAggregatesFilter<"Timesheet"> | number | null
    status?: EnumTimesheetStatusNullableWithAggregatesFilter<"Timesheet"> | $Enums.TimesheetStatus | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Timesheet"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"Timesheet"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"Timesheet"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Timesheet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Timesheet"> | Date | string
  }

  export type TimesheetItemWhereInput = {
    AND?: TimesheetItemWhereInput | TimesheetItemWhereInput[]
    OR?: TimesheetItemWhereInput[]
    NOT?: TimesheetItemWhereInput | TimesheetItemWhereInput[]
    id?: StringFilter<"TimesheetItem"> | string
    timesheetId?: StringFilter<"TimesheetItem"> | string
    visitId?: StringFilter<"TimesheetItem"> | string
    minutes?: IntFilter<"TimesheetItem"> | number
    createdAt?: DateTimeFilter<"TimesheetItem"> | Date | string
    timesheet?: XOR<TimesheetRelationFilter, TimesheetWhereInput>
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
  }

  export type TimesheetItemOrderByWithRelationInput = {
    id?: SortOrder
    timesheetId?: SortOrder
    visitId?: SortOrder
    minutes?: SortOrder
    createdAt?: SortOrder
    timesheet?: TimesheetOrderByWithRelationInput
    visit?: VisitOrderByWithRelationInput
  }

  export type TimesheetItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimesheetItemWhereInput | TimesheetItemWhereInput[]
    OR?: TimesheetItemWhereInput[]
    NOT?: TimesheetItemWhereInput | TimesheetItemWhereInput[]
    timesheetId?: StringFilter<"TimesheetItem"> | string
    visitId?: StringFilter<"TimesheetItem"> | string
    minutes?: IntFilter<"TimesheetItem"> | number
    createdAt?: DateTimeFilter<"TimesheetItem"> | Date | string
    timesheet?: XOR<TimesheetRelationFilter, TimesheetWhereInput>
    visit?: XOR<VisitRelationFilter, VisitWhereInput>
  }, "id">

  export type TimesheetItemOrderByWithAggregationInput = {
    id?: SortOrder
    timesheetId?: SortOrder
    visitId?: SortOrder
    minutes?: SortOrder
    createdAt?: SortOrder
    _count?: TimesheetItemCountOrderByAggregateInput
    _avg?: TimesheetItemAvgOrderByAggregateInput
    _max?: TimesheetItemMaxOrderByAggregateInput
    _min?: TimesheetItemMinOrderByAggregateInput
    _sum?: TimesheetItemSumOrderByAggregateInput
  }

  export type TimesheetItemScalarWhereWithAggregatesInput = {
    AND?: TimesheetItemScalarWhereWithAggregatesInput | TimesheetItemScalarWhereWithAggregatesInput[]
    OR?: TimesheetItemScalarWhereWithAggregatesInput[]
    NOT?: TimesheetItemScalarWhereWithAggregatesInput | TimesheetItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimesheetItem"> | string
    timesheetId?: StringWithAggregatesFilter<"TimesheetItem"> | string
    visitId?: StringWithAggregatesFilter<"TimesheetItem"> | string
    minutes?: IntWithAggregatesFilter<"TimesheetItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TimesheetItem"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    clientId?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusNullableFilter<"Invoice"> | $Enums.InvoiceStatus | null
    currency?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    tax?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    subtotal?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientProfileOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    clientId?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusNullableFilter<"Invoice"> | $Enums.InvoiceStatus | null
    currency?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    tax?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    payments?: PaymentListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    subtotal?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    clientId?: StringWithAggregatesFilter<"Invoice"> | string
    status?: EnumInvoiceStatusNullableWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus | null
    currency?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    subtotal?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    tax?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type MessageThreadWhereInput = {
    AND?: MessageThreadWhereInput | MessageThreadWhereInput[]
    OR?: MessageThreadWhereInput[]
    NOT?: MessageThreadWhereInput | MessageThreadWhereInput[]
    id?: StringFilter<"MessageThread"> | string
    threadType?: StringFilter<"MessageThread"> | string
    clientId?: StringNullableFilter<"MessageThread"> | string | null
    pswId?: StringNullableFilter<"MessageThread"> | string | null
    createdAt?: DateTimeFilter<"MessageThread"> | Date | string
    client?: XOR<ClientProfileNullableRelationFilter, ClientProfileWhereInput> | null
    psw?: XOR<PswProfileNullableRelationFilter, PswProfileWhereInput> | null
    messages?: MessageListRelationFilter
  }

  export type MessageThreadOrderByWithRelationInput = {
    id?: SortOrder
    threadType?: SortOrder
    clientId?: SortOrderInput | SortOrder
    pswId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    client?: ClientProfileOrderByWithRelationInput
    psw?: PswProfileOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type MessageThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageThreadWhereInput | MessageThreadWhereInput[]
    OR?: MessageThreadWhereInput[]
    NOT?: MessageThreadWhereInput | MessageThreadWhereInput[]
    threadType?: StringFilter<"MessageThread"> | string
    clientId?: StringNullableFilter<"MessageThread"> | string | null
    pswId?: StringNullableFilter<"MessageThread"> | string | null
    createdAt?: DateTimeFilter<"MessageThread"> | Date | string
    client?: XOR<ClientProfileNullableRelationFilter, ClientProfileWhereInput> | null
    psw?: XOR<PswProfileNullableRelationFilter, PswProfileWhereInput> | null
    messages?: MessageListRelationFilter
  }, "id">

  export type MessageThreadOrderByWithAggregationInput = {
    id?: SortOrder
    threadType?: SortOrder
    clientId?: SortOrderInput | SortOrder
    pswId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageThreadCountOrderByAggregateInput
    _max?: MessageThreadMaxOrderByAggregateInput
    _min?: MessageThreadMinOrderByAggregateInput
  }

  export type MessageThreadScalarWhereWithAggregatesInput = {
    AND?: MessageThreadScalarWhereWithAggregatesInput | MessageThreadScalarWhereWithAggregatesInput[]
    OR?: MessageThreadScalarWhereWithAggregatesInput[]
    NOT?: MessageThreadScalarWhereWithAggregatesInput | MessageThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageThread"> | string
    threadType?: StringWithAggregatesFilter<"MessageThread"> | string
    clientId?: StringNullableWithAggregatesFilter<"MessageThread"> | string | null
    pswId?: StringNullableWithAggregatesFilter<"MessageThread"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageThread"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    senderUserId?: StringFilter<"Message"> | string
    bodyText?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    thread?: XOR<MessageThreadRelationFilter, MessageThreadWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderUserId?: SortOrder
    bodyText?: SortOrder
    createdAt?: SortOrder
    thread?: MessageThreadOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    threadId?: StringFilter<"Message"> | string
    senderUserId?: StringFilter<"Message"> | string
    bodyText?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    thread?: XOR<MessageThreadRelationFilter, MessageThreadWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderUserId?: SortOrder
    bodyText?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    threadId?: StringWithAggregatesFilter<"Message"> | string
    senderUserId?: StringWithAggregatesFilter<"Message"> | string
    bodyText?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    metadataJson?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    metadataJson?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    metadataJson?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    metadataJson?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorUserId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceType?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadataJson?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    fullName?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    phone?: StringNullableFilter<"Lead"> | string | null
    message?: StringNullableFilter<"Lead"> | string | null
    source?: StringFilter<"Lead"> | string
    status?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    source?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    fullName?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    phone?: StringNullableFilter<"Lead"> | string | null
    message?: StringNullableFilter<"Lead"> | string | null
    source?: StringFilter<"Lead"> | string
    status?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    source?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    fullName?: StringWithAggregatesFilter<"Lead"> | string
    email?: StringWithAggregatesFilter<"Lead"> | string
    phone?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    message?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    source?: StringWithAggregatesFilter<"Lead"> | string
    status?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    contentHtml?: StringNullableFilter<"BlogPost"> | string | null
    status?: StringNullableFilter<"BlogPost"> | string | null
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    authorUserId?: StringNullableFilter<"BlogPost"> | string | null
    featureImageDocId?: StringNullableFilter<"BlogPost"> | string | null
    seoTitle?: StringNullableFilter<"BlogPost"> | string | null
    seoDescription?: StringNullableFilter<"BlogPost"> | string | null
    canonicalUrl?: StringNullableFilter<"BlogPost"> | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    contentHtml?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    authorUserId?: SortOrderInput | SortOrder
    featureImageDocId?: SortOrderInput | SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    contentHtml?: StringNullableFilter<"BlogPost"> | string | null
    status?: StringNullableFilter<"BlogPost"> | string | null
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    authorUserId?: StringNullableFilter<"BlogPost"> | string | null
    featureImageDocId?: StringNullableFilter<"BlogPost"> | string | null
    seoTitle?: StringNullableFilter<"BlogPost"> | string | null
    seoDescription?: StringNullableFilter<"BlogPost"> | string | null
    canonicalUrl?: StringNullableFilter<"BlogPost"> | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    contentHtml?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    authorUserId?: SortOrderInput | SortOrder
    featureImageDocId?: SortOrderInput | SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    contentHtml?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    status?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    authorUserId?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    featureImageDocId?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    seoTitle?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    seoDescription?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    canonicalUrl?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
  }

  export type PswDocumentWhereInput = {
    AND?: PswDocumentWhereInput | PswDocumentWhereInput[]
    OR?: PswDocumentWhereInput[]
    NOT?: PswDocumentWhereInput | PswDocumentWhereInput[]
    id?: StringFilter<"PswDocument"> | string
    pswId?: StringFilter<"PswDocument"> | string
    docType?: StringFilter<"PswDocument"> | string
    fileKey?: StringFilter<"PswDocument"> | string
    status?: EnumDocStatusNullableFilter<"PswDocument"> | $Enums.DocStatus | null
    expiryDate?: DateTimeNullableFilter<"PswDocument"> | Date | string | null
    verifiedBy?: StringNullableFilter<"PswDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"PswDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"PswDocument"> | Date | string
    updatedAt?: DateTimeFilter<"PswDocument"> | Date | string
    psw?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
    verifier?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PswDocumentOrderByWithRelationInput = {
    id?: SortOrder
    pswId?: SortOrder
    docType?: SortOrder
    fileKey?: SortOrder
    status?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    psw?: PswProfileOrderByWithRelationInput
    verifier?: UserOrderByWithRelationInput
  }

  export type PswDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PswDocumentWhereInput | PswDocumentWhereInput[]
    OR?: PswDocumentWhereInput[]
    NOT?: PswDocumentWhereInput | PswDocumentWhereInput[]
    pswId?: StringFilter<"PswDocument"> | string
    docType?: StringFilter<"PswDocument"> | string
    fileKey?: StringFilter<"PswDocument"> | string
    status?: EnumDocStatusNullableFilter<"PswDocument"> | $Enums.DocStatus | null
    expiryDate?: DateTimeNullableFilter<"PswDocument"> | Date | string | null
    verifiedBy?: StringNullableFilter<"PswDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"PswDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"PswDocument"> | Date | string
    updatedAt?: DateTimeFilter<"PswDocument"> | Date | string
    psw?: XOR<PswProfileRelationFilter, PswProfileWhereInput>
    verifier?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type PswDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    pswId?: SortOrder
    docType?: SortOrder
    fileKey?: SortOrder
    status?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PswDocumentCountOrderByAggregateInput
    _max?: PswDocumentMaxOrderByAggregateInput
    _min?: PswDocumentMinOrderByAggregateInput
  }

  export type PswDocumentScalarWhereWithAggregatesInput = {
    AND?: PswDocumentScalarWhereWithAggregatesInput | PswDocumentScalarWhereWithAggregatesInput[]
    OR?: PswDocumentScalarWhereWithAggregatesInput[]
    NOT?: PswDocumentScalarWhereWithAggregatesInput | PswDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PswDocument"> | string
    pswId?: StringWithAggregatesFilter<"PswDocument"> | string
    docType?: StringWithAggregatesFilter<"PswDocument"> | string
    fileKey?: StringWithAggregatesFilter<"PswDocument"> | string
    status?: EnumDocStatusNullableWithAggregatesFilter<"PswDocument"> | $Enums.DocStatus | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"PswDocument"> | Date | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"PswDocument"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"PswDocument"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PswDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PswDocument"> | Date | string
  }

  export type FAQWhereInput = {
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    id?: StringFilter<"FAQ"> | string
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    category?: StringFilter<"FAQ"> | string
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
  }

  export type FAQOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    category?: StringFilter<"FAQ"> | string
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
  }, "id">

  export type FAQOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FAQCountOrderByAggregateInput
    _max?: FAQMaxOrderByAggregateInput
    _min?: FAQMinOrderByAggregateInput
  }

  export type FAQScalarWhereWithAggregatesInput = {
    AND?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    OR?: FAQScalarWhereWithAggregatesInput[]
    NOT?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FAQ"> | string
    question?: StringWithAggregatesFilter<"FAQ"> | string
    answer?: StringWithAggregatesFilter<"FAQ"> | string
    category?: StringWithAggregatesFilter<"FAQ"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
  }

  export type DailyEntryWhereInput = {
    AND?: DailyEntryWhereInput | DailyEntryWhereInput[]
    OR?: DailyEntryWhereInput[]
    NOT?: DailyEntryWhereInput | DailyEntryWhereInput[]
    id?: StringFilter<"DailyEntry"> | string
    clientId?: StringFilter<"DailyEntry"> | string
    staffId?: StringFilter<"DailyEntry"> | string
    visitId?: StringNullableFilter<"DailyEntry"> | string | null
    adlData?: JsonFilter<"DailyEntry">
    medication?: JsonNullableFilter<"DailyEntry">
    mood?: IntNullableFilter<"DailyEntry"> | number | null
    vitals?: JsonNullableFilter<"DailyEntry">
    notes?: StringNullableFilter<"DailyEntry"> | string | null
    signature?: StringNullableFilter<"DailyEntry"> | string | null
    status?: EnumDailyEntryStatusFilter<"DailyEntry"> | $Enums.DailyEntryStatus
    createdAt?: DateTimeFilter<"DailyEntry"> | Date | string
    updatedAt?: DateTimeFilter<"DailyEntry"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    staff?: XOR<UserRelationFilter, UserWhereInput>
    visit?: XOR<VisitNullableRelationFilter, VisitWhereInput> | null
  }

  export type DailyEntryOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    adlData?: SortOrder
    medication?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    vitals?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientProfileOrderByWithRelationInput
    staff?: UserOrderByWithRelationInput
    visit?: VisitOrderByWithRelationInput
  }

  export type DailyEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DailyEntryWhereInput | DailyEntryWhereInput[]
    OR?: DailyEntryWhereInput[]
    NOT?: DailyEntryWhereInput | DailyEntryWhereInput[]
    clientId?: StringFilter<"DailyEntry"> | string
    staffId?: StringFilter<"DailyEntry"> | string
    visitId?: StringNullableFilter<"DailyEntry"> | string | null
    adlData?: JsonFilter<"DailyEntry">
    medication?: JsonNullableFilter<"DailyEntry">
    mood?: IntNullableFilter<"DailyEntry"> | number | null
    vitals?: JsonNullableFilter<"DailyEntry">
    notes?: StringNullableFilter<"DailyEntry"> | string | null
    signature?: StringNullableFilter<"DailyEntry"> | string | null
    status?: EnumDailyEntryStatusFilter<"DailyEntry"> | $Enums.DailyEntryStatus
    createdAt?: DateTimeFilter<"DailyEntry"> | Date | string
    updatedAt?: DateTimeFilter<"DailyEntry"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    staff?: XOR<UserRelationFilter, UserWhereInput>
    visit?: XOR<VisitNullableRelationFilter, VisitWhereInput> | null
  }, "id">

  export type DailyEntryOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    adlData?: SortOrder
    medication?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    vitals?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyEntryCountOrderByAggregateInput
    _avg?: DailyEntryAvgOrderByAggregateInput
    _max?: DailyEntryMaxOrderByAggregateInput
    _min?: DailyEntryMinOrderByAggregateInput
    _sum?: DailyEntrySumOrderByAggregateInput
  }

  export type DailyEntryScalarWhereWithAggregatesInput = {
    AND?: DailyEntryScalarWhereWithAggregatesInput | DailyEntryScalarWhereWithAggregatesInput[]
    OR?: DailyEntryScalarWhereWithAggregatesInput[]
    NOT?: DailyEntryScalarWhereWithAggregatesInput | DailyEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyEntry"> | string
    clientId?: StringWithAggregatesFilter<"DailyEntry"> | string
    staffId?: StringWithAggregatesFilter<"DailyEntry"> | string
    visitId?: StringNullableWithAggregatesFilter<"DailyEntry"> | string | null
    adlData?: JsonWithAggregatesFilter<"DailyEntry">
    medication?: JsonNullableWithAggregatesFilter<"DailyEntry">
    mood?: IntNullableWithAggregatesFilter<"DailyEntry"> | number | null
    vitals?: JsonNullableWithAggregatesFilter<"DailyEntry">
    notes?: StringNullableWithAggregatesFilter<"DailyEntry"> | string | null
    signature?: StringNullableWithAggregatesFilter<"DailyEntry"> | string | null
    status?: EnumDailyEntryStatusWithAggregatesFilter<"DailyEntry"> | $Enums.DailyEntryStatus
    createdAt?: DateTimeWithAggregatesFilter<"DailyEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyEntry"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileCreateInput = {
    id?: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    visits?: VisitCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateInput = {
    id?: string
    userId: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    visits?: VisitUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileCreateManyInput = {
    id?: string
    userId: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PswProfileCreateInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPswProfileInput
    documents?: PswDocumentCreateNestedManyWithoutPswInput
    assignedVisits?: VisitCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistCreateNestedManyWithoutPswInput
    timesheets?: TimesheetCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadCreateNestedManyWithoutPswInput
  }

  export type PswProfileUncheckedCreateInput = {
    id?: string
    userId: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PswDocumentUncheckedCreateNestedManyWithoutPswInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutPswInput
    timesheets?: TimesheetUncheckedCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutPswInput
  }

  export type PswProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPswProfileNestedInput
    documents?: PswDocumentUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutPswNestedInput
  }

  export type PswProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PswDocumentUncheckedUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUncheckedUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutPswNestedInput
  }

  export type PswProfileCreateManyInput = {
    id?: string
    userId: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PswProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PswProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutVisitsInput
    service: ServiceCreateNestedOneWithoutVisitsInput
    psw?: PswProfileCreateNestedOneWithoutAssignedVisitsInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutVisitInput
    notes?: VisitNoteCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemUncheckedCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutVisitsNestedInput
    service?: ServiceUpdateOneRequiredWithoutVisitsNestedInput
    psw?: PswProfileUpdateOneWithoutAssignedVisitsNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitCreateManyInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseRateHourly?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseRateHourly?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseRateHourly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseRateHourly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseRateHourly?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseRateHourly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseRateHourly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCheckEventCreateInput = {
    id?: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideReason?: string | null
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutCheckEventsInput
    pswProfile: PswProfileCreateNestedOneWithoutCheckEventsInput
    overriddenBy?: UserCreateNestedOneWithoutVisitCheckEventInput
  }

  export type VisitCheckEventUncheckedCreateInput = {
    id?: string
    visitId: string
    pswId: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideByUserId?: string | null
    overrideReason?: string | null
    createdAt?: Date | string
  }

  export type VisitCheckEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutCheckEventsNestedInput
    pswProfile?: PswProfileUpdateOneRequiredWithoutCheckEventsNestedInput
    overriddenBy?: UserUpdateOneWithoutVisitCheckEventNestedInput
  }

  export type VisitCheckEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCheckEventCreateManyInput = {
    id?: string
    visitId: string
    pswId: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideByUserId?: string | null
    overrideReason?: string | null
    createdAt?: Date | string
  }

  export type VisitCheckEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCheckEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitNoteCreateInput = {
    id?: string
    noteText: string
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutNotesInput
    psw: PswProfileCreateNestedOneWithoutNotesInput
  }

  export type VisitNoteUncheckedCreateInput = {
    id?: string
    visitId: string
    pswId: string
    noteText: string
    createdAt?: Date | string
  }

  export type VisitNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutNotesNestedInput
    psw?: PswProfileUpdateOneRequiredWithoutNotesNestedInput
  }

  export type VisitNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitNoteCreateManyInput = {
    id?: string
    visitId: string
    pswId: string
    noteText: string
    createdAt?: Date | string
  }

  export type VisitNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitChecklistCreateInput = {
    id?: string
    checklistJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutChecklistsInput
    psw: PswProfileCreateNestedOneWithoutChecklistsInput
  }

  export type VisitChecklistUncheckedCreateInput = {
    id?: string
    visitId: string
    pswId: string
    checklistJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VisitChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutChecklistsNestedInput
    psw?: PswProfileUpdateOneRequiredWithoutChecklistsNestedInput
  }

  export type VisitChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitChecklistCreateManyInput = {
    id?: string
    visitId: string
    pswId: string
    checklistJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VisitChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateInput = {
    id?: string
    type: $Enums.IncidentType
    description: string
    status?: $Enums.IncidentStatus | null
    resolutionNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visit?: VisitCreateNestedOneWithoutIncidentsInput
    reporter: UserCreateNestedOneWithoutReportedIncidentsInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    visitId?: string | null
    reporterUserId: string
    type: $Enums.IncidentType
    description: string
    status?: $Enums.IncidentStatus | null
    resolutionNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneWithoutIncidentsNestedInput
    reporter?: UserUpdateOneRequiredWithoutReportedIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    reporterUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateManyInput = {
    id?: string
    visitId?: string | null
    reporterUserId: string
    type: $Enums.IncidentType
    description: string
    status?: $Enums.IncidentStatus | null
    resolutionNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    reporterUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetCreateInput = {
    id?: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    psw: PswProfileCreateNestedOneWithoutTimesheetsInput
    reviewer?: UserCreateNestedOneWithoutReviewedTimesheetsInput
    items?: TimesheetItemCreateNestedManyWithoutTimesheetInput
  }

  export type TimesheetUncheckedCreateInput = {
    id?: string
    pswId: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TimesheetItemUncheckedCreateNestedManyWithoutTimesheetInput
  }

  export type TimesheetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    psw?: PswProfileUpdateOneRequiredWithoutTimesheetsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedTimesheetsNestedInput
    items?: TimesheetItemUpdateManyWithoutTimesheetNestedInput
  }

  export type TimesheetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TimesheetItemUncheckedUpdateManyWithoutTimesheetNestedInput
  }

  export type TimesheetCreateManyInput = {
    id?: string
    pswId: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimesheetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetItemCreateInput = {
    id?: string
    minutes: number
    createdAt?: Date | string
    timesheet: TimesheetCreateNestedOneWithoutItemsInput
    visit: VisitCreateNestedOneWithoutTimesheetItemsInput
  }

  export type TimesheetItemUncheckedCreateInput = {
    id?: string
    timesheetId: string
    visitId: string
    minutes: number
    createdAt?: Date | string
  }

  export type TimesheetItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timesheet?: TimesheetUpdateOneRequiredWithoutItemsNestedInput
    visit?: VisitUpdateOneRequiredWithoutTimesheetItemsNestedInput
  }

  export type TimesheetItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timesheetId?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetItemCreateManyInput = {
    id?: string
    timesheetId: string
    visitId: string
    minutes: number
    createdAt?: Date | string
  }

  export type TimesheetItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timesheetId?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    status?: $Enums.InvoiceStatus | null
    currency?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string | null
    tax?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    clientId: string
    status?: $Enums.InvoiceStatus | null
    currency?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string | null
    tax?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    clientId: string
    status?: $Enums.InvoiceStatus | null
    currency?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string | null
    tax?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    stripePaymentIntentId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    stripePaymentIntentId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoiceId: string
    stripePaymentIntentId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadCreateInput = {
    id?: string
    threadType: string
    createdAt?: Date | string
    client?: ClientProfileCreateNestedOneWithoutMessageThreadsInput
    psw?: PswProfileCreateNestedOneWithoutMessageThreadsInput
    messages?: MessageCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateInput = {
    id?: string
    threadType: string
    clientId?: string | null
    pswId?: string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneWithoutMessageThreadsNestedInput
    psw?: PswProfileUpdateOneWithoutMessageThreadsNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    pswId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadCreateManyInput = {
    id?: string
    threadType: string
    clientId?: string | null
    pswId?: string | null
    createdAt?: Date | string
  }

  export type MessageThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    pswId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    bodyText: string
    createdAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    threadId: string
    senderUserId: string
    bodyText: string
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderUserId?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    threadId: string
    senderUserId: string
    bodyText: string
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderUserId?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resourceType: string
    resourceId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorUserId?: string | null
    action: string
    resourceType: string
    resourceId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorUserId?: string | null
    action: string
    resourceType: string
    resourceId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    message?: string | null
    source: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    message?: string | null
    source: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    message?: string | null
    source: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    contentHtml?: string | null
    status?: string | null
    publishedAt?: Date | string | null
    featureImageDocId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    canonicalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: UserCreateNestedOneWithoutBlogPostsInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    contentHtml?: string | null
    status?: string | null
    publishedAt?: Date | string | null
    authorUserId?: string | null
    featureImageDocId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    canonicalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    contentHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureImageDocId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutBlogPostsNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    contentHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    featureImageDocId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    contentHtml?: string | null
    status?: string | null
    publishedAt?: Date | string | null
    authorUserId?: string | null
    featureImageDocId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    canonicalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    contentHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureImageDocId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    contentHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    featureImageDocId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PswDocumentCreateInput = {
    id?: string
    docType: string
    fileKey: string
    status?: $Enums.DocStatus | null
    expiryDate?: Date | string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    psw: PswProfileCreateNestedOneWithoutDocumentsInput
    verifier?: UserCreateNestedOneWithoutVerifiedDocsInput
  }

  export type PswDocumentUncheckedCreateInput = {
    id?: string
    pswId: string
    docType: string
    fileKey: string
    status?: $Enums.DocStatus | null
    expiryDate?: Date | string | null
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PswDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    psw?: PswProfileUpdateOneRequiredWithoutDocumentsNestedInput
    verifier?: UserUpdateOneWithoutVerifiedDocsNestedInput
  }

  export type PswDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PswDocumentCreateManyInput = {
    id?: string
    pswId: string
    docType: string
    fileKey: string
    status?: $Enums.DocStatus | null
    expiryDate?: Date | string | null
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PswDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PswDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQCreateInput = {
    id?: string
    question: string
    answer: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FAQUncheckedCreateInput = {
    id?: string
    question: string
    answer: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FAQUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQCreateManyInput = {
    id?: string
    question: string
    answer: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FAQUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryCreateInput = {
    id?: string
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutDailyEntryInput
    staff: UserCreateNestedOneWithoutDailyEntryInput
    visit?: VisitCreateNestedOneWithoutDailyEntryInput
  }

  export type DailyEntryUncheckedCreateInput = {
    id?: string
    clientId: string
    staffId: string
    visitId?: string | null
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutDailyEntryNestedInput
    staff?: UserUpdateOneRequiredWithoutDailyEntryNestedInput
    visit?: VisitUpdateOneWithoutDailyEntryNestedInput
  }

  export type DailyEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryCreateManyInput = {
    id?: string
    clientId: string
    staffId: string
    visitId?: string | null
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClientProfileNullableRelationFilter = {
    is?: ClientProfileWhereInput | null
    isNot?: ClientProfileWhereInput | null
  }

  export type PswProfileNullableRelationFilter = {
    is?: PswProfileWhereInput | null
    isNot?: PswProfileWhereInput | null
  }

  export type PswDocumentListRelationFilter = {
    every?: PswDocumentWhereInput
    some?: PswDocumentWhereInput
    none?: PswDocumentWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type TimesheetListRelationFilter = {
    every?: TimesheetWhereInput
    some?: TimesheetWhereInput
    none?: TimesheetWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type VisitCheckEventListRelationFilter = {
    every?: VisitCheckEventWhereInput
    some?: VisitCheckEventWhereInput
    none?: VisitCheckEventWhereInput
  }

  export type DailyEntryListRelationFilter = {
    every?: DailyEntryWhereInput
    some?: DailyEntryWhereInput
    none?: DailyEntryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PswDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimesheetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitCheckEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VisitListRelationFilter = {
    every?: VisitWhereInput
    some?: VisitWhereInput
    none?: VisitWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type MessageThreadListRelationFilter = {
    every?: MessageThreadWhereInput
    some?: MessageThreadWhereInput
    none?: MessageThreadWhereInput
  }

  export type VisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageThreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    dob?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    emergencyName?: SortOrder
    emergencyPhone?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type ClientProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    dob?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    emergencyName?: SortOrder
    emergencyPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    dob?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    emergencyName?: SortOrder
    emergencyPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type VisitNoteListRelationFilter = {
    every?: VisitNoteWhereInput
    some?: VisitNoteWhereInput
    none?: VisitNoteWhereInput
  }

  export type VisitChecklistListRelationFilter = {
    every?: VisitChecklistWhereInput
    some?: VisitChecklistWhereInput
    none?: VisitChecklistWhereInput
  }

  export type VisitNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PswProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    bio?: SortOrder
    languages?: SortOrder
    serviceAreas?: SortOrder
    availability?: SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PswProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    bio?: SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PswProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    bio?: SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumVisitStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVisitStatusNullableFilter<$PrismaModel> | $Enums.VisitStatus | null
  }

  export type ClientProfileRelationFilter = {
    is?: ClientProfileWhereInput
    isNot?: ClientProfileWhereInput
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type TimesheetItemListRelationFilter = {
    every?: TimesheetItemWhereInput
    some?: TimesheetItemWhereInput
    none?: TimesheetItemWhereInput
  }

  export type TimesheetItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    requestedStartAt?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrder
    assignedPswId?: SortOrder
    serviceAddressLine1?: SortOrder
    serviceAddressLine2?: SortOrder
    serviceCity?: SortOrder
    serviceProvince?: SortOrder
    servicePostalCode?: SortOrder
    serviceLat?: SortOrder
    serviceLng?: SortOrder
    clientNotes?: SortOrder
    coordinatorNotes?: SortOrder
    cancellationReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
    serviceLat?: SortOrder
    serviceLng?: SortOrder
  }

  export type VisitMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    requestedStartAt?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrder
    assignedPswId?: SortOrder
    serviceAddressLine1?: SortOrder
    serviceAddressLine2?: SortOrder
    serviceCity?: SortOrder
    serviceProvince?: SortOrder
    servicePostalCode?: SortOrder
    serviceLat?: SortOrder
    serviceLng?: SortOrder
    clientNotes?: SortOrder
    coordinatorNotes?: SortOrder
    cancellationReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    requestedStartAt?: SortOrder
    durationMinutes?: SortOrder
    status?: SortOrder
    assignedPswId?: SortOrder
    serviceAddressLine1?: SortOrder
    serviceAddressLine2?: SortOrder
    serviceCity?: SortOrder
    serviceProvince?: SortOrder
    servicePostalCode?: SortOrder
    serviceLat?: SortOrder
    serviceLng?: SortOrder
    clientNotes?: SortOrder
    coordinatorNotes?: SortOrder
    cancellationReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
    serviceLat?: SortOrder
    serviceLng?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumVisitStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVisitStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    baseRateHourly?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    baseRateHourly?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    baseRateHourly?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    baseRateHourly?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    baseRateHourly?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type EnumEventResultFilter<$PrismaModel = never> = {
    equals?: $Enums.EventResult | EnumEventResultFieldRefInput<$PrismaModel>
    in?: $Enums.EventResult[] | ListEnumEventResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventResult[] | ListEnumEventResultFieldRefInput<$PrismaModel>
    not?: NestedEnumEventResultFilter<$PrismaModel> | $Enums.EventResult
  }

  export type VisitRelationFilter = {
    is?: VisitWhereInput
    isNot?: VisitWhereInput
  }

  export type PswProfileRelationFilter = {
    is?: PswProfileWhereInput
    isNot?: PswProfileWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type VisitCheckEventCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    eventType?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    accuracyM?: SortOrder
    computedDistanceM?: SortOrder
    deviceTimeIso?: SortOrder
    serverTime?: SortOrder
    result?: SortOrder
    rejectReason?: SortOrder
    isOverride?: SortOrder
    overrideByUserId?: SortOrder
    overrideReason?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitCheckEventAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    accuracyM?: SortOrder
    computedDistanceM?: SortOrder
  }

  export type VisitCheckEventMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    eventType?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    accuracyM?: SortOrder
    computedDistanceM?: SortOrder
    deviceTimeIso?: SortOrder
    serverTime?: SortOrder
    result?: SortOrder
    rejectReason?: SortOrder
    isOverride?: SortOrder
    overrideByUserId?: SortOrder
    overrideReason?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitCheckEventMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    eventType?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    accuracyM?: SortOrder
    computedDistanceM?: SortOrder
    deviceTimeIso?: SortOrder
    serverTime?: SortOrder
    result?: SortOrder
    rejectReason?: SortOrder
    isOverride?: SortOrder
    overrideByUserId?: SortOrder
    overrideReason?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitCheckEventSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    accuracyM?: SortOrder
    computedDistanceM?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type EnumEventResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventResult | EnumEventResultFieldRefInput<$PrismaModel>
    in?: $Enums.EventResult[] | ListEnumEventResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventResult[] | ListEnumEventResultFieldRefInput<$PrismaModel>
    not?: NestedEnumEventResultWithAggregatesFilter<$PrismaModel> | $Enums.EventResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventResultFilter<$PrismaModel>
    _max?: NestedEnumEventResultFilter<$PrismaModel>
  }

  export type VisitNoteCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    noteText?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    noteText?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitNoteMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    noteText?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VisitChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    checklistJson?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    pswId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type EnumIncidentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIncidentStatusNullableFilter<$PrismaModel> | $Enums.IncidentStatus | null
  }

  export type VisitNullableRelationFilter = {
    is?: VisitWhereInput | null
    isNot?: VisitWhereInput | null
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    reporterUserId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolutionNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    reporterUserId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolutionNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    visitId?: SortOrder
    reporterUserId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolutionNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type EnumIncidentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIncidentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTimesheetStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TimesheetStatus | EnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TimesheetStatus[] | ListEnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TimesheetStatus[] | ListEnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTimesheetStatusNullableFilter<$PrismaModel> | $Enums.TimesheetStatus | null
  }

  export type TimesheetCountOrderByAggregateInput = {
    id?: SortOrder
    pswId?: SortOrder
    weekId?: SortOrder
    totalMinutes?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimesheetAvgOrderByAggregateInput = {
    totalMinutes?: SortOrder
  }

  export type TimesheetMaxOrderByAggregateInput = {
    id?: SortOrder
    pswId?: SortOrder
    weekId?: SortOrder
    totalMinutes?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimesheetMinOrderByAggregateInput = {
    id?: SortOrder
    pswId?: SortOrder
    weekId?: SortOrder
    totalMinutes?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimesheetSumOrderByAggregateInput = {
    totalMinutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumTimesheetStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimesheetStatus | EnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TimesheetStatus[] | ListEnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TimesheetStatus[] | ListEnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTimesheetStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TimesheetStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTimesheetStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTimesheetStatusNullableFilter<$PrismaModel>
  }

  export type TimesheetRelationFilter = {
    is?: TimesheetWhereInput
    isNot?: TimesheetWhereInput
  }

  export type TimesheetItemCountOrderByAggregateInput = {
    id?: SortOrder
    timesheetId?: SortOrder
    visitId?: SortOrder
    minutes?: SortOrder
    createdAt?: SortOrder
  }

  export type TimesheetItemAvgOrderByAggregateInput = {
    minutes?: SortOrder
  }

  export type TimesheetItemMaxOrderByAggregateInput = {
    id?: SortOrder
    timesheetId?: SortOrder
    visitId?: SortOrder
    minutes?: SortOrder
    createdAt?: SortOrder
  }

  export type TimesheetItemMinOrderByAggregateInput = {
    id?: SortOrder
    timesheetId?: SortOrder
    visitId?: SortOrder
    minutes?: SortOrder
    createdAt?: SortOrder
  }

  export type TimesheetItemSumOrderByAggregateInput = {
    minutes?: SortOrder
  }

  export type EnumInvoiceStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInvoiceStatusNullableFilter<$PrismaModel> | $Enums.InvoiceStatus | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    stripeInvoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    stripeInvoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    stripeInvoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type EnumInvoiceStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInvoiceStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusNullableFilter<$PrismaModel>
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    stripePaymentIntentId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    stripePaymentIntentId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    stripePaymentIntentId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type MessageThreadCountOrderByAggregateInput = {
    id?: SortOrder
    threadType?: SortOrder
    clientId?: SortOrder
    pswId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    threadType?: SortOrder
    clientId?: SortOrder
    pswId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageThreadMinOrderByAggregateInput = {
    id?: SortOrder
    threadType?: SortOrder
    clientId?: SortOrder
    pswId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageThreadRelationFilter = {
    is?: MessageThreadWhereInput
    isNot?: MessageThreadWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderUserId?: SortOrder
    bodyText?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderUserId?: SortOrder
    bodyText?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderUserId?: SortOrder
    bodyText?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    metadataJson?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    contentHtml?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    authorUserId?: SortOrder
    featureImageDocId?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    canonicalUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    contentHtml?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    authorUserId?: SortOrder
    featureImageDocId?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    canonicalUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    contentHtml?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    authorUserId?: SortOrder
    featureImageDocId?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    canonicalUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDocStatusNullableFilter<$PrismaModel> | $Enums.DocStatus | null
  }

  export type PswDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    pswId?: SortOrder
    docType?: SortOrder
    fileKey?: SortOrder
    status?: SortOrder
    expiryDate?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PswDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    pswId?: SortOrder
    docType?: SortOrder
    fileKey?: SortOrder
    status?: SortOrder
    expiryDate?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PswDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    pswId?: SortOrder
    docType?: SortOrder
    fileKey?: SortOrder
    status?: SortOrder
    expiryDate?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDocStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.DocStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDocStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumDocStatusNullableFilter<$PrismaModel>
  }

  export type FAQCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDailyEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DailyEntryStatus | EnumDailyEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DailyEntryStatus[] | ListEnumDailyEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DailyEntryStatus[] | ListEnumDailyEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDailyEntryStatusFilter<$PrismaModel> | $Enums.DailyEntryStatus
  }

  export type DailyEntryCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffId?: SortOrder
    visitId?: SortOrder
    adlData?: SortOrder
    medication?: SortOrder
    mood?: SortOrder
    vitals?: SortOrder
    notes?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyEntryAvgOrderByAggregateInput = {
    mood?: SortOrder
  }

  export type DailyEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffId?: SortOrder
    visitId?: SortOrder
    mood?: SortOrder
    notes?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyEntryMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffId?: SortOrder
    visitId?: SortOrder
    mood?: SortOrder
    notes?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyEntrySumOrderByAggregateInput = {
    mood?: SortOrder
  }

  export type EnumDailyEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DailyEntryStatus | EnumDailyEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DailyEntryStatus[] | ListEnumDailyEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DailyEntryStatus[] | ListEnumDailyEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDailyEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DailyEntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDailyEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumDailyEntryStatusFilter<$PrismaModel>
  }

  export type ClientProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type PswProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<PswProfileCreateWithoutUserInput, PswProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutUserInput
    connect?: PswProfileWhereUniqueInput
  }

  export type PswDocumentCreateNestedManyWithoutVerifierInput = {
    create?: XOR<PswDocumentCreateWithoutVerifierInput, PswDocumentUncheckedCreateWithoutVerifierInput> | PswDocumentCreateWithoutVerifierInput[] | PswDocumentUncheckedCreateWithoutVerifierInput[]
    connectOrCreate?: PswDocumentCreateOrConnectWithoutVerifierInput | PswDocumentCreateOrConnectWithoutVerifierInput[]
    createMany?: PswDocumentCreateManyVerifierInputEnvelope
    connect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutReporterInput = {
    create?: XOR<IncidentCreateWithoutReporterInput, IncidentUncheckedCreateWithoutReporterInput> | IncidentCreateWithoutReporterInput[] | IncidentUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutReporterInput | IncidentCreateOrConnectWithoutReporterInput[]
    createMany?: IncidentCreateManyReporterInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type TimesheetCreateNestedManyWithoutReviewerInput = {
    create?: XOR<TimesheetCreateWithoutReviewerInput, TimesheetUncheckedCreateWithoutReviewerInput> | TimesheetCreateWithoutReviewerInput[] | TimesheetUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: TimesheetCreateOrConnectWithoutReviewerInput | TimesheetCreateOrConnectWithoutReviewerInput[]
    createMany?: TimesheetCreateManyReviewerInputEnvelope
    connect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type VisitCheckEventCreateNestedManyWithoutOverriddenByInput = {
    create?: XOR<VisitCheckEventCreateWithoutOverriddenByInput, VisitCheckEventUncheckedCreateWithoutOverriddenByInput> | VisitCheckEventCreateWithoutOverriddenByInput[] | VisitCheckEventUncheckedCreateWithoutOverriddenByInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutOverriddenByInput | VisitCheckEventCreateOrConnectWithoutOverriddenByInput[]
    createMany?: VisitCheckEventCreateManyOverriddenByInputEnvelope
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
  }

  export type DailyEntryCreateNestedManyWithoutStaffInput = {
    create?: XOR<DailyEntryCreateWithoutStaffInput, DailyEntryUncheckedCreateWithoutStaffInput> | DailyEntryCreateWithoutStaffInput[] | DailyEntryUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutStaffInput | DailyEntryCreateOrConnectWithoutStaffInput[]
    createMany?: DailyEntryCreateManyStaffInputEnvelope
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
  }

  export type ClientProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type PswProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PswProfileCreateWithoutUserInput, PswProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutUserInput
    connect?: PswProfileWhereUniqueInput
  }

  export type PswDocumentUncheckedCreateNestedManyWithoutVerifierInput = {
    create?: XOR<PswDocumentCreateWithoutVerifierInput, PswDocumentUncheckedCreateWithoutVerifierInput> | PswDocumentCreateWithoutVerifierInput[] | PswDocumentUncheckedCreateWithoutVerifierInput[]
    connectOrCreate?: PswDocumentCreateOrConnectWithoutVerifierInput | PswDocumentCreateOrConnectWithoutVerifierInput[]
    createMany?: PswDocumentCreateManyVerifierInputEnvelope
    connect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<IncidentCreateWithoutReporterInput, IncidentUncheckedCreateWithoutReporterInput> | IncidentCreateWithoutReporterInput[] | IncidentUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutReporterInput | IncidentCreateOrConnectWithoutReporterInput[]
    createMany?: IncidentCreateManyReporterInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type TimesheetUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<TimesheetCreateWithoutReviewerInput, TimesheetUncheckedCreateWithoutReviewerInput> | TimesheetCreateWithoutReviewerInput[] | TimesheetUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: TimesheetCreateOrConnectWithoutReviewerInput | TimesheetCreateOrConnectWithoutReviewerInput[]
    createMany?: TimesheetCreateManyReviewerInputEnvelope
    connect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput = {
    create?: XOR<VisitCheckEventCreateWithoutOverriddenByInput, VisitCheckEventUncheckedCreateWithoutOverriddenByInput> | VisitCheckEventCreateWithoutOverriddenByInput[] | VisitCheckEventUncheckedCreateWithoutOverriddenByInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutOverriddenByInput | VisitCheckEventCreateOrConnectWithoutOverriddenByInput[]
    createMany?: VisitCheckEventCreateManyOverriddenByInputEnvelope
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
  }

  export type DailyEntryUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<DailyEntryCreateWithoutStaffInput, DailyEntryUncheckedCreateWithoutStaffInput> | DailyEntryCreateWithoutStaffInput[] | DailyEntryUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutStaffInput | DailyEntryCreateOrConnectWithoutStaffInput[]
    createMany?: DailyEntryCreateManyStaffInputEnvelope
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClientProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    upsert?: ClientProfileUpsertWithoutUserInput
    disconnect?: ClientProfileWhereInput | boolean
    delete?: ClientProfileWhereInput | boolean
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutUserInput, ClientProfileUpdateWithoutUserInput>, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type PswProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<PswProfileCreateWithoutUserInput, PswProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutUserInput
    upsert?: PswProfileUpsertWithoutUserInput
    disconnect?: PswProfileWhereInput | boolean
    delete?: PswProfileWhereInput | boolean
    connect?: PswProfileWhereUniqueInput
    update?: XOR<XOR<PswProfileUpdateToOneWithWhereWithoutUserInput, PswProfileUpdateWithoutUserInput>, PswProfileUncheckedUpdateWithoutUserInput>
  }

  export type PswDocumentUpdateManyWithoutVerifierNestedInput = {
    create?: XOR<PswDocumentCreateWithoutVerifierInput, PswDocumentUncheckedCreateWithoutVerifierInput> | PswDocumentCreateWithoutVerifierInput[] | PswDocumentUncheckedCreateWithoutVerifierInput[]
    connectOrCreate?: PswDocumentCreateOrConnectWithoutVerifierInput | PswDocumentCreateOrConnectWithoutVerifierInput[]
    upsert?: PswDocumentUpsertWithWhereUniqueWithoutVerifierInput | PswDocumentUpsertWithWhereUniqueWithoutVerifierInput[]
    createMany?: PswDocumentCreateManyVerifierInputEnvelope
    set?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    disconnect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    delete?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    connect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    update?: PswDocumentUpdateWithWhereUniqueWithoutVerifierInput | PswDocumentUpdateWithWhereUniqueWithoutVerifierInput[]
    updateMany?: PswDocumentUpdateManyWithWhereWithoutVerifierInput | PswDocumentUpdateManyWithWhereWithoutVerifierInput[]
    deleteMany?: PswDocumentScalarWhereInput | PswDocumentScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutReporterNestedInput = {
    create?: XOR<IncidentCreateWithoutReporterInput, IncidentUncheckedCreateWithoutReporterInput> | IncidentCreateWithoutReporterInput[] | IncidentUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutReporterInput | IncidentCreateOrConnectWithoutReporterInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutReporterInput | IncidentUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: IncidentCreateManyReporterInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutReporterInput | IncidentUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutReporterInput | IncidentUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type TimesheetUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<TimesheetCreateWithoutReviewerInput, TimesheetUncheckedCreateWithoutReviewerInput> | TimesheetCreateWithoutReviewerInput[] | TimesheetUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: TimesheetCreateOrConnectWithoutReviewerInput | TimesheetCreateOrConnectWithoutReviewerInput[]
    upsert?: TimesheetUpsertWithWhereUniqueWithoutReviewerInput | TimesheetUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: TimesheetCreateManyReviewerInputEnvelope
    set?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    disconnect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    delete?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    connect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    update?: TimesheetUpdateWithWhereUniqueWithoutReviewerInput | TimesheetUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: TimesheetUpdateManyWithWhereWithoutReviewerInput | TimesheetUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: TimesheetScalarWhereInput | TimesheetScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type VisitCheckEventUpdateManyWithoutOverriddenByNestedInput = {
    create?: XOR<VisitCheckEventCreateWithoutOverriddenByInput, VisitCheckEventUncheckedCreateWithoutOverriddenByInput> | VisitCheckEventCreateWithoutOverriddenByInput[] | VisitCheckEventUncheckedCreateWithoutOverriddenByInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutOverriddenByInput | VisitCheckEventCreateOrConnectWithoutOverriddenByInput[]
    upsert?: VisitCheckEventUpsertWithWhereUniqueWithoutOverriddenByInput | VisitCheckEventUpsertWithWhereUniqueWithoutOverriddenByInput[]
    createMany?: VisitCheckEventCreateManyOverriddenByInputEnvelope
    set?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    disconnect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    delete?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    update?: VisitCheckEventUpdateWithWhereUniqueWithoutOverriddenByInput | VisitCheckEventUpdateWithWhereUniqueWithoutOverriddenByInput[]
    updateMany?: VisitCheckEventUpdateManyWithWhereWithoutOverriddenByInput | VisitCheckEventUpdateManyWithWhereWithoutOverriddenByInput[]
    deleteMany?: VisitCheckEventScalarWhereInput | VisitCheckEventScalarWhereInput[]
  }

  export type DailyEntryUpdateManyWithoutStaffNestedInput = {
    create?: XOR<DailyEntryCreateWithoutStaffInput, DailyEntryUncheckedCreateWithoutStaffInput> | DailyEntryCreateWithoutStaffInput[] | DailyEntryUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutStaffInput | DailyEntryCreateOrConnectWithoutStaffInput[]
    upsert?: DailyEntryUpsertWithWhereUniqueWithoutStaffInput | DailyEntryUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: DailyEntryCreateManyStaffInputEnvelope
    set?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    disconnect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    delete?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    update?: DailyEntryUpdateWithWhereUniqueWithoutStaffInput | DailyEntryUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: DailyEntryUpdateManyWithWhereWithoutStaffInput | DailyEntryUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
  }

  export type ClientProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    upsert?: ClientProfileUpsertWithoutUserInput
    disconnect?: ClientProfileWhereInput | boolean
    delete?: ClientProfileWhereInput | boolean
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutUserInput, ClientProfileUpdateWithoutUserInput>, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type PswProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PswProfileCreateWithoutUserInput, PswProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutUserInput
    upsert?: PswProfileUpsertWithoutUserInput
    disconnect?: PswProfileWhereInput | boolean
    delete?: PswProfileWhereInput | boolean
    connect?: PswProfileWhereUniqueInput
    update?: XOR<XOR<PswProfileUpdateToOneWithWhereWithoutUserInput, PswProfileUpdateWithoutUserInput>, PswProfileUncheckedUpdateWithoutUserInput>
  }

  export type PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput = {
    create?: XOR<PswDocumentCreateWithoutVerifierInput, PswDocumentUncheckedCreateWithoutVerifierInput> | PswDocumentCreateWithoutVerifierInput[] | PswDocumentUncheckedCreateWithoutVerifierInput[]
    connectOrCreate?: PswDocumentCreateOrConnectWithoutVerifierInput | PswDocumentCreateOrConnectWithoutVerifierInput[]
    upsert?: PswDocumentUpsertWithWhereUniqueWithoutVerifierInput | PswDocumentUpsertWithWhereUniqueWithoutVerifierInput[]
    createMany?: PswDocumentCreateManyVerifierInputEnvelope
    set?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    disconnect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    delete?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    connect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    update?: PswDocumentUpdateWithWhereUniqueWithoutVerifierInput | PswDocumentUpdateWithWhereUniqueWithoutVerifierInput[]
    updateMany?: PswDocumentUpdateManyWithWhereWithoutVerifierInput | PswDocumentUpdateManyWithWhereWithoutVerifierInput[]
    deleteMany?: PswDocumentScalarWhereInput | PswDocumentScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<IncidentCreateWithoutReporterInput, IncidentUncheckedCreateWithoutReporterInput> | IncidentCreateWithoutReporterInput[] | IncidentUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutReporterInput | IncidentCreateOrConnectWithoutReporterInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutReporterInput | IncidentUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: IncidentCreateManyReporterInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutReporterInput | IncidentUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutReporterInput | IncidentUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type TimesheetUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<TimesheetCreateWithoutReviewerInput, TimesheetUncheckedCreateWithoutReviewerInput> | TimesheetCreateWithoutReviewerInput[] | TimesheetUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: TimesheetCreateOrConnectWithoutReviewerInput | TimesheetCreateOrConnectWithoutReviewerInput[]
    upsert?: TimesheetUpsertWithWhereUniqueWithoutReviewerInput | TimesheetUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: TimesheetCreateManyReviewerInputEnvelope
    set?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    disconnect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    delete?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    connect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    update?: TimesheetUpdateWithWhereUniqueWithoutReviewerInput | TimesheetUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: TimesheetUpdateManyWithWhereWithoutReviewerInput | TimesheetUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: TimesheetScalarWhereInput | TimesheetScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput = {
    create?: XOR<VisitCheckEventCreateWithoutOverriddenByInput, VisitCheckEventUncheckedCreateWithoutOverriddenByInput> | VisitCheckEventCreateWithoutOverriddenByInput[] | VisitCheckEventUncheckedCreateWithoutOverriddenByInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutOverriddenByInput | VisitCheckEventCreateOrConnectWithoutOverriddenByInput[]
    upsert?: VisitCheckEventUpsertWithWhereUniqueWithoutOverriddenByInput | VisitCheckEventUpsertWithWhereUniqueWithoutOverriddenByInput[]
    createMany?: VisitCheckEventCreateManyOverriddenByInputEnvelope
    set?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    disconnect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    delete?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    update?: VisitCheckEventUpdateWithWhereUniqueWithoutOverriddenByInput | VisitCheckEventUpdateWithWhereUniqueWithoutOverriddenByInput[]
    updateMany?: VisitCheckEventUpdateManyWithWhereWithoutOverriddenByInput | VisitCheckEventUpdateManyWithWhereWithoutOverriddenByInput[]
    deleteMany?: VisitCheckEventScalarWhereInput | VisitCheckEventScalarWhereInput[]
  }

  export type DailyEntryUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<DailyEntryCreateWithoutStaffInput, DailyEntryUncheckedCreateWithoutStaffInput> | DailyEntryCreateWithoutStaffInput[] | DailyEntryUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutStaffInput | DailyEntryCreateOrConnectWithoutStaffInput[]
    upsert?: DailyEntryUpsertWithWhereUniqueWithoutStaffInput | DailyEntryUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: DailyEntryCreateManyStaffInputEnvelope
    set?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    disconnect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    delete?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    update?: DailyEntryUpdateWithWhereUniqueWithoutStaffInput | DailyEntryUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: DailyEntryUpdateManyWithWhereWithoutStaffInput | DailyEntryUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientProfileInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    connect?: UserWhereUniqueInput
  }

  export type VisitCreateNestedManyWithoutClientInput = {
    create?: XOR<VisitCreateWithoutClientInput, VisitUncheckedCreateWithoutClientInput> | VisitCreateWithoutClientInput[] | VisitUncheckedCreateWithoutClientInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutClientInput | VisitCreateOrConnectWithoutClientInput[]
    createMany?: VisitCreateManyClientInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MessageThreadCreateNestedManyWithoutClientInput = {
    create?: XOR<MessageThreadCreateWithoutClientInput, MessageThreadUncheckedCreateWithoutClientInput> | MessageThreadCreateWithoutClientInput[] | MessageThreadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageThreadCreateOrConnectWithoutClientInput | MessageThreadCreateOrConnectWithoutClientInput[]
    createMany?: MessageThreadCreateManyClientInputEnvelope
    connect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
  }

  export type DailyEntryCreateNestedManyWithoutClientInput = {
    create?: XOR<DailyEntryCreateWithoutClientInput, DailyEntryUncheckedCreateWithoutClientInput> | DailyEntryCreateWithoutClientInput[] | DailyEntryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutClientInput | DailyEntryCreateOrConnectWithoutClientInput[]
    createMany?: DailyEntryCreateManyClientInputEnvelope
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<VisitCreateWithoutClientInput, VisitUncheckedCreateWithoutClientInput> | VisitCreateWithoutClientInput[] | VisitUncheckedCreateWithoutClientInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutClientInput | VisitCreateOrConnectWithoutClientInput[]
    createMany?: VisitCreateManyClientInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MessageThreadUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MessageThreadCreateWithoutClientInput, MessageThreadUncheckedCreateWithoutClientInput> | MessageThreadCreateWithoutClientInput[] | MessageThreadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageThreadCreateOrConnectWithoutClientInput | MessageThreadCreateOrConnectWithoutClientInput[]
    createMany?: MessageThreadCreateManyClientInputEnvelope
    connect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
  }

  export type DailyEntryUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DailyEntryCreateWithoutClientInput, DailyEntryUncheckedCreateWithoutClientInput> | DailyEntryCreateWithoutClientInput[] | DailyEntryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutClientInput | DailyEntryCreateOrConnectWithoutClientInput[]
    createMany?: DailyEntryCreateManyClientInputEnvelope
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutClientProfileNestedInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    upsert?: UserUpsertWithoutClientProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientProfileInput, UserUpdateWithoutClientProfileInput>, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type VisitUpdateManyWithoutClientNestedInput = {
    create?: XOR<VisitCreateWithoutClientInput, VisitUncheckedCreateWithoutClientInput> | VisitCreateWithoutClientInput[] | VisitUncheckedCreateWithoutClientInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutClientInput | VisitCreateOrConnectWithoutClientInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutClientInput | VisitUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: VisitCreateManyClientInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutClientInput | VisitUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutClientInput | VisitUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MessageThreadUpdateManyWithoutClientNestedInput = {
    create?: XOR<MessageThreadCreateWithoutClientInput, MessageThreadUncheckedCreateWithoutClientInput> | MessageThreadCreateWithoutClientInput[] | MessageThreadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageThreadCreateOrConnectWithoutClientInput | MessageThreadCreateOrConnectWithoutClientInput[]
    upsert?: MessageThreadUpsertWithWhereUniqueWithoutClientInput | MessageThreadUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MessageThreadCreateManyClientInputEnvelope
    set?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    disconnect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    delete?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    connect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    update?: MessageThreadUpdateWithWhereUniqueWithoutClientInput | MessageThreadUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MessageThreadUpdateManyWithWhereWithoutClientInput | MessageThreadUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MessageThreadScalarWhereInput | MessageThreadScalarWhereInput[]
  }

  export type DailyEntryUpdateManyWithoutClientNestedInput = {
    create?: XOR<DailyEntryCreateWithoutClientInput, DailyEntryUncheckedCreateWithoutClientInput> | DailyEntryCreateWithoutClientInput[] | DailyEntryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutClientInput | DailyEntryCreateOrConnectWithoutClientInput[]
    upsert?: DailyEntryUpsertWithWhereUniqueWithoutClientInput | DailyEntryUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DailyEntryCreateManyClientInputEnvelope
    set?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    disconnect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    delete?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    update?: DailyEntryUpdateWithWhereUniqueWithoutClientInput | DailyEntryUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DailyEntryUpdateManyWithWhereWithoutClientInput | DailyEntryUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<VisitCreateWithoutClientInput, VisitUncheckedCreateWithoutClientInput> | VisitCreateWithoutClientInput[] | VisitUncheckedCreateWithoutClientInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutClientInput | VisitCreateOrConnectWithoutClientInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutClientInput | VisitUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: VisitCreateManyClientInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutClientInput | VisitUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutClientInput | VisitUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MessageThreadUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MessageThreadCreateWithoutClientInput, MessageThreadUncheckedCreateWithoutClientInput> | MessageThreadCreateWithoutClientInput[] | MessageThreadUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageThreadCreateOrConnectWithoutClientInput | MessageThreadCreateOrConnectWithoutClientInput[]
    upsert?: MessageThreadUpsertWithWhereUniqueWithoutClientInput | MessageThreadUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MessageThreadCreateManyClientInputEnvelope
    set?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    disconnect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    delete?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    connect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    update?: MessageThreadUpdateWithWhereUniqueWithoutClientInput | MessageThreadUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MessageThreadUpdateManyWithWhereWithoutClientInput | MessageThreadUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MessageThreadScalarWhereInput | MessageThreadScalarWhereInput[]
  }

  export type DailyEntryUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DailyEntryCreateWithoutClientInput, DailyEntryUncheckedCreateWithoutClientInput> | DailyEntryCreateWithoutClientInput[] | DailyEntryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutClientInput | DailyEntryCreateOrConnectWithoutClientInput[]
    upsert?: DailyEntryUpsertWithWhereUniqueWithoutClientInput | DailyEntryUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DailyEntryCreateManyClientInputEnvelope
    set?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    disconnect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    delete?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    update?: DailyEntryUpdateWithWhereUniqueWithoutClientInput | DailyEntryUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DailyEntryUpdateManyWithWhereWithoutClientInput | DailyEntryUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
  }

  export type PswProfileCreatelanguagesInput = {
    set: string[]
  }

  export type PswProfileCreateserviceAreasInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutPswProfileInput = {
    create?: XOR<UserCreateWithoutPswProfileInput, UserUncheckedCreateWithoutPswProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPswProfileInput
    connect?: UserWhereUniqueInput
  }

  export type PswDocumentCreateNestedManyWithoutPswInput = {
    create?: XOR<PswDocumentCreateWithoutPswInput, PswDocumentUncheckedCreateWithoutPswInput> | PswDocumentCreateWithoutPswInput[] | PswDocumentUncheckedCreateWithoutPswInput[]
    connectOrCreate?: PswDocumentCreateOrConnectWithoutPswInput | PswDocumentCreateOrConnectWithoutPswInput[]
    createMany?: PswDocumentCreateManyPswInputEnvelope
    connect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
  }

  export type VisitCreateNestedManyWithoutPswInput = {
    create?: XOR<VisitCreateWithoutPswInput, VisitUncheckedCreateWithoutPswInput> | VisitCreateWithoutPswInput[] | VisitUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutPswInput | VisitCreateOrConnectWithoutPswInput[]
    createMany?: VisitCreateManyPswInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitCheckEventCreateNestedManyWithoutPswProfileInput = {
    create?: XOR<VisitCheckEventCreateWithoutPswProfileInput, VisitCheckEventUncheckedCreateWithoutPswProfileInput> | VisitCheckEventCreateWithoutPswProfileInput[] | VisitCheckEventUncheckedCreateWithoutPswProfileInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutPswProfileInput | VisitCheckEventCreateOrConnectWithoutPswProfileInput[]
    createMany?: VisitCheckEventCreateManyPswProfileInputEnvelope
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
  }

  export type VisitNoteCreateNestedManyWithoutPswInput = {
    create?: XOR<VisitNoteCreateWithoutPswInput, VisitNoteUncheckedCreateWithoutPswInput> | VisitNoteCreateWithoutPswInput[] | VisitNoteUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitNoteCreateOrConnectWithoutPswInput | VisitNoteCreateOrConnectWithoutPswInput[]
    createMany?: VisitNoteCreateManyPswInputEnvelope
    connect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
  }

  export type VisitChecklistCreateNestedManyWithoutPswInput = {
    create?: XOR<VisitChecklistCreateWithoutPswInput, VisitChecklistUncheckedCreateWithoutPswInput> | VisitChecklistCreateWithoutPswInput[] | VisitChecklistUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitChecklistCreateOrConnectWithoutPswInput | VisitChecklistCreateOrConnectWithoutPswInput[]
    createMany?: VisitChecklistCreateManyPswInputEnvelope
    connect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
  }

  export type TimesheetCreateNestedManyWithoutPswInput = {
    create?: XOR<TimesheetCreateWithoutPswInput, TimesheetUncheckedCreateWithoutPswInput> | TimesheetCreateWithoutPswInput[] | TimesheetUncheckedCreateWithoutPswInput[]
    connectOrCreate?: TimesheetCreateOrConnectWithoutPswInput | TimesheetCreateOrConnectWithoutPswInput[]
    createMany?: TimesheetCreateManyPswInputEnvelope
    connect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
  }

  export type MessageThreadCreateNestedManyWithoutPswInput = {
    create?: XOR<MessageThreadCreateWithoutPswInput, MessageThreadUncheckedCreateWithoutPswInput> | MessageThreadCreateWithoutPswInput[] | MessageThreadUncheckedCreateWithoutPswInput[]
    connectOrCreate?: MessageThreadCreateOrConnectWithoutPswInput | MessageThreadCreateOrConnectWithoutPswInput[]
    createMany?: MessageThreadCreateManyPswInputEnvelope
    connect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
  }

  export type PswDocumentUncheckedCreateNestedManyWithoutPswInput = {
    create?: XOR<PswDocumentCreateWithoutPswInput, PswDocumentUncheckedCreateWithoutPswInput> | PswDocumentCreateWithoutPswInput[] | PswDocumentUncheckedCreateWithoutPswInput[]
    connectOrCreate?: PswDocumentCreateOrConnectWithoutPswInput | PswDocumentCreateOrConnectWithoutPswInput[]
    createMany?: PswDocumentCreateManyPswInputEnvelope
    connect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutPswInput = {
    create?: XOR<VisitCreateWithoutPswInput, VisitUncheckedCreateWithoutPswInput> | VisitCreateWithoutPswInput[] | VisitUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutPswInput | VisitCreateOrConnectWithoutPswInput[]
    createMany?: VisitCreateManyPswInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitCheckEventUncheckedCreateNestedManyWithoutPswProfileInput = {
    create?: XOR<VisitCheckEventCreateWithoutPswProfileInput, VisitCheckEventUncheckedCreateWithoutPswProfileInput> | VisitCheckEventCreateWithoutPswProfileInput[] | VisitCheckEventUncheckedCreateWithoutPswProfileInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutPswProfileInput | VisitCheckEventCreateOrConnectWithoutPswProfileInput[]
    createMany?: VisitCheckEventCreateManyPswProfileInputEnvelope
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
  }

  export type VisitNoteUncheckedCreateNestedManyWithoutPswInput = {
    create?: XOR<VisitNoteCreateWithoutPswInput, VisitNoteUncheckedCreateWithoutPswInput> | VisitNoteCreateWithoutPswInput[] | VisitNoteUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitNoteCreateOrConnectWithoutPswInput | VisitNoteCreateOrConnectWithoutPswInput[]
    createMany?: VisitNoteCreateManyPswInputEnvelope
    connect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
  }

  export type VisitChecklistUncheckedCreateNestedManyWithoutPswInput = {
    create?: XOR<VisitChecklistCreateWithoutPswInput, VisitChecklistUncheckedCreateWithoutPswInput> | VisitChecklistCreateWithoutPswInput[] | VisitChecklistUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitChecklistCreateOrConnectWithoutPswInput | VisitChecklistCreateOrConnectWithoutPswInput[]
    createMany?: VisitChecklistCreateManyPswInputEnvelope
    connect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
  }

  export type TimesheetUncheckedCreateNestedManyWithoutPswInput = {
    create?: XOR<TimesheetCreateWithoutPswInput, TimesheetUncheckedCreateWithoutPswInput> | TimesheetCreateWithoutPswInput[] | TimesheetUncheckedCreateWithoutPswInput[]
    connectOrCreate?: TimesheetCreateOrConnectWithoutPswInput | TimesheetCreateOrConnectWithoutPswInput[]
    createMany?: TimesheetCreateManyPswInputEnvelope
    connect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
  }

  export type MessageThreadUncheckedCreateNestedManyWithoutPswInput = {
    create?: XOR<MessageThreadCreateWithoutPswInput, MessageThreadUncheckedCreateWithoutPswInput> | MessageThreadCreateWithoutPswInput[] | MessageThreadUncheckedCreateWithoutPswInput[]
    connectOrCreate?: MessageThreadCreateOrConnectWithoutPswInput | MessageThreadCreateOrConnectWithoutPswInput[]
    createMany?: MessageThreadCreateManyPswInputEnvelope
    connect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
  }

  export type PswProfileUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PswProfileUpdateserviceAreasInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutPswProfileNestedInput = {
    create?: XOR<UserCreateWithoutPswProfileInput, UserUncheckedCreateWithoutPswProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPswProfileInput
    upsert?: UserUpsertWithoutPswProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPswProfileInput, UserUpdateWithoutPswProfileInput>, UserUncheckedUpdateWithoutPswProfileInput>
  }

  export type PswDocumentUpdateManyWithoutPswNestedInput = {
    create?: XOR<PswDocumentCreateWithoutPswInput, PswDocumentUncheckedCreateWithoutPswInput> | PswDocumentCreateWithoutPswInput[] | PswDocumentUncheckedCreateWithoutPswInput[]
    connectOrCreate?: PswDocumentCreateOrConnectWithoutPswInput | PswDocumentCreateOrConnectWithoutPswInput[]
    upsert?: PswDocumentUpsertWithWhereUniqueWithoutPswInput | PswDocumentUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: PswDocumentCreateManyPswInputEnvelope
    set?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    disconnect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    delete?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    connect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    update?: PswDocumentUpdateWithWhereUniqueWithoutPswInput | PswDocumentUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: PswDocumentUpdateManyWithWhereWithoutPswInput | PswDocumentUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: PswDocumentScalarWhereInput | PswDocumentScalarWhereInput[]
  }

  export type VisitUpdateManyWithoutPswNestedInput = {
    create?: XOR<VisitCreateWithoutPswInput, VisitUncheckedCreateWithoutPswInput> | VisitCreateWithoutPswInput[] | VisitUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutPswInput | VisitCreateOrConnectWithoutPswInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutPswInput | VisitUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: VisitCreateManyPswInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutPswInput | VisitUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutPswInput | VisitUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitCheckEventUpdateManyWithoutPswProfileNestedInput = {
    create?: XOR<VisitCheckEventCreateWithoutPswProfileInput, VisitCheckEventUncheckedCreateWithoutPswProfileInput> | VisitCheckEventCreateWithoutPswProfileInput[] | VisitCheckEventUncheckedCreateWithoutPswProfileInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutPswProfileInput | VisitCheckEventCreateOrConnectWithoutPswProfileInput[]
    upsert?: VisitCheckEventUpsertWithWhereUniqueWithoutPswProfileInput | VisitCheckEventUpsertWithWhereUniqueWithoutPswProfileInput[]
    createMany?: VisitCheckEventCreateManyPswProfileInputEnvelope
    set?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    disconnect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    delete?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    update?: VisitCheckEventUpdateWithWhereUniqueWithoutPswProfileInput | VisitCheckEventUpdateWithWhereUniqueWithoutPswProfileInput[]
    updateMany?: VisitCheckEventUpdateManyWithWhereWithoutPswProfileInput | VisitCheckEventUpdateManyWithWhereWithoutPswProfileInput[]
    deleteMany?: VisitCheckEventScalarWhereInput | VisitCheckEventScalarWhereInput[]
  }

  export type VisitNoteUpdateManyWithoutPswNestedInput = {
    create?: XOR<VisitNoteCreateWithoutPswInput, VisitNoteUncheckedCreateWithoutPswInput> | VisitNoteCreateWithoutPswInput[] | VisitNoteUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitNoteCreateOrConnectWithoutPswInput | VisitNoteCreateOrConnectWithoutPswInput[]
    upsert?: VisitNoteUpsertWithWhereUniqueWithoutPswInput | VisitNoteUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: VisitNoteCreateManyPswInputEnvelope
    set?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    disconnect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    delete?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    connect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    update?: VisitNoteUpdateWithWhereUniqueWithoutPswInput | VisitNoteUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: VisitNoteUpdateManyWithWhereWithoutPswInput | VisitNoteUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: VisitNoteScalarWhereInput | VisitNoteScalarWhereInput[]
  }

  export type VisitChecklistUpdateManyWithoutPswNestedInput = {
    create?: XOR<VisitChecklistCreateWithoutPswInput, VisitChecklistUncheckedCreateWithoutPswInput> | VisitChecklistCreateWithoutPswInput[] | VisitChecklistUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitChecklistCreateOrConnectWithoutPswInput | VisitChecklistCreateOrConnectWithoutPswInput[]
    upsert?: VisitChecklistUpsertWithWhereUniqueWithoutPswInput | VisitChecklistUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: VisitChecklistCreateManyPswInputEnvelope
    set?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    disconnect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    delete?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    connect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    update?: VisitChecklistUpdateWithWhereUniqueWithoutPswInput | VisitChecklistUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: VisitChecklistUpdateManyWithWhereWithoutPswInput | VisitChecklistUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: VisitChecklistScalarWhereInput | VisitChecklistScalarWhereInput[]
  }

  export type TimesheetUpdateManyWithoutPswNestedInput = {
    create?: XOR<TimesheetCreateWithoutPswInput, TimesheetUncheckedCreateWithoutPswInput> | TimesheetCreateWithoutPswInput[] | TimesheetUncheckedCreateWithoutPswInput[]
    connectOrCreate?: TimesheetCreateOrConnectWithoutPswInput | TimesheetCreateOrConnectWithoutPswInput[]
    upsert?: TimesheetUpsertWithWhereUniqueWithoutPswInput | TimesheetUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: TimesheetCreateManyPswInputEnvelope
    set?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    disconnect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    delete?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    connect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    update?: TimesheetUpdateWithWhereUniqueWithoutPswInput | TimesheetUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: TimesheetUpdateManyWithWhereWithoutPswInput | TimesheetUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: TimesheetScalarWhereInput | TimesheetScalarWhereInput[]
  }

  export type MessageThreadUpdateManyWithoutPswNestedInput = {
    create?: XOR<MessageThreadCreateWithoutPswInput, MessageThreadUncheckedCreateWithoutPswInput> | MessageThreadCreateWithoutPswInput[] | MessageThreadUncheckedCreateWithoutPswInput[]
    connectOrCreate?: MessageThreadCreateOrConnectWithoutPswInput | MessageThreadCreateOrConnectWithoutPswInput[]
    upsert?: MessageThreadUpsertWithWhereUniqueWithoutPswInput | MessageThreadUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: MessageThreadCreateManyPswInputEnvelope
    set?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    disconnect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    delete?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    connect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    update?: MessageThreadUpdateWithWhereUniqueWithoutPswInput | MessageThreadUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: MessageThreadUpdateManyWithWhereWithoutPswInput | MessageThreadUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: MessageThreadScalarWhereInput | MessageThreadScalarWhereInput[]
  }

  export type PswDocumentUncheckedUpdateManyWithoutPswNestedInput = {
    create?: XOR<PswDocumentCreateWithoutPswInput, PswDocumentUncheckedCreateWithoutPswInput> | PswDocumentCreateWithoutPswInput[] | PswDocumentUncheckedCreateWithoutPswInput[]
    connectOrCreate?: PswDocumentCreateOrConnectWithoutPswInput | PswDocumentCreateOrConnectWithoutPswInput[]
    upsert?: PswDocumentUpsertWithWhereUniqueWithoutPswInput | PswDocumentUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: PswDocumentCreateManyPswInputEnvelope
    set?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    disconnect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    delete?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    connect?: PswDocumentWhereUniqueInput | PswDocumentWhereUniqueInput[]
    update?: PswDocumentUpdateWithWhereUniqueWithoutPswInput | PswDocumentUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: PswDocumentUpdateManyWithWhereWithoutPswInput | PswDocumentUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: PswDocumentScalarWhereInput | PswDocumentScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutPswNestedInput = {
    create?: XOR<VisitCreateWithoutPswInput, VisitUncheckedCreateWithoutPswInput> | VisitCreateWithoutPswInput[] | VisitUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutPswInput | VisitCreateOrConnectWithoutPswInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutPswInput | VisitUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: VisitCreateManyPswInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutPswInput | VisitUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutPswInput | VisitUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitCheckEventUncheckedUpdateManyWithoutPswProfileNestedInput = {
    create?: XOR<VisitCheckEventCreateWithoutPswProfileInput, VisitCheckEventUncheckedCreateWithoutPswProfileInput> | VisitCheckEventCreateWithoutPswProfileInput[] | VisitCheckEventUncheckedCreateWithoutPswProfileInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutPswProfileInput | VisitCheckEventCreateOrConnectWithoutPswProfileInput[]
    upsert?: VisitCheckEventUpsertWithWhereUniqueWithoutPswProfileInput | VisitCheckEventUpsertWithWhereUniqueWithoutPswProfileInput[]
    createMany?: VisitCheckEventCreateManyPswProfileInputEnvelope
    set?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    disconnect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    delete?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    update?: VisitCheckEventUpdateWithWhereUniqueWithoutPswProfileInput | VisitCheckEventUpdateWithWhereUniqueWithoutPswProfileInput[]
    updateMany?: VisitCheckEventUpdateManyWithWhereWithoutPswProfileInput | VisitCheckEventUpdateManyWithWhereWithoutPswProfileInput[]
    deleteMany?: VisitCheckEventScalarWhereInput | VisitCheckEventScalarWhereInput[]
  }

  export type VisitNoteUncheckedUpdateManyWithoutPswNestedInput = {
    create?: XOR<VisitNoteCreateWithoutPswInput, VisitNoteUncheckedCreateWithoutPswInput> | VisitNoteCreateWithoutPswInput[] | VisitNoteUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitNoteCreateOrConnectWithoutPswInput | VisitNoteCreateOrConnectWithoutPswInput[]
    upsert?: VisitNoteUpsertWithWhereUniqueWithoutPswInput | VisitNoteUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: VisitNoteCreateManyPswInputEnvelope
    set?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    disconnect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    delete?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    connect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    update?: VisitNoteUpdateWithWhereUniqueWithoutPswInput | VisitNoteUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: VisitNoteUpdateManyWithWhereWithoutPswInput | VisitNoteUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: VisitNoteScalarWhereInput | VisitNoteScalarWhereInput[]
  }

  export type VisitChecklistUncheckedUpdateManyWithoutPswNestedInput = {
    create?: XOR<VisitChecklistCreateWithoutPswInput, VisitChecklistUncheckedCreateWithoutPswInput> | VisitChecklistCreateWithoutPswInput[] | VisitChecklistUncheckedCreateWithoutPswInput[]
    connectOrCreate?: VisitChecklistCreateOrConnectWithoutPswInput | VisitChecklistCreateOrConnectWithoutPswInput[]
    upsert?: VisitChecklistUpsertWithWhereUniqueWithoutPswInput | VisitChecklistUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: VisitChecklistCreateManyPswInputEnvelope
    set?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    disconnect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    delete?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    connect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    update?: VisitChecklistUpdateWithWhereUniqueWithoutPswInput | VisitChecklistUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: VisitChecklistUpdateManyWithWhereWithoutPswInput | VisitChecklistUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: VisitChecklistScalarWhereInput | VisitChecklistScalarWhereInput[]
  }

  export type TimesheetUncheckedUpdateManyWithoutPswNestedInput = {
    create?: XOR<TimesheetCreateWithoutPswInput, TimesheetUncheckedCreateWithoutPswInput> | TimesheetCreateWithoutPswInput[] | TimesheetUncheckedCreateWithoutPswInput[]
    connectOrCreate?: TimesheetCreateOrConnectWithoutPswInput | TimesheetCreateOrConnectWithoutPswInput[]
    upsert?: TimesheetUpsertWithWhereUniqueWithoutPswInput | TimesheetUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: TimesheetCreateManyPswInputEnvelope
    set?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    disconnect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    delete?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    connect?: TimesheetWhereUniqueInput | TimesheetWhereUniqueInput[]
    update?: TimesheetUpdateWithWhereUniqueWithoutPswInput | TimesheetUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: TimesheetUpdateManyWithWhereWithoutPswInput | TimesheetUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: TimesheetScalarWhereInput | TimesheetScalarWhereInput[]
  }

  export type MessageThreadUncheckedUpdateManyWithoutPswNestedInput = {
    create?: XOR<MessageThreadCreateWithoutPswInput, MessageThreadUncheckedCreateWithoutPswInput> | MessageThreadCreateWithoutPswInput[] | MessageThreadUncheckedCreateWithoutPswInput[]
    connectOrCreate?: MessageThreadCreateOrConnectWithoutPswInput | MessageThreadCreateOrConnectWithoutPswInput[]
    upsert?: MessageThreadUpsertWithWhereUniqueWithoutPswInput | MessageThreadUpsertWithWhereUniqueWithoutPswInput[]
    createMany?: MessageThreadCreateManyPswInputEnvelope
    set?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    disconnect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    delete?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    connect?: MessageThreadWhereUniqueInput | MessageThreadWhereUniqueInput[]
    update?: MessageThreadUpdateWithWhereUniqueWithoutPswInput | MessageThreadUpdateWithWhereUniqueWithoutPswInput[]
    updateMany?: MessageThreadUpdateManyWithWhereWithoutPswInput | MessageThreadUpdateManyWithWhereWithoutPswInput[]
    deleteMany?: MessageThreadScalarWhereInput | MessageThreadScalarWhereInput[]
  }

  export type ClientProfileCreateNestedOneWithoutVisitsInput = {
    create?: XOR<ClientProfileCreateWithoutVisitsInput, ClientProfileUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutVisitsInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutVisitsInput = {
    create?: XOR<ServiceCreateWithoutVisitsInput, ServiceUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutVisitsInput
    connect?: ServiceWhereUniqueInput
  }

  export type PswProfileCreateNestedOneWithoutAssignedVisitsInput = {
    create?: XOR<PswProfileCreateWithoutAssignedVisitsInput, PswProfileUncheckedCreateWithoutAssignedVisitsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutAssignedVisitsInput
    connect?: PswProfileWhereUniqueInput
  }

  export type VisitCheckEventCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitCheckEventCreateWithoutVisitInput, VisitCheckEventUncheckedCreateWithoutVisitInput> | VisitCheckEventCreateWithoutVisitInput[] | VisitCheckEventUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutVisitInput | VisitCheckEventCreateOrConnectWithoutVisitInput[]
    createMany?: VisitCheckEventCreateManyVisitInputEnvelope
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
  }

  export type VisitNoteCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitNoteCreateWithoutVisitInput, VisitNoteUncheckedCreateWithoutVisitInput> | VisitNoteCreateWithoutVisitInput[] | VisitNoteUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitNoteCreateOrConnectWithoutVisitInput | VisitNoteCreateOrConnectWithoutVisitInput[]
    createMany?: VisitNoteCreateManyVisitInputEnvelope
    connect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
  }

  export type VisitChecklistCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitChecklistCreateWithoutVisitInput, VisitChecklistUncheckedCreateWithoutVisitInput> | VisitChecklistCreateWithoutVisitInput[] | VisitChecklistUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitChecklistCreateOrConnectWithoutVisitInput | VisitChecklistCreateOrConnectWithoutVisitInput[]
    createMany?: VisitChecklistCreateManyVisitInputEnvelope
    connect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutVisitInput = {
    create?: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput> | IncidentCreateWithoutVisitInput[] | IncidentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVisitInput | IncidentCreateOrConnectWithoutVisitInput[]
    createMany?: IncidentCreateManyVisitInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type TimesheetItemCreateNestedManyWithoutVisitInput = {
    create?: XOR<TimesheetItemCreateWithoutVisitInput, TimesheetItemUncheckedCreateWithoutVisitInput> | TimesheetItemCreateWithoutVisitInput[] | TimesheetItemUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: TimesheetItemCreateOrConnectWithoutVisitInput | TimesheetItemCreateOrConnectWithoutVisitInput[]
    createMany?: TimesheetItemCreateManyVisitInputEnvelope
    connect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
  }

  export type DailyEntryCreateNestedManyWithoutVisitInput = {
    create?: XOR<DailyEntryCreateWithoutVisitInput, DailyEntryUncheckedCreateWithoutVisitInput> | DailyEntryCreateWithoutVisitInput[] | DailyEntryUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutVisitInput | DailyEntryCreateOrConnectWithoutVisitInput[]
    createMany?: DailyEntryCreateManyVisitInputEnvelope
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
  }

  export type VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitCheckEventCreateWithoutVisitInput, VisitCheckEventUncheckedCreateWithoutVisitInput> | VisitCheckEventCreateWithoutVisitInput[] | VisitCheckEventUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutVisitInput | VisitCheckEventCreateOrConnectWithoutVisitInput[]
    createMany?: VisitCheckEventCreateManyVisitInputEnvelope
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
  }

  export type VisitNoteUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitNoteCreateWithoutVisitInput, VisitNoteUncheckedCreateWithoutVisitInput> | VisitNoteCreateWithoutVisitInput[] | VisitNoteUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitNoteCreateOrConnectWithoutVisitInput | VisitNoteCreateOrConnectWithoutVisitInput[]
    createMany?: VisitNoteCreateManyVisitInputEnvelope
    connect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
  }

  export type VisitChecklistUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<VisitChecklistCreateWithoutVisitInput, VisitChecklistUncheckedCreateWithoutVisitInput> | VisitChecklistCreateWithoutVisitInput[] | VisitChecklistUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitChecklistCreateOrConnectWithoutVisitInput | VisitChecklistCreateOrConnectWithoutVisitInput[]
    createMany?: VisitChecklistCreateManyVisitInputEnvelope
    connect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput> | IncidentCreateWithoutVisitInput[] | IncidentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVisitInput | IncidentCreateOrConnectWithoutVisitInput[]
    createMany?: IncidentCreateManyVisitInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type TimesheetItemUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<TimesheetItemCreateWithoutVisitInput, TimesheetItemUncheckedCreateWithoutVisitInput> | TimesheetItemCreateWithoutVisitInput[] | TimesheetItemUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: TimesheetItemCreateOrConnectWithoutVisitInput | TimesheetItemCreateOrConnectWithoutVisitInput[]
    createMany?: TimesheetItemCreateManyVisitInputEnvelope
    connect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
  }

  export type DailyEntryUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<DailyEntryCreateWithoutVisitInput, DailyEntryUncheckedCreateWithoutVisitInput> | DailyEntryCreateWithoutVisitInput[] | DailyEntryUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutVisitInput | DailyEntryCreateOrConnectWithoutVisitInput[]
    createMany?: DailyEntryCreateManyVisitInputEnvelope
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumVisitStatusFieldUpdateOperationsInput = {
    set?: $Enums.VisitStatus | null
  }

  export type ClientProfileUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<ClientProfileCreateWithoutVisitsInput, ClientProfileUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutVisitsInput
    upsert?: ClientProfileUpsertWithoutVisitsInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutVisitsInput, ClientProfileUpdateWithoutVisitsInput>, ClientProfileUncheckedUpdateWithoutVisitsInput>
  }

  export type ServiceUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<ServiceCreateWithoutVisitsInput, ServiceUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutVisitsInput
    upsert?: ServiceUpsertWithoutVisitsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutVisitsInput, ServiceUpdateWithoutVisitsInput>, ServiceUncheckedUpdateWithoutVisitsInput>
  }

  export type PswProfileUpdateOneWithoutAssignedVisitsNestedInput = {
    create?: XOR<PswProfileCreateWithoutAssignedVisitsInput, PswProfileUncheckedCreateWithoutAssignedVisitsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutAssignedVisitsInput
    upsert?: PswProfileUpsertWithoutAssignedVisitsInput
    disconnect?: PswProfileWhereInput | boolean
    delete?: PswProfileWhereInput | boolean
    connect?: PswProfileWhereUniqueInput
    update?: XOR<XOR<PswProfileUpdateToOneWithWhereWithoutAssignedVisitsInput, PswProfileUpdateWithoutAssignedVisitsInput>, PswProfileUncheckedUpdateWithoutAssignedVisitsInput>
  }

  export type VisitCheckEventUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitCheckEventCreateWithoutVisitInput, VisitCheckEventUncheckedCreateWithoutVisitInput> | VisitCheckEventCreateWithoutVisitInput[] | VisitCheckEventUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutVisitInput | VisitCheckEventCreateOrConnectWithoutVisitInput[]
    upsert?: VisitCheckEventUpsertWithWhereUniqueWithoutVisitInput | VisitCheckEventUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitCheckEventCreateManyVisitInputEnvelope
    set?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    disconnect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    delete?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    update?: VisitCheckEventUpdateWithWhereUniqueWithoutVisitInput | VisitCheckEventUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitCheckEventUpdateManyWithWhereWithoutVisitInput | VisitCheckEventUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitCheckEventScalarWhereInput | VisitCheckEventScalarWhereInput[]
  }

  export type VisitNoteUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitNoteCreateWithoutVisitInput, VisitNoteUncheckedCreateWithoutVisitInput> | VisitNoteCreateWithoutVisitInput[] | VisitNoteUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitNoteCreateOrConnectWithoutVisitInput | VisitNoteCreateOrConnectWithoutVisitInput[]
    upsert?: VisitNoteUpsertWithWhereUniqueWithoutVisitInput | VisitNoteUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitNoteCreateManyVisitInputEnvelope
    set?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    disconnect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    delete?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    connect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    update?: VisitNoteUpdateWithWhereUniqueWithoutVisitInput | VisitNoteUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitNoteUpdateManyWithWhereWithoutVisitInput | VisitNoteUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitNoteScalarWhereInput | VisitNoteScalarWhereInput[]
  }

  export type VisitChecklistUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitChecklistCreateWithoutVisitInput, VisitChecklistUncheckedCreateWithoutVisitInput> | VisitChecklistCreateWithoutVisitInput[] | VisitChecklistUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitChecklistCreateOrConnectWithoutVisitInput | VisitChecklistCreateOrConnectWithoutVisitInput[]
    upsert?: VisitChecklistUpsertWithWhereUniqueWithoutVisitInput | VisitChecklistUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitChecklistCreateManyVisitInputEnvelope
    set?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    disconnect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    delete?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    connect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    update?: VisitChecklistUpdateWithWhereUniqueWithoutVisitInput | VisitChecklistUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitChecklistUpdateManyWithWhereWithoutVisitInput | VisitChecklistUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitChecklistScalarWhereInput | VisitChecklistScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutVisitNestedInput = {
    create?: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput> | IncidentCreateWithoutVisitInput[] | IncidentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVisitInput | IncidentCreateOrConnectWithoutVisitInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutVisitInput | IncidentUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: IncidentCreateManyVisitInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutVisitInput | IncidentUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutVisitInput | IncidentUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type TimesheetItemUpdateManyWithoutVisitNestedInput = {
    create?: XOR<TimesheetItemCreateWithoutVisitInput, TimesheetItemUncheckedCreateWithoutVisitInput> | TimesheetItemCreateWithoutVisitInput[] | TimesheetItemUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: TimesheetItemCreateOrConnectWithoutVisitInput | TimesheetItemCreateOrConnectWithoutVisitInput[]
    upsert?: TimesheetItemUpsertWithWhereUniqueWithoutVisitInput | TimesheetItemUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: TimesheetItemCreateManyVisitInputEnvelope
    set?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    disconnect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    delete?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    connect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    update?: TimesheetItemUpdateWithWhereUniqueWithoutVisitInput | TimesheetItemUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: TimesheetItemUpdateManyWithWhereWithoutVisitInput | TimesheetItemUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: TimesheetItemScalarWhereInput | TimesheetItemScalarWhereInput[]
  }

  export type DailyEntryUpdateManyWithoutVisitNestedInput = {
    create?: XOR<DailyEntryCreateWithoutVisitInput, DailyEntryUncheckedCreateWithoutVisitInput> | DailyEntryCreateWithoutVisitInput[] | DailyEntryUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutVisitInput | DailyEntryCreateOrConnectWithoutVisitInput[]
    upsert?: DailyEntryUpsertWithWhereUniqueWithoutVisitInput | DailyEntryUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: DailyEntryCreateManyVisitInputEnvelope
    set?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    disconnect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    delete?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    update?: DailyEntryUpdateWithWhereUniqueWithoutVisitInput | DailyEntryUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: DailyEntryUpdateManyWithWhereWithoutVisitInput | DailyEntryUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
  }

  export type VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitCheckEventCreateWithoutVisitInput, VisitCheckEventUncheckedCreateWithoutVisitInput> | VisitCheckEventCreateWithoutVisitInput[] | VisitCheckEventUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitCheckEventCreateOrConnectWithoutVisitInput | VisitCheckEventCreateOrConnectWithoutVisitInput[]
    upsert?: VisitCheckEventUpsertWithWhereUniqueWithoutVisitInput | VisitCheckEventUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitCheckEventCreateManyVisitInputEnvelope
    set?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    disconnect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    delete?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    connect?: VisitCheckEventWhereUniqueInput | VisitCheckEventWhereUniqueInput[]
    update?: VisitCheckEventUpdateWithWhereUniqueWithoutVisitInput | VisitCheckEventUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitCheckEventUpdateManyWithWhereWithoutVisitInput | VisitCheckEventUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitCheckEventScalarWhereInput | VisitCheckEventScalarWhereInput[]
  }

  export type VisitNoteUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitNoteCreateWithoutVisitInput, VisitNoteUncheckedCreateWithoutVisitInput> | VisitNoteCreateWithoutVisitInput[] | VisitNoteUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitNoteCreateOrConnectWithoutVisitInput | VisitNoteCreateOrConnectWithoutVisitInput[]
    upsert?: VisitNoteUpsertWithWhereUniqueWithoutVisitInput | VisitNoteUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitNoteCreateManyVisitInputEnvelope
    set?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    disconnect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    delete?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    connect?: VisitNoteWhereUniqueInput | VisitNoteWhereUniqueInput[]
    update?: VisitNoteUpdateWithWhereUniqueWithoutVisitInput | VisitNoteUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitNoteUpdateManyWithWhereWithoutVisitInput | VisitNoteUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitNoteScalarWhereInput | VisitNoteScalarWhereInput[]
  }

  export type VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<VisitChecklistCreateWithoutVisitInput, VisitChecklistUncheckedCreateWithoutVisitInput> | VisitChecklistCreateWithoutVisitInput[] | VisitChecklistUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: VisitChecklistCreateOrConnectWithoutVisitInput | VisitChecklistCreateOrConnectWithoutVisitInput[]
    upsert?: VisitChecklistUpsertWithWhereUniqueWithoutVisitInput | VisitChecklistUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: VisitChecklistCreateManyVisitInputEnvelope
    set?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    disconnect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    delete?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    connect?: VisitChecklistWhereUniqueInput | VisitChecklistWhereUniqueInput[]
    update?: VisitChecklistUpdateWithWhereUniqueWithoutVisitInput | VisitChecklistUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: VisitChecklistUpdateManyWithWhereWithoutVisitInput | VisitChecklistUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: VisitChecklistScalarWhereInput | VisitChecklistScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput> | IncidentCreateWithoutVisitInput[] | IncidentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutVisitInput | IncidentCreateOrConnectWithoutVisitInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutVisitInput | IncidentUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: IncidentCreateManyVisitInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutVisitInput | IncidentUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutVisitInput | IncidentUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<TimesheetItemCreateWithoutVisitInput, TimesheetItemUncheckedCreateWithoutVisitInput> | TimesheetItemCreateWithoutVisitInput[] | TimesheetItemUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: TimesheetItemCreateOrConnectWithoutVisitInput | TimesheetItemCreateOrConnectWithoutVisitInput[]
    upsert?: TimesheetItemUpsertWithWhereUniqueWithoutVisitInput | TimesheetItemUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: TimesheetItemCreateManyVisitInputEnvelope
    set?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    disconnect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    delete?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    connect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    update?: TimesheetItemUpdateWithWhereUniqueWithoutVisitInput | TimesheetItemUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: TimesheetItemUpdateManyWithWhereWithoutVisitInput | TimesheetItemUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: TimesheetItemScalarWhereInput | TimesheetItemScalarWhereInput[]
  }

  export type DailyEntryUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<DailyEntryCreateWithoutVisitInput, DailyEntryUncheckedCreateWithoutVisitInput> | DailyEntryCreateWithoutVisitInput[] | DailyEntryUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutVisitInput | DailyEntryCreateOrConnectWithoutVisitInput[]
    upsert?: DailyEntryUpsertWithWhereUniqueWithoutVisitInput | DailyEntryUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: DailyEntryCreateManyVisitInputEnvelope
    set?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    disconnect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    delete?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    update?: DailyEntryUpdateWithWhereUniqueWithoutVisitInput | DailyEntryUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: DailyEntryUpdateManyWithWhereWithoutVisitInput | DailyEntryUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
  }

  export type VisitCreateNestedManyWithoutServiceInput = {
    create?: XOR<VisitCreateWithoutServiceInput, VisitUncheckedCreateWithoutServiceInput> | VisitCreateWithoutServiceInput[] | VisitUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutServiceInput | VisitCreateOrConnectWithoutServiceInput[]
    createMany?: VisitCreateManyServiceInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type VisitUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<VisitCreateWithoutServiceInput, VisitUncheckedCreateWithoutServiceInput> | VisitCreateWithoutServiceInput[] | VisitUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutServiceInput | VisitCreateOrConnectWithoutServiceInput[]
    createMany?: VisitCreateManyServiceInputEnvelope
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type VisitUpdateManyWithoutServiceNestedInput = {
    create?: XOR<VisitCreateWithoutServiceInput, VisitUncheckedCreateWithoutServiceInput> | VisitCreateWithoutServiceInput[] | VisitUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutServiceInput | VisitCreateOrConnectWithoutServiceInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutServiceInput | VisitUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: VisitCreateManyServiceInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutServiceInput | VisitUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutServiceInput | VisitUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<VisitCreateWithoutServiceInput, VisitUncheckedCreateWithoutServiceInput> | VisitCreateWithoutServiceInput[] | VisitUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: VisitCreateOrConnectWithoutServiceInput | VisitCreateOrConnectWithoutServiceInput[]
    upsert?: VisitUpsertWithWhereUniqueWithoutServiceInput | VisitUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: VisitCreateManyServiceInputEnvelope
    set?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    disconnect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    delete?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    connect?: VisitWhereUniqueInput | VisitWhereUniqueInput[]
    update?: VisitUpdateWithWhereUniqueWithoutServiceInput | VisitUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: VisitUpdateManyWithWhereWithoutServiceInput | VisitUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: VisitScalarWhereInput | VisitScalarWhereInput[]
  }

  export type VisitCreateNestedOneWithoutCheckEventsInput = {
    create?: XOR<VisitCreateWithoutCheckEventsInput, VisitUncheckedCreateWithoutCheckEventsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutCheckEventsInput
    connect?: VisitWhereUniqueInput
  }

  export type PswProfileCreateNestedOneWithoutCheckEventsInput = {
    create?: XOR<PswProfileCreateWithoutCheckEventsInput, PswProfileUncheckedCreateWithoutCheckEventsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutCheckEventsInput
    connect?: PswProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVisitCheckEventInput = {
    create?: XOR<UserCreateWithoutVisitCheckEventInput, UserUncheckedCreateWithoutVisitCheckEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitCheckEventInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type EnumEventResultFieldUpdateOperationsInput = {
    set?: $Enums.EventResult
  }

  export type VisitUpdateOneRequiredWithoutCheckEventsNestedInput = {
    create?: XOR<VisitCreateWithoutCheckEventsInput, VisitUncheckedCreateWithoutCheckEventsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutCheckEventsInput
    upsert?: VisitUpsertWithoutCheckEventsInput
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutCheckEventsInput, VisitUpdateWithoutCheckEventsInput>, VisitUncheckedUpdateWithoutCheckEventsInput>
  }

  export type PswProfileUpdateOneRequiredWithoutCheckEventsNestedInput = {
    create?: XOR<PswProfileCreateWithoutCheckEventsInput, PswProfileUncheckedCreateWithoutCheckEventsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutCheckEventsInput
    upsert?: PswProfileUpsertWithoutCheckEventsInput
    connect?: PswProfileWhereUniqueInput
    update?: XOR<XOR<PswProfileUpdateToOneWithWhereWithoutCheckEventsInput, PswProfileUpdateWithoutCheckEventsInput>, PswProfileUncheckedUpdateWithoutCheckEventsInput>
  }

  export type UserUpdateOneWithoutVisitCheckEventNestedInput = {
    create?: XOR<UserCreateWithoutVisitCheckEventInput, UserUncheckedCreateWithoutVisitCheckEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitCheckEventInput
    upsert?: UserUpsertWithoutVisitCheckEventInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVisitCheckEventInput, UserUpdateWithoutVisitCheckEventInput>, UserUncheckedUpdateWithoutVisitCheckEventInput>
  }

  export type VisitCreateNestedOneWithoutNotesInput = {
    create?: XOR<VisitCreateWithoutNotesInput, VisitUncheckedCreateWithoutNotesInput>
    connectOrCreate?: VisitCreateOrConnectWithoutNotesInput
    connect?: VisitWhereUniqueInput
  }

  export type PswProfileCreateNestedOneWithoutNotesInput = {
    create?: XOR<PswProfileCreateWithoutNotesInput, PswProfileUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutNotesInput
    connect?: PswProfileWhereUniqueInput
  }

  export type VisitUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<VisitCreateWithoutNotesInput, VisitUncheckedCreateWithoutNotesInput>
    connectOrCreate?: VisitCreateOrConnectWithoutNotesInput
    upsert?: VisitUpsertWithoutNotesInput
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutNotesInput, VisitUpdateWithoutNotesInput>, VisitUncheckedUpdateWithoutNotesInput>
  }

  export type PswProfileUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<PswProfileCreateWithoutNotesInput, PswProfileUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutNotesInput
    upsert?: PswProfileUpsertWithoutNotesInput
    connect?: PswProfileWhereUniqueInput
    update?: XOR<XOR<PswProfileUpdateToOneWithWhereWithoutNotesInput, PswProfileUpdateWithoutNotesInput>, PswProfileUncheckedUpdateWithoutNotesInput>
  }

  export type VisitCreateNestedOneWithoutChecklistsInput = {
    create?: XOR<VisitCreateWithoutChecklistsInput, VisitUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutChecklistsInput
    connect?: VisitWhereUniqueInput
  }

  export type PswProfileCreateNestedOneWithoutChecklistsInput = {
    create?: XOR<PswProfileCreateWithoutChecklistsInput, PswProfileUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutChecklistsInput
    connect?: PswProfileWhereUniqueInput
  }

  export type VisitUpdateOneRequiredWithoutChecklistsNestedInput = {
    create?: XOR<VisitCreateWithoutChecklistsInput, VisitUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutChecklistsInput
    upsert?: VisitUpsertWithoutChecklistsInput
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutChecklistsInput, VisitUpdateWithoutChecklistsInput>, VisitUncheckedUpdateWithoutChecklistsInput>
  }

  export type PswProfileUpdateOneRequiredWithoutChecklistsNestedInput = {
    create?: XOR<PswProfileCreateWithoutChecklistsInput, PswProfileUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutChecklistsInput
    upsert?: PswProfileUpsertWithoutChecklistsInput
    connect?: PswProfileWhereUniqueInput
    update?: XOR<XOR<PswProfileUpdateToOneWithWhereWithoutChecklistsInput, PswProfileUpdateWithoutChecklistsInput>, PswProfileUncheckedUpdateWithoutChecklistsInput>
  }

  export type VisitCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<VisitCreateWithoutIncidentsInput, VisitUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutIncidentsInput
    connect?: VisitWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportedIncidentsInput = {
    create?: XOR<UserCreateWithoutReportedIncidentsInput, UserUncheckedCreateWithoutReportedIncidentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedIncidentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumIncidentTypeFieldUpdateOperationsInput = {
    set?: $Enums.IncidentType
  }

  export type NullableEnumIncidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncidentStatus | null
  }

  export type VisitUpdateOneWithoutIncidentsNestedInput = {
    create?: XOR<VisitCreateWithoutIncidentsInput, VisitUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutIncidentsInput
    upsert?: VisitUpsertWithoutIncidentsInput
    disconnect?: VisitWhereInput | boolean
    delete?: VisitWhereInput | boolean
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutIncidentsInput, VisitUpdateWithoutIncidentsInput>, VisitUncheckedUpdateWithoutIncidentsInput>
  }

  export type UserUpdateOneRequiredWithoutReportedIncidentsNestedInput = {
    create?: XOR<UserCreateWithoutReportedIncidentsInput, UserUncheckedCreateWithoutReportedIncidentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedIncidentsInput
    upsert?: UserUpsertWithoutReportedIncidentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedIncidentsInput, UserUpdateWithoutReportedIncidentsInput>, UserUncheckedUpdateWithoutReportedIncidentsInput>
  }

  export type PswProfileCreateNestedOneWithoutTimesheetsInput = {
    create?: XOR<PswProfileCreateWithoutTimesheetsInput, PswProfileUncheckedCreateWithoutTimesheetsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutTimesheetsInput
    connect?: PswProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedTimesheetsInput = {
    create?: XOR<UserCreateWithoutReviewedTimesheetsInput, UserUncheckedCreateWithoutReviewedTimesheetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedTimesheetsInput
    connect?: UserWhereUniqueInput
  }

  export type TimesheetItemCreateNestedManyWithoutTimesheetInput = {
    create?: XOR<TimesheetItemCreateWithoutTimesheetInput, TimesheetItemUncheckedCreateWithoutTimesheetInput> | TimesheetItemCreateWithoutTimesheetInput[] | TimesheetItemUncheckedCreateWithoutTimesheetInput[]
    connectOrCreate?: TimesheetItemCreateOrConnectWithoutTimesheetInput | TimesheetItemCreateOrConnectWithoutTimesheetInput[]
    createMany?: TimesheetItemCreateManyTimesheetInputEnvelope
    connect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
  }

  export type TimesheetItemUncheckedCreateNestedManyWithoutTimesheetInput = {
    create?: XOR<TimesheetItemCreateWithoutTimesheetInput, TimesheetItemUncheckedCreateWithoutTimesheetInput> | TimesheetItemCreateWithoutTimesheetInput[] | TimesheetItemUncheckedCreateWithoutTimesheetInput[]
    connectOrCreate?: TimesheetItemCreateOrConnectWithoutTimesheetInput | TimesheetItemCreateOrConnectWithoutTimesheetInput[]
    createMany?: TimesheetItemCreateManyTimesheetInputEnvelope
    connect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumTimesheetStatusFieldUpdateOperationsInput = {
    set?: $Enums.TimesheetStatus | null
  }

  export type PswProfileUpdateOneRequiredWithoutTimesheetsNestedInput = {
    create?: XOR<PswProfileCreateWithoutTimesheetsInput, PswProfileUncheckedCreateWithoutTimesheetsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutTimesheetsInput
    upsert?: PswProfileUpsertWithoutTimesheetsInput
    connect?: PswProfileWhereUniqueInput
    update?: XOR<XOR<PswProfileUpdateToOneWithWhereWithoutTimesheetsInput, PswProfileUpdateWithoutTimesheetsInput>, PswProfileUncheckedUpdateWithoutTimesheetsInput>
  }

  export type UserUpdateOneWithoutReviewedTimesheetsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedTimesheetsInput, UserUncheckedCreateWithoutReviewedTimesheetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedTimesheetsInput
    upsert?: UserUpsertWithoutReviewedTimesheetsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedTimesheetsInput, UserUpdateWithoutReviewedTimesheetsInput>, UserUncheckedUpdateWithoutReviewedTimesheetsInput>
  }

  export type TimesheetItemUpdateManyWithoutTimesheetNestedInput = {
    create?: XOR<TimesheetItemCreateWithoutTimesheetInput, TimesheetItemUncheckedCreateWithoutTimesheetInput> | TimesheetItemCreateWithoutTimesheetInput[] | TimesheetItemUncheckedCreateWithoutTimesheetInput[]
    connectOrCreate?: TimesheetItemCreateOrConnectWithoutTimesheetInput | TimesheetItemCreateOrConnectWithoutTimesheetInput[]
    upsert?: TimesheetItemUpsertWithWhereUniqueWithoutTimesheetInput | TimesheetItemUpsertWithWhereUniqueWithoutTimesheetInput[]
    createMany?: TimesheetItemCreateManyTimesheetInputEnvelope
    set?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    disconnect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    delete?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    connect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    update?: TimesheetItemUpdateWithWhereUniqueWithoutTimesheetInput | TimesheetItemUpdateWithWhereUniqueWithoutTimesheetInput[]
    updateMany?: TimesheetItemUpdateManyWithWhereWithoutTimesheetInput | TimesheetItemUpdateManyWithWhereWithoutTimesheetInput[]
    deleteMany?: TimesheetItemScalarWhereInput | TimesheetItemScalarWhereInput[]
  }

  export type TimesheetItemUncheckedUpdateManyWithoutTimesheetNestedInput = {
    create?: XOR<TimesheetItemCreateWithoutTimesheetInput, TimesheetItemUncheckedCreateWithoutTimesheetInput> | TimesheetItemCreateWithoutTimesheetInput[] | TimesheetItemUncheckedCreateWithoutTimesheetInput[]
    connectOrCreate?: TimesheetItemCreateOrConnectWithoutTimesheetInput | TimesheetItemCreateOrConnectWithoutTimesheetInput[]
    upsert?: TimesheetItemUpsertWithWhereUniqueWithoutTimesheetInput | TimesheetItemUpsertWithWhereUniqueWithoutTimesheetInput[]
    createMany?: TimesheetItemCreateManyTimesheetInputEnvelope
    set?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    disconnect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    delete?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    connect?: TimesheetItemWhereUniqueInput | TimesheetItemWhereUniqueInput[]
    update?: TimesheetItemUpdateWithWhereUniqueWithoutTimesheetInput | TimesheetItemUpdateWithWhereUniqueWithoutTimesheetInput[]
    updateMany?: TimesheetItemUpdateManyWithWhereWithoutTimesheetInput | TimesheetItemUpdateManyWithWhereWithoutTimesheetInput[]
    deleteMany?: TimesheetItemScalarWhereInput | TimesheetItemScalarWhereInput[]
  }

  export type TimesheetCreateNestedOneWithoutItemsInput = {
    create?: XOR<TimesheetCreateWithoutItemsInput, TimesheetUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TimesheetCreateOrConnectWithoutItemsInput
    connect?: TimesheetWhereUniqueInput
  }

  export type VisitCreateNestedOneWithoutTimesheetItemsInput = {
    create?: XOR<VisitCreateWithoutTimesheetItemsInput, VisitUncheckedCreateWithoutTimesheetItemsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutTimesheetItemsInput
    connect?: VisitWhereUniqueInput
  }

  export type TimesheetUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TimesheetCreateWithoutItemsInput, TimesheetUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TimesheetCreateOrConnectWithoutItemsInput
    upsert?: TimesheetUpsertWithoutItemsInput
    connect?: TimesheetWhereUniqueInput
    update?: XOR<XOR<TimesheetUpdateToOneWithWhereWithoutItemsInput, TimesheetUpdateWithoutItemsInput>, TimesheetUncheckedUpdateWithoutItemsInput>
  }

  export type VisitUpdateOneRequiredWithoutTimesheetItemsNestedInput = {
    create?: XOR<VisitCreateWithoutTimesheetItemsInput, VisitUncheckedCreateWithoutTimesheetItemsInput>
    connectOrCreate?: VisitCreateOrConnectWithoutTimesheetItemsInput
    upsert?: VisitUpsertWithoutTimesheetItemsInput
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutTimesheetItemsInput, VisitUpdateWithoutTimesheetItemsInput>, VisitUncheckedUpdateWithoutTimesheetItemsInput>
  }

  export type ClientProfileCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ClientProfileCreateWithoutInvoicesInput, ClientProfileUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutInvoicesInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type NullableEnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus | null
  }

  export type ClientProfileUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<ClientProfileCreateWithoutInvoicesInput, ClientProfileUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutInvoicesInput
    upsert?: ClientProfileUpsertWithoutInvoicesInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutInvoicesInput, ClientProfileUpdateWithoutInvoicesInput>, ClientProfileUncheckedUpdateWithoutInvoicesInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type ClientProfileCreateNestedOneWithoutMessageThreadsInput = {
    create?: XOR<ClientProfileCreateWithoutMessageThreadsInput, ClientProfileUncheckedCreateWithoutMessageThreadsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutMessageThreadsInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type PswProfileCreateNestedOneWithoutMessageThreadsInput = {
    create?: XOR<PswProfileCreateWithoutMessageThreadsInput, PswProfileUncheckedCreateWithoutMessageThreadsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutMessageThreadsInput
    connect?: PswProfileWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ClientProfileUpdateOneWithoutMessageThreadsNestedInput = {
    create?: XOR<ClientProfileCreateWithoutMessageThreadsInput, ClientProfileUncheckedCreateWithoutMessageThreadsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutMessageThreadsInput
    upsert?: ClientProfileUpsertWithoutMessageThreadsInput
    disconnect?: ClientProfileWhereInput | boolean
    delete?: ClientProfileWhereInput | boolean
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutMessageThreadsInput, ClientProfileUpdateWithoutMessageThreadsInput>, ClientProfileUncheckedUpdateWithoutMessageThreadsInput>
  }

  export type PswProfileUpdateOneWithoutMessageThreadsNestedInput = {
    create?: XOR<PswProfileCreateWithoutMessageThreadsInput, PswProfileUncheckedCreateWithoutMessageThreadsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutMessageThreadsInput
    upsert?: PswProfileUpsertWithoutMessageThreadsInput
    disconnect?: PswProfileWhereInput | boolean
    delete?: PswProfileWhereInput | boolean
    connect?: PswProfileWhereUniqueInput
    update?: XOR<XOR<PswProfileUpdateToOneWithWhereWithoutMessageThreadsInput, PswProfileUpdateWithoutMessageThreadsInput>, PswProfileUncheckedUpdateWithoutMessageThreadsInput>
  }

  export type MessageUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutThreadInput | MessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutThreadInput | MessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutThreadInput | MessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutThreadInput | MessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutThreadInput | MessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutThreadInput | MessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageThreadCreateNestedOneWithoutMessagesInput = {
    create?: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutMessagesInput
    connect?: MessageThreadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageThreadUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutMessagesInput
    upsert?: MessageThreadUpsertWithoutMessagesInput
    connect?: MessageThreadWhereUniqueInput
    update?: XOR<XOR<MessageThreadUpdateToOneWithWhereWithoutMessagesInput, MessageThreadUpdateWithoutMessagesInput>, MessageThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    upsert?: UserUpsertWithoutBlogPostsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostsInput, UserUpdateWithoutBlogPostsInput>, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type PswProfileCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PswProfileCreateWithoutDocumentsInput, PswProfileUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutDocumentsInput
    connect?: PswProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVerifiedDocsInput = {
    create?: XOR<UserCreateWithoutVerifiedDocsInput, UserUncheckedCreateWithoutVerifiedDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedDocsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumDocStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocStatus | null
  }

  export type PswProfileUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<PswProfileCreateWithoutDocumentsInput, PswProfileUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PswProfileCreateOrConnectWithoutDocumentsInput
    upsert?: PswProfileUpsertWithoutDocumentsInput
    connect?: PswProfileWhereUniqueInput
    update?: XOR<XOR<PswProfileUpdateToOneWithWhereWithoutDocumentsInput, PswProfileUpdateWithoutDocumentsInput>, PswProfileUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneWithoutVerifiedDocsNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedDocsInput, UserUncheckedCreateWithoutVerifiedDocsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedDocsInput
    upsert?: UserUpsertWithoutVerifiedDocsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifiedDocsInput, UserUpdateWithoutVerifiedDocsInput>, UserUncheckedUpdateWithoutVerifiedDocsInput>
  }

  export type ClientProfileCreateNestedOneWithoutDailyEntryInput = {
    create?: XOR<ClientProfileCreateWithoutDailyEntryInput, ClientProfileUncheckedCreateWithoutDailyEntryInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutDailyEntryInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDailyEntryInput = {
    create?: XOR<UserCreateWithoutDailyEntryInput, UserUncheckedCreateWithoutDailyEntryInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyEntryInput
    connect?: UserWhereUniqueInput
  }

  export type VisitCreateNestedOneWithoutDailyEntryInput = {
    create?: XOR<VisitCreateWithoutDailyEntryInput, VisitUncheckedCreateWithoutDailyEntryInput>
    connectOrCreate?: VisitCreateOrConnectWithoutDailyEntryInput
    connect?: VisitWhereUniqueInput
  }

  export type EnumDailyEntryStatusFieldUpdateOperationsInput = {
    set?: $Enums.DailyEntryStatus
  }

  export type ClientProfileUpdateOneRequiredWithoutDailyEntryNestedInput = {
    create?: XOR<ClientProfileCreateWithoutDailyEntryInput, ClientProfileUncheckedCreateWithoutDailyEntryInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutDailyEntryInput
    upsert?: ClientProfileUpsertWithoutDailyEntryInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutDailyEntryInput, ClientProfileUpdateWithoutDailyEntryInput>, ClientProfileUncheckedUpdateWithoutDailyEntryInput>
  }

  export type UserUpdateOneRequiredWithoutDailyEntryNestedInput = {
    create?: XOR<UserCreateWithoutDailyEntryInput, UserUncheckedCreateWithoutDailyEntryInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyEntryInput
    upsert?: UserUpsertWithoutDailyEntryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyEntryInput, UserUpdateWithoutDailyEntryInput>, UserUncheckedUpdateWithoutDailyEntryInput>
  }

  export type VisitUpdateOneWithoutDailyEntryNestedInput = {
    create?: XOR<VisitCreateWithoutDailyEntryInput, VisitUncheckedCreateWithoutDailyEntryInput>
    connectOrCreate?: VisitCreateOrConnectWithoutDailyEntryInput
    upsert?: VisitUpsertWithoutDailyEntryInput
    disconnect?: VisitWhereInput | boolean
    delete?: VisitWhereInput | boolean
    connect?: VisitWhereUniqueInput
    update?: XOR<XOR<VisitUpdateToOneWithWhereWithoutDailyEntryInput, VisitUpdateWithoutDailyEntryInput>, VisitUncheckedUpdateWithoutDailyEntryInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumVisitStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVisitStatusNullableFilter<$PrismaModel> | $Enums.VisitStatus | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumVisitStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVisitStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumEventResultFilter<$PrismaModel = never> = {
    equals?: $Enums.EventResult | EnumEventResultFieldRefInput<$PrismaModel>
    in?: $Enums.EventResult[] | ListEnumEventResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventResult[] | ListEnumEventResultFieldRefInput<$PrismaModel>
    not?: NestedEnumEventResultFilter<$PrismaModel> | $Enums.EventResult
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumEventResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventResult | EnumEventResultFieldRefInput<$PrismaModel>
    in?: $Enums.EventResult[] | ListEnumEventResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventResult[] | ListEnumEventResultFieldRefInput<$PrismaModel>
    not?: NestedEnumEventResultWithAggregatesFilter<$PrismaModel> | $Enums.EventResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventResultFilter<$PrismaModel>
    _max?: NestedEnumEventResultFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumIncidentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeFilter<$PrismaModel> | $Enums.IncidentType
  }

  export type NestedEnumIncidentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIncidentStatusNullableFilter<$PrismaModel> | $Enums.IncidentStatus | null
  }

  export type NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentType | EnumIncidentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentType[] | ListEnumIncidentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IncidentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentTypeFilter<$PrismaModel>
    _max?: NestedEnumIncidentTypeFilter<$PrismaModel>
  }

  export type NestedEnumIncidentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIncidentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumTimesheetStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TimesheetStatus | EnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TimesheetStatus[] | ListEnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TimesheetStatus[] | ListEnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTimesheetStatusNullableFilter<$PrismaModel> | $Enums.TimesheetStatus | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumTimesheetStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimesheetStatus | EnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TimesheetStatus[] | ListEnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TimesheetStatus[] | ListEnumTimesheetStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTimesheetStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TimesheetStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTimesheetStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTimesheetStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInvoiceStatusNullableFilter<$PrismaModel> | $Enums.InvoiceStatus | null
  }

  export type NestedEnumInvoiceStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInvoiceStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDocStatusNullableFilter<$PrismaModel> | $Enums.DocStatus | null
  }

  export type NestedEnumDocStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDocStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.DocStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDocStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumDocStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumDailyEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DailyEntryStatus | EnumDailyEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DailyEntryStatus[] | ListEnumDailyEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DailyEntryStatus[] | ListEnumDailyEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDailyEntryStatusFilter<$PrismaModel> | $Enums.DailyEntryStatus
  }

  export type NestedEnumDailyEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DailyEntryStatus | EnumDailyEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DailyEntryStatus[] | ListEnumDailyEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DailyEntryStatus[] | ListEnumDailyEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDailyEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DailyEntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDailyEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumDailyEntryStatusFilter<$PrismaModel>
  }

  export type ClientProfileCreateWithoutUserInput = {
    id?: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutUserInput = {
    id?: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutUserInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
  }

  export type PswProfileCreateWithoutUserInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PswDocumentCreateNestedManyWithoutPswInput
    assignedVisits?: VisitCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistCreateNestedManyWithoutPswInput
    timesheets?: TimesheetCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadCreateNestedManyWithoutPswInput
  }

  export type PswProfileUncheckedCreateWithoutUserInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PswDocumentUncheckedCreateNestedManyWithoutPswInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutPswInput
    timesheets?: TimesheetUncheckedCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutPswInput
  }

  export type PswProfileCreateOrConnectWithoutUserInput = {
    where: PswProfileWhereUniqueInput
    create: XOR<PswProfileCreateWithoutUserInput, PswProfileUncheckedCreateWithoutUserInput>
  }

  export type PswDocumentCreateWithoutVerifierInput = {
    id?: string
    docType: string
    fileKey: string
    status?: $Enums.DocStatus | null
    expiryDate?: Date | string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    psw: PswProfileCreateNestedOneWithoutDocumentsInput
  }

  export type PswDocumentUncheckedCreateWithoutVerifierInput = {
    id?: string
    pswId: string
    docType: string
    fileKey: string
    status?: $Enums.DocStatus | null
    expiryDate?: Date | string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PswDocumentCreateOrConnectWithoutVerifierInput = {
    where: PswDocumentWhereUniqueInput
    create: XOR<PswDocumentCreateWithoutVerifierInput, PswDocumentUncheckedCreateWithoutVerifierInput>
  }

  export type PswDocumentCreateManyVerifierInputEnvelope = {
    data: PswDocumentCreateManyVerifierInput | PswDocumentCreateManyVerifierInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutReporterInput = {
    id?: string
    type: $Enums.IncidentType
    description: string
    status?: $Enums.IncidentStatus | null
    resolutionNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visit?: VisitCreateNestedOneWithoutIncidentsInput
  }

  export type IncidentUncheckedCreateWithoutReporterInput = {
    id?: string
    visitId?: string | null
    type: $Enums.IncidentType
    description: string
    status?: $Enums.IncidentStatus | null
    resolutionNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateOrConnectWithoutReporterInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutReporterInput, IncidentUncheckedCreateWithoutReporterInput>
  }

  export type IncidentCreateManyReporterInputEnvelope = {
    data: IncidentCreateManyReporterInput | IncidentCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type TimesheetCreateWithoutReviewerInput = {
    id?: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    psw: PswProfileCreateNestedOneWithoutTimesheetsInput
    items?: TimesheetItemCreateNestedManyWithoutTimesheetInput
  }

  export type TimesheetUncheckedCreateWithoutReviewerInput = {
    id?: string
    pswId: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TimesheetItemUncheckedCreateNestedManyWithoutTimesheetInput
  }

  export type TimesheetCreateOrConnectWithoutReviewerInput = {
    where: TimesheetWhereUniqueInput
    create: XOR<TimesheetCreateWithoutReviewerInput, TimesheetUncheckedCreateWithoutReviewerInput>
  }

  export type TimesheetCreateManyReviewerInputEnvelope = {
    data: TimesheetCreateManyReviewerInput | TimesheetCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    bodyText: string
    createdAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    threadId: string
    bodyText: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutActorInput = {
    id?: string
    action: string
    resourceType: string
    resourceId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    action: string
    resourceType: string
    resourceId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    contentHtml?: string | null
    status?: string | null
    publishedAt?: Date | string | null
    featureImageDocId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    canonicalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    contentHtml?: string | null
    status?: string | null
    publishedAt?: Date | string | null
    featureImageDocId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    canonicalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateOrConnectWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostCreateManyAuthorInputEnvelope = {
    data: BlogPostCreateManyAuthorInput | BlogPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type VisitCheckEventCreateWithoutOverriddenByInput = {
    id?: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideReason?: string | null
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutCheckEventsInput
    pswProfile: PswProfileCreateNestedOneWithoutCheckEventsInput
  }

  export type VisitCheckEventUncheckedCreateWithoutOverriddenByInput = {
    id?: string
    visitId: string
    pswId: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideReason?: string | null
    createdAt?: Date | string
  }

  export type VisitCheckEventCreateOrConnectWithoutOverriddenByInput = {
    where: VisitCheckEventWhereUniqueInput
    create: XOR<VisitCheckEventCreateWithoutOverriddenByInput, VisitCheckEventUncheckedCreateWithoutOverriddenByInput>
  }

  export type VisitCheckEventCreateManyOverriddenByInputEnvelope = {
    data: VisitCheckEventCreateManyOverriddenByInput | VisitCheckEventCreateManyOverriddenByInput[]
    skipDuplicates?: boolean
  }

  export type DailyEntryCreateWithoutStaffInput = {
    id?: string
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutDailyEntryInput
    visit?: VisitCreateNestedOneWithoutDailyEntryInput
  }

  export type DailyEntryUncheckedCreateWithoutStaffInput = {
    id?: string
    clientId: string
    visitId?: string | null
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyEntryCreateOrConnectWithoutStaffInput = {
    where: DailyEntryWhereUniqueInput
    create: XOR<DailyEntryCreateWithoutStaffInput, DailyEntryUncheckedCreateWithoutStaffInput>
  }

  export type DailyEntryCreateManyStaffInputEnvelope = {
    data: DailyEntryCreateManyStaffInput | DailyEntryCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type ClientProfileUpsertWithoutUserInput = {
    update: XOR<ClientProfileUpdateWithoutUserInput, ClientProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutUserInput, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClientProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type PswProfileUpsertWithoutUserInput = {
    update: XOR<PswProfileUpdateWithoutUserInput, PswProfileUncheckedUpdateWithoutUserInput>
    create: XOR<PswProfileCreateWithoutUserInput, PswProfileUncheckedCreateWithoutUserInput>
    where?: PswProfileWhereInput
  }

  export type PswProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: PswProfileWhereInput
    data: XOR<PswProfileUpdateWithoutUserInput, PswProfileUncheckedUpdateWithoutUserInput>
  }

  export type PswProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PswDocumentUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutPswNestedInput
  }

  export type PswProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PswDocumentUncheckedUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUncheckedUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutPswNestedInput
  }

  export type PswDocumentUpsertWithWhereUniqueWithoutVerifierInput = {
    where: PswDocumentWhereUniqueInput
    update: XOR<PswDocumentUpdateWithoutVerifierInput, PswDocumentUncheckedUpdateWithoutVerifierInput>
    create: XOR<PswDocumentCreateWithoutVerifierInput, PswDocumentUncheckedCreateWithoutVerifierInput>
  }

  export type PswDocumentUpdateWithWhereUniqueWithoutVerifierInput = {
    where: PswDocumentWhereUniqueInput
    data: XOR<PswDocumentUpdateWithoutVerifierInput, PswDocumentUncheckedUpdateWithoutVerifierInput>
  }

  export type PswDocumentUpdateManyWithWhereWithoutVerifierInput = {
    where: PswDocumentScalarWhereInput
    data: XOR<PswDocumentUpdateManyMutationInput, PswDocumentUncheckedUpdateManyWithoutVerifierInput>
  }

  export type PswDocumentScalarWhereInput = {
    AND?: PswDocumentScalarWhereInput | PswDocumentScalarWhereInput[]
    OR?: PswDocumentScalarWhereInput[]
    NOT?: PswDocumentScalarWhereInput | PswDocumentScalarWhereInput[]
    id?: StringFilter<"PswDocument"> | string
    pswId?: StringFilter<"PswDocument"> | string
    docType?: StringFilter<"PswDocument"> | string
    fileKey?: StringFilter<"PswDocument"> | string
    status?: EnumDocStatusNullableFilter<"PswDocument"> | $Enums.DocStatus | null
    expiryDate?: DateTimeNullableFilter<"PswDocument"> | Date | string | null
    verifiedBy?: StringNullableFilter<"PswDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"PswDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"PswDocument"> | Date | string
    updatedAt?: DateTimeFilter<"PswDocument"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutReporterInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutReporterInput, IncidentUncheckedUpdateWithoutReporterInput>
    create: XOR<IncidentCreateWithoutReporterInput, IncidentUncheckedCreateWithoutReporterInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutReporterInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutReporterInput, IncidentUncheckedUpdateWithoutReporterInput>
  }

  export type IncidentUpdateManyWithWhereWithoutReporterInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutReporterInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    visitId?: StringNullableFilter<"Incident"> | string | null
    reporterUserId?: StringFilter<"Incident"> | string
    type?: EnumIncidentTypeFilter<"Incident"> | $Enums.IncidentType
    description?: StringFilter<"Incident"> | string
    status?: EnumIncidentStatusNullableFilter<"Incident"> | $Enums.IncidentStatus | null
    resolutionNotes?: StringNullableFilter<"Incident"> | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
  }

  export type TimesheetUpsertWithWhereUniqueWithoutReviewerInput = {
    where: TimesheetWhereUniqueInput
    update: XOR<TimesheetUpdateWithoutReviewerInput, TimesheetUncheckedUpdateWithoutReviewerInput>
    create: XOR<TimesheetCreateWithoutReviewerInput, TimesheetUncheckedCreateWithoutReviewerInput>
  }

  export type TimesheetUpdateWithWhereUniqueWithoutReviewerInput = {
    where: TimesheetWhereUniqueInput
    data: XOR<TimesheetUpdateWithoutReviewerInput, TimesheetUncheckedUpdateWithoutReviewerInput>
  }

  export type TimesheetUpdateManyWithWhereWithoutReviewerInput = {
    where: TimesheetScalarWhereInput
    data: XOR<TimesheetUpdateManyMutationInput, TimesheetUncheckedUpdateManyWithoutReviewerInput>
  }

  export type TimesheetScalarWhereInput = {
    AND?: TimesheetScalarWhereInput | TimesheetScalarWhereInput[]
    OR?: TimesheetScalarWhereInput[]
    NOT?: TimesheetScalarWhereInput | TimesheetScalarWhereInput[]
    id?: StringFilter<"Timesheet"> | string
    pswId?: StringFilter<"Timesheet"> | string
    weekId?: StringFilter<"Timesheet"> | string
    totalMinutes?: IntNullableFilter<"Timesheet"> | number | null
    status?: EnumTimesheetStatusNullableFilter<"Timesheet"> | $Enums.TimesheetStatus | null
    submittedAt?: DateTimeNullableFilter<"Timesheet"> | Date | string | null
    reviewedBy?: StringNullableFilter<"Timesheet"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Timesheet"> | Date | string | null
    createdAt?: DateTimeFilter<"Timesheet"> | Date | string
    updatedAt?: DateTimeFilter<"Timesheet"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    senderUserId?: StringFilter<"Message"> | string
    bodyText?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    metadataJson?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    contentHtml?: StringNullableFilter<"BlogPost"> | string | null
    status?: StringNullableFilter<"BlogPost"> | string | null
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    authorUserId?: StringNullableFilter<"BlogPost"> | string | null
    featureImageDocId?: StringNullableFilter<"BlogPost"> | string | null
    seoTitle?: StringNullableFilter<"BlogPost"> | string | null
    seoDescription?: StringNullableFilter<"BlogPost"> | string | null
    canonicalUrl?: StringNullableFilter<"BlogPost"> | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
  }

  export type VisitCheckEventUpsertWithWhereUniqueWithoutOverriddenByInput = {
    where: VisitCheckEventWhereUniqueInput
    update: XOR<VisitCheckEventUpdateWithoutOverriddenByInput, VisitCheckEventUncheckedUpdateWithoutOverriddenByInput>
    create: XOR<VisitCheckEventCreateWithoutOverriddenByInput, VisitCheckEventUncheckedCreateWithoutOverriddenByInput>
  }

  export type VisitCheckEventUpdateWithWhereUniqueWithoutOverriddenByInput = {
    where: VisitCheckEventWhereUniqueInput
    data: XOR<VisitCheckEventUpdateWithoutOverriddenByInput, VisitCheckEventUncheckedUpdateWithoutOverriddenByInput>
  }

  export type VisitCheckEventUpdateManyWithWhereWithoutOverriddenByInput = {
    where: VisitCheckEventScalarWhereInput
    data: XOR<VisitCheckEventUpdateManyMutationInput, VisitCheckEventUncheckedUpdateManyWithoutOverriddenByInput>
  }

  export type VisitCheckEventScalarWhereInput = {
    AND?: VisitCheckEventScalarWhereInput | VisitCheckEventScalarWhereInput[]
    OR?: VisitCheckEventScalarWhereInput[]
    NOT?: VisitCheckEventScalarWhereInput | VisitCheckEventScalarWhereInput[]
    id?: StringFilter<"VisitCheckEvent"> | string
    visitId?: StringFilter<"VisitCheckEvent"> | string
    pswId?: StringFilter<"VisitCheckEvent"> | string
    eventType?: EnumEventTypeFilter<"VisitCheckEvent"> | $Enums.EventType
    lat?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    lng?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    accuracyM?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    computedDistanceM?: FloatNullableFilter<"VisitCheckEvent"> | number | null
    deviceTimeIso?: DateTimeNullableFilter<"VisitCheckEvent"> | Date | string | null
    serverTime?: DateTimeNullableFilter<"VisitCheckEvent"> | Date | string | null
    result?: EnumEventResultFilter<"VisitCheckEvent"> | $Enums.EventResult
    rejectReason?: StringNullableFilter<"VisitCheckEvent"> | string | null
    isOverride?: BoolNullableFilter<"VisitCheckEvent"> | boolean | null
    overrideByUserId?: StringNullableFilter<"VisitCheckEvent"> | string | null
    overrideReason?: StringNullableFilter<"VisitCheckEvent"> | string | null
    createdAt?: DateTimeFilter<"VisitCheckEvent"> | Date | string
  }

  export type DailyEntryUpsertWithWhereUniqueWithoutStaffInput = {
    where: DailyEntryWhereUniqueInput
    update: XOR<DailyEntryUpdateWithoutStaffInput, DailyEntryUncheckedUpdateWithoutStaffInput>
    create: XOR<DailyEntryCreateWithoutStaffInput, DailyEntryUncheckedCreateWithoutStaffInput>
  }

  export type DailyEntryUpdateWithWhereUniqueWithoutStaffInput = {
    where: DailyEntryWhereUniqueInput
    data: XOR<DailyEntryUpdateWithoutStaffInput, DailyEntryUncheckedUpdateWithoutStaffInput>
  }

  export type DailyEntryUpdateManyWithWhereWithoutStaffInput = {
    where: DailyEntryScalarWhereInput
    data: XOR<DailyEntryUpdateManyMutationInput, DailyEntryUncheckedUpdateManyWithoutStaffInput>
  }

  export type DailyEntryScalarWhereInput = {
    AND?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
    OR?: DailyEntryScalarWhereInput[]
    NOT?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
    id?: StringFilter<"DailyEntry"> | string
    clientId?: StringFilter<"DailyEntry"> | string
    staffId?: StringFilter<"DailyEntry"> | string
    visitId?: StringNullableFilter<"DailyEntry"> | string | null
    adlData?: JsonFilter<"DailyEntry">
    medication?: JsonNullableFilter<"DailyEntry">
    mood?: IntNullableFilter<"DailyEntry"> | number | null
    vitals?: JsonNullableFilter<"DailyEntry">
    notes?: StringNullableFilter<"DailyEntry"> | string | null
    signature?: StringNullableFilter<"DailyEntry"> | string | null
    status?: EnumDailyEntryStatusFilter<"DailyEntry"> | $Enums.DailyEntryStatus
    createdAt?: DateTimeFilter<"DailyEntry"> | Date | string
    updatedAt?: DateTimeFilter<"DailyEntry"> | Date | string
  }

  export type UserCreateWithoutClientProfileInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutClientProfileInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutClientProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
  }

  export type VisitCreateWithoutClientInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutVisitsInput
    psw?: PswProfileCreateNestedOneWithoutAssignedVisitsInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutVisitInput
    notes?: VisitNoteCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutClientInput = {
    id?: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemUncheckedCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutClientInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutClientInput, VisitUncheckedCreateWithoutClientInput>
  }

  export type VisitCreateManyClientInputEnvelope = {
    data: VisitCreateManyClientInput | VisitCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutClientInput = {
    id?: string
    status?: $Enums.InvoiceStatus | null
    currency?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string | null
    tax?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutClientInput = {
    id?: string
    status?: $Enums.InvoiceStatus | null
    currency?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string | null
    tax?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceCreateManyClientInputEnvelope = {
    data: InvoiceCreateManyClientInput | InvoiceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type MessageThreadCreateWithoutClientInput = {
    id?: string
    threadType: string
    createdAt?: Date | string
    psw?: PswProfileCreateNestedOneWithoutMessageThreadsInput
    messages?: MessageCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateWithoutClientInput = {
    id?: string
    threadType: string
    pswId?: string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadCreateOrConnectWithoutClientInput = {
    where: MessageThreadWhereUniqueInput
    create: XOR<MessageThreadCreateWithoutClientInput, MessageThreadUncheckedCreateWithoutClientInput>
  }

  export type MessageThreadCreateManyClientInputEnvelope = {
    data: MessageThreadCreateManyClientInput | MessageThreadCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type DailyEntryCreateWithoutClientInput = {
    id?: string
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: UserCreateNestedOneWithoutDailyEntryInput
    visit?: VisitCreateNestedOneWithoutDailyEntryInput
  }

  export type DailyEntryUncheckedCreateWithoutClientInput = {
    id?: string
    staffId: string
    visitId?: string | null
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyEntryCreateOrConnectWithoutClientInput = {
    where: DailyEntryWhereUniqueInput
    create: XOR<DailyEntryCreateWithoutClientInput, DailyEntryUncheckedCreateWithoutClientInput>
  }

  export type DailyEntryCreateManyClientInputEnvelope = {
    data: DailyEntryCreateManyClientInput | DailyEntryCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientProfileInput = {
    update: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type UserUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type VisitUpsertWithWhereUniqueWithoutClientInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutClientInput, VisitUncheckedUpdateWithoutClientInput>
    create: XOR<VisitCreateWithoutClientInput, VisitUncheckedCreateWithoutClientInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutClientInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutClientInput, VisitUncheckedUpdateWithoutClientInput>
  }

  export type VisitUpdateManyWithWhereWithoutClientInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutClientInput>
  }

  export type VisitScalarWhereInput = {
    AND?: VisitScalarWhereInput | VisitScalarWhereInput[]
    OR?: VisitScalarWhereInput[]
    NOT?: VisitScalarWhereInput | VisitScalarWhereInput[]
    id?: StringFilter<"Visit"> | string
    clientId?: StringFilter<"Visit"> | string
    serviceId?: StringFilter<"Visit"> | string
    requestedStartAt?: DateTimeFilter<"Visit"> | Date | string
    durationMinutes?: IntFilter<"Visit"> | number
    status?: EnumVisitStatusNullableFilter<"Visit"> | $Enums.VisitStatus | null
    assignedPswId?: StringNullableFilter<"Visit"> | string | null
    serviceAddressLine1?: StringNullableFilter<"Visit"> | string | null
    serviceAddressLine2?: StringNullableFilter<"Visit"> | string | null
    serviceCity?: StringNullableFilter<"Visit"> | string | null
    serviceProvince?: StringNullableFilter<"Visit"> | string | null
    servicePostalCode?: StringNullableFilter<"Visit"> | string | null
    serviceLat?: FloatNullableFilter<"Visit"> | number | null
    serviceLng?: FloatNullableFilter<"Visit"> | number | null
    clientNotes?: StringNullableFilter<"Visit"> | string | null
    coordinatorNotes?: StringNullableFilter<"Visit"> | string | null
    cancellationReason?: StringNullableFilter<"Visit"> | string | null
    createdAt?: DateTimeFilter<"Visit"> | Date | string
    updatedAt?: DateTimeFilter<"Visit"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    clientId?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusNullableFilter<"Invoice"> | $Enums.InvoiceStatus | null
    currency?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    tax?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type MessageThreadUpsertWithWhereUniqueWithoutClientInput = {
    where: MessageThreadWhereUniqueInput
    update: XOR<MessageThreadUpdateWithoutClientInput, MessageThreadUncheckedUpdateWithoutClientInput>
    create: XOR<MessageThreadCreateWithoutClientInput, MessageThreadUncheckedCreateWithoutClientInput>
  }

  export type MessageThreadUpdateWithWhereUniqueWithoutClientInput = {
    where: MessageThreadWhereUniqueInput
    data: XOR<MessageThreadUpdateWithoutClientInput, MessageThreadUncheckedUpdateWithoutClientInput>
  }

  export type MessageThreadUpdateManyWithWhereWithoutClientInput = {
    where: MessageThreadScalarWhereInput
    data: XOR<MessageThreadUpdateManyMutationInput, MessageThreadUncheckedUpdateManyWithoutClientInput>
  }

  export type MessageThreadScalarWhereInput = {
    AND?: MessageThreadScalarWhereInput | MessageThreadScalarWhereInput[]
    OR?: MessageThreadScalarWhereInput[]
    NOT?: MessageThreadScalarWhereInput | MessageThreadScalarWhereInput[]
    id?: StringFilter<"MessageThread"> | string
    threadType?: StringFilter<"MessageThread"> | string
    clientId?: StringNullableFilter<"MessageThread"> | string | null
    pswId?: StringNullableFilter<"MessageThread"> | string | null
    createdAt?: DateTimeFilter<"MessageThread"> | Date | string
  }

  export type DailyEntryUpsertWithWhereUniqueWithoutClientInput = {
    where: DailyEntryWhereUniqueInput
    update: XOR<DailyEntryUpdateWithoutClientInput, DailyEntryUncheckedUpdateWithoutClientInput>
    create: XOR<DailyEntryCreateWithoutClientInput, DailyEntryUncheckedCreateWithoutClientInput>
  }

  export type DailyEntryUpdateWithWhereUniqueWithoutClientInput = {
    where: DailyEntryWhereUniqueInput
    data: XOR<DailyEntryUpdateWithoutClientInput, DailyEntryUncheckedUpdateWithoutClientInput>
  }

  export type DailyEntryUpdateManyWithWhereWithoutClientInput = {
    where: DailyEntryScalarWhereInput
    data: XOR<DailyEntryUpdateManyMutationInput, DailyEntryUncheckedUpdateManyWithoutClientInput>
  }

  export type UserCreateWithoutPswProfileInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutPswProfileInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutPswProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPswProfileInput, UserUncheckedCreateWithoutPswProfileInput>
  }

  export type PswDocumentCreateWithoutPswInput = {
    id?: string
    docType: string
    fileKey: string
    status?: $Enums.DocStatus | null
    expiryDate?: Date | string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifier?: UserCreateNestedOneWithoutVerifiedDocsInput
  }

  export type PswDocumentUncheckedCreateWithoutPswInput = {
    id?: string
    docType: string
    fileKey: string
    status?: $Enums.DocStatus | null
    expiryDate?: Date | string | null
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PswDocumentCreateOrConnectWithoutPswInput = {
    where: PswDocumentWhereUniqueInput
    create: XOR<PswDocumentCreateWithoutPswInput, PswDocumentUncheckedCreateWithoutPswInput>
  }

  export type PswDocumentCreateManyPswInputEnvelope = {
    data: PswDocumentCreateManyPswInput | PswDocumentCreateManyPswInput[]
    skipDuplicates?: boolean
  }

  export type VisitCreateWithoutPswInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutVisitsInput
    service: ServiceCreateNestedOneWithoutVisitsInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutVisitInput
    notes?: VisitNoteCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutPswInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemUncheckedCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutPswInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutPswInput, VisitUncheckedCreateWithoutPswInput>
  }

  export type VisitCreateManyPswInputEnvelope = {
    data: VisitCreateManyPswInput | VisitCreateManyPswInput[]
    skipDuplicates?: boolean
  }

  export type VisitCheckEventCreateWithoutPswProfileInput = {
    id?: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideReason?: string | null
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutCheckEventsInput
    overriddenBy?: UserCreateNestedOneWithoutVisitCheckEventInput
  }

  export type VisitCheckEventUncheckedCreateWithoutPswProfileInput = {
    id?: string
    visitId: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideByUserId?: string | null
    overrideReason?: string | null
    createdAt?: Date | string
  }

  export type VisitCheckEventCreateOrConnectWithoutPswProfileInput = {
    where: VisitCheckEventWhereUniqueInput
    create: XOR<VisitCheckEventCreateWithoutPswProfileInput, VisitCheckEventUncheckedCreateWithoutPswProfileInput>
  }

  export type VisitCheckEventCreateManyPswProfileInputEnvelope = {
    data: VisitCheckEventCreateManyPswProfileInput | VisitCheckEventCreateManyPswProfileInput[]
    skipDuplicates?: boolean
  }

  export type VisitNoteCreateWithoutPswInput = {
    id?: string
    noteText: string
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutNotesInput
  }

  export type VisitNoteUncheckedCreateWithoutPswInput = {
    id?: string
    visitId: string
    noteText: string
    createdAt?: Date | string
  }

  export type VisitNoteCreateOrConnectWithoutPswInput = {
    where: VisitNoteWhereUniqueInput
    create: XOR<VisitNoteCreateWithoutPswInput, VisitNoteUncheckedCreateWithoutPswInput>
  }

  export type VisitNoteCreateManyPswInputEnvelope = {
    data: VisitNoteCreateManyPswInput | VisitNoteCreateManyPswInput[]
    skipDuplicates?: boolean
  }

  export type VisitChecklistCreateWithoutPswInput = {
    id?: string
    checklistJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutChecklistsInput
  }

  export type VisitChecklistUncheckedCreateWithoutPswInput = {
    id?: string
    visitId: string
    checklistJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VisitChecklistCreateOrConnectWithoutPswInput = {
    where: VisitChecklistWhereUniqueInput
    create: XOR<VisitChecklistCreateWithoutPswInput, VisitChecklistUncheckedCreateWithoutPswInput>
  }

  export type VisitChecklistCreateManyPswInputEnvelope = {
    data: VisitChecklistCreateManyPswInput | VisitChecklistCreateManyPswInput[]
    skipDuplicates?: boolean
  }

  export type TimesheetCreateWithoutPswInput = {
    id?: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewer?: UserCreateNestedOneWithoutReviewedTimesheetsInput
    items?: TimesheetItemCreateNestedManyWithoutTimesheetInput
  }

  export type TimesheetUncheckedCreateWithoutPswInput = {
    id?: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TimesheetItemUncheckedCreateNestedManyWithoutTimesheetInput
  }

  export type TimesheetCreateOrConnectWithoutPswInput = {
    where: TimesheetWhereUniqueInput
    create: XOR<TimesheetCreateWithoutPswInput, TimesheetUncheckedCreateWithoutPswInput>
  }

  export type TimesheetCreateManyPswInputEnvelope = {
    data: TimesheetCreateManyPswInput | TimesheetCreateManyPswInput[]
    skipDuplicates?: boolean
  }

  export type MessageThreadCreateWithoutPswInput = {
    id?: string
    threadType: string
    createdAt?: Date | string
    client?: ClientProfileCreateNestedOneWithoutMessageThreadsInput
    messages?: MessageCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateWithoutPswInput = {
    id?: string
    threadType: string
    clientId?: string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadCreateOrConnectWithoutPswInput = {
    where: MessageThreadWhereUniqueInput
    create: XOR<MessageThreadCreateWithoutPswInput, MessageThreadUncheckedCreateWithoutPswInput>
  }

  export type MessageThreadCreateManyPswInputEnvelope = {
    data: MessageThreadCreateManyPswInput | MessageThreadCreateManyPswInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPswProfileInput = {
    update: XOR<UserUpdateWithoutPswProfileInput, UserUncheckedUpdateWithoutPswProfileInput>
    create: XOR<UserCreateWithoutPswProfileInput, UserUncheckedCreateWithoutPswProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPswProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPswProfileInput, UserUncheckedUpdateWithoutPswProfileInput>
  }

  export type UserUpdateWithoutPswProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutPswProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type PswDocumentUpsertWithWhereUniqueWithoutPswInput = {
    where: PswDocumentWhereUniqueInput
    update: XOR<PswDocumentUpdateWithoutPswInput, PswDocumentUncheckedUpdateWithoutPswInput>
    create: XOR<PswDocumentCreateWithoutPswInput, PswDocumentUncheckedCreateWithoutPswInput>
  }

  export type PswDocumentUpdateWithWhereUniqueWithoutPswInput = {
    where: PswDocumentWhereUniqueInput
    data: XOR<PswDocumentUpdateWithoutPswInput, PswDocumentUncheckedUpdateWithoutPswInput>
  }

  export type PswDocumentUpdateManyWithWhereWithoutPswInput = {
    where: PswDocumentScalarWhereInput
    data: XOR<PswDocumentUpdateManyMutationInput, PswDocumentUncheckedUpdateManyWithoutPswInput>
  }

  export type VisitUpsertWithWhereUniqueWithoutPswInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutPswInput, VisitUncheckedUpdateWithoutPswInput>
    create: XOR<VisitCreateWithoutPswInput, VisitUncheckedCreateWithoutPswInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutPswInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutPswInput, VisitUncheckedUpdateWithoutPswInput>
  }

  export type VisitUpdateManyWithWhereWithoutPswInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutPswInput>
  }

  export type VisitCheckEventUpsertWithWhereUniqueWithoutPswProfileInput = {
    where: VisitCheckEventWhereUniqueInput
    update: XOR<VisitCheckEventUpdateWithoutPswProfileInput, VisitCheckEventUncheckedUpdateWithoutPswProfileInput>
    create: XOR<VisitCheckEventCreateWithoutPswProfileInput, VisitCheckEventUncheckedCreateWithoutPswProfileInput>
  }

  export type VisitCheckEventUpdateWithWhereUniqueWithoutPswProfileInput = {
    where: VisitCheckEventWhereUniqueInput
    data: XOR<VisitCheckEventUpdateWithoutPswProfileInput, VisitCheckEventUncheckedUpdateWithoutPswProfileInput>
  }

  export type VisitCheckEventUpdateManyWithWhereWithoutPswProfileInput = {
    where: VisitCheckEventScalarWhereInput
    data: XOR<VisitCheckEventUpdateManyMutationInput, VisitCheckEventUncheckedUpdateManyWithoutPswProfileInput>
  }

  export type VisitNoteUpsertWithWhereUniqueWithoutPswInput = {
    where: VisitNoteWhereUniqueInput
    update: XOR<VisitNoteUpdateWithoutPswInput, VisitNoteUncheckedUpdateWithoutPswInput>
    create: XOR<VisitNoteCreateWithoutPswInput, VisitNoteUncheckedCreateWithoutPswInput>
  }

  export type VisitNoteUpdateWithWhereUniqueWithoutPswInput = {
    where: VisitNoteWhereUniqueInput
    data: XOR<VisitNoteUpdateWithoutPswInput, VisitNoteUncheckedUpdateWithoutPswInput>
  }

  export type VisitNoteUpdateManyWithWhereWithoutPswInput = {
    where: VisitNoteScalarWhereInput
    data: XOR<VisitNoteUpdateManyMutationInput, VisitNoteUncheckedUpdateManyWithoutPswInput>
  }

  export type VisitNoteScalarWhereInput = {
    AND?: VisitNoteScalarWhereInput | VisitNoteScalarWhereInput[]
    OR?: VisitNoteScalarWhereInput[]
    NOT?: VisitNoteScalarWhereInput | VisitNoteScalarWhereInput[]
    id?: StringFilter<"VisitNote"> | string
    visitId?: StringFilter<"VisitNote"> | string
    pswId?: StringFilter<"VisitNote"> | string
    noteText?: StringFilter<"VisitNote"> | string
    createdAt?: DateTimeFilter<"VisitNote"> | Date | string
  }

  export type VisitChecklistUpsertWithWhereUniqueWithoutPswInput = {
    where: VisitChecklistWhereUniqueInput
    update: XOR<VisitChecklistUpdateWithoutPswInput, VisitChecklistUncheckedUpdateWithoutPswInput>
    create: XOR<VisitChecklistCreateWithoutPswInput, VisitChecklistUncheckedCreateWithoutPswInput>
  }

  export type VisitChecklistUpdateWithWhereUniqueWithoutPswInput = {
    where: VisitChecklistWhereUniqueInput
    data: XOR<VisitChecklistUpdateWithoutPswInput, VisitChecklistUncheckedUpdateWithoutPswInput>
  }

  export type VisitChecklistUpdateManyWithWhereWithoutPswInput = {
    where: VisitChecklistScalarWhereInput
    data: XOR<VisitChecklistUpdateManyMutationInput, VisitChecklistUncheckedUpdateManyWithoutPswInput>
  }

  export type VisitChecklistScalarWhereInput = {
    AND?: VisitChecklistScalarWhereInput | VisitChecklistScalarWhereInput[]
    OR?: VisitChecklistScalarWhereInput[]
    NOT?: VisitChecklistScalarWhereInput | VisitChecklistScalarWhereInput[]
    id?: StringFilter<"VisitChecklist"> | string
    visitId?: StringFilter<"VisitChecklist"> | string
    pswId?: StringFilter<"VisitChecklist"> | string
    checklistJson?: JsonFilter<"VisitChecklist">
    createdAt?: DateTimeFilter<"VisitChecklist"> | Date | string
  }

  export type TimesheetUpsertWithWhereUniqueWithoutPswInput = {
    where: TimesheetWhereUniqueInput
    update: XOR<TimesheetUpdateWithoutPswInput, TimesheetUncheckedUpdateWithoutPswInput>
    create: XOR<TimesheetCreateWithoutPswInput, TimesheetUncheckedCreateWithoutPswInput>
  }

  export type TimesheetUpdateWithWhereUniqueWithoutPswInput = {
    where: TimesheetWhereUniqueInput
    data: XOR<TimesheetUpdateWithoutPswInput, TimesheetUncheckedUpdateWithoutPswInput>
  }

  export type TimesheetUpdateManyWithWhereWithoutPswInput = {
    where: TimesheetScalarWhereInput
    data: XOR<TimesheetUpdateManyMutationInput, TimesheetUncheckedUpdateManyWithoutPswInput>
  }

  export type MessageThreadUpsertWithWhereUniqueWithoutPswInput = {
    where: MessageThreadWhereUniqueInput
    update: XOR<MessageThreadUpdateWithoutPswInput, MessageThreadUncheckedUpdateWithoutPswInput>
    create: XOR<MessageThreadCreateWithoutPswInput, MessageThreadUncheckedCreateWithoutPswInput>
  }

  export type MessageThreadUpdateWithWhereUniqueWithoutPswInput = {
    where: MessageThreadWhereUniqueInput
    data: XOR<MessageThreadUpdateWithoutPswInput, MessageThreadUncheckedUpdateWithoutPswInput>
  }

  export type MessageThreadUpdateManyWithWhereWithoutPswInput = {
    where: MessageThreadScalarWhereInput
    data: XOR<MessageThreadUpdateManyMutationInput, MessageThreadUncheckedUpdateManyWithoutPswInput>
  }

  export type ClientProfileCreateWithoutVisitsInput = {
    id?: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutVisitsInput = {
    id?: string
    userId: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutVisitsInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutVisitsInput, ClientProfileUncheckedCreateWithoutVisitsInput>
  }

  export type ServiceCreateWithoutVisitsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseRateHourly?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateWithoutVisitsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseRateHourly?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutVisitsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutVisitsInput, ServiceUncheckedCreateWithoutVisitsInput>
  }

  export type PswProfileCreateWithoutAssignedVisitsInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPswProfileInput
    documents?: PswDocumentCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistCreateNestedManyWithoutPswInput
    timesheets?: TimesheetCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadCreateNestedManyWithoutPswInput
  }

  export type PswProfileUncheckedCreateWithoutAssignedVisitsInput = {
    id?: string
    userId: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PswDocumentUncheckedCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutPswInput
    timesheets?: TimesheetUncheckedCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutPswInput
  }

  export type PswProfileCreateOrConnectWithoutAssignedVisitsInput = {
    where: PswProfileWhereUniqueInput
    create: XOR<PswProfileCreateWithoutAssignedVisitsInput, PswProfileUncheckedCreateWithoutAssignedVisitsInput>
  }

  export type VisitCheckEventCreateWithoutVisitInput = {
    id?: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideReason?: string | null
    createdAt?: Date | string
    pswProfile: PswProfileCreateNestedOneWithoutCheckEventsInput
    overriddenBy?: UserCreateNestedOneWithoutVisitCheckEventInput
  }

  export type VisitCheckEventUncheckedCreateWithoutVisitInput = {
    id?: string
    pswId: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideByUserId?: string | null
    overrideReason?: string | null
    createdAt?: Date | string
  }

  export type VisitCheckEventCreateOrConnectWithoutVisitInput = {
    where: VisitCheckEventWhereUniqueInput
    create: XOR<VisitCheckEventCreateWithoutVisitInput, VisitCheckEventUncheckedCreateWithoutVisitInput>
  }

  export type VisitCheckEventCreateManyVisitInputEnvelope = {
    data: VisitCheckEventCreateManyVisitInput | VisitCheckEventCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type VisitNoteCreateWithoutVisitInput = {
    id?: string
    noteText: string
    createdAt?: Date | string
    psw: PswProfileCreateNestedOneWithoutNotesInput
  }

  export type VisitNoteUncheckedCreateWithoutVisitInput = {
    id?: string
    pswId: string
    noteText: string
    createdAt?: Date | string
  }

  export type VisitNoteCreateOrConnectWithoutVisitInput = {
    where: VisitNoteWhereUniqueInput
    create: XOR<VisitNoteCreateWithoutVisitInput, VisitNoteUncheckedCreateWithoutVisitInput>
  }

  export type VisitNoteCreateManyVisitInputEnvelope = {
    data: VisitNoteCreateManyVisitInput | VisitNoteCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type VisitChecklistCreateWithoutVisitInput = {
    id?: string
    checklistJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    psw: PswProfileCreateNestedOneWithoutChecklistsInput
  }

  export type VisitChecklistUncheckedCreateWithoutVisitInput = {
    id?: string
    pswId: string
    checklistJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VisitChecklistCreateOrConnectWithoutVisitInput = {
    where: VisitChecklistWhereUniqueInput
    create: XOR<VisitChecklistCreateWithoutVisitInput, VisitChecklistUncheckedCreateWithoutVisitInput>
  }

  export type VisitChecklistCreateManyVisitInputEnvelope = {
    data: VisitChecklistCreateManyVisitInput | VisitChecklistCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutVisitInput = {
    id?: string
    type: $Enums.IncidentType
    description: string
    status?: $Enums.IncidentStatus | null
    resolutionNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportedIncidentsInput
  }

  export type IncidentUncheckedCreateWithoutVisitInput = {
    id?: string
    reporterUserId: string
    type: $Enums.IncidentType
    description: string
    status?: $Enums.IncidentStatus | null
    resolutionNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateOrConnectWithoutVisitInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput>
  }

  export type IncidentCreateManyVisitInputEnvelope = {
    data: IncidentCreateManyVisitInput | IncidentCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type TimesheetItemCreateWithoutVisitInput = {
    id?: string
    minutes: number
    createdAt?: Date | string
    timesheet: TimesheetCreateNestedOneWithoutItemsInput
  }

  export type TimesheetItemUncheckedCreateWithoutVisitInput = {
    id?: string
    timesheetId: string
    minutes: number
    createdAt?: Date | string
  }

  export type TimesheetItemCreateOrConnectWithoutVisitInput = {
    where: TimesheetItemWhereUniqueInput
    create: XOR<TimesheetItemCreateWithoutVisitInput, TimesheetItemUncheckedCreateWithoutVisitInput>
  }

  export type TimesheetItemCreateManyVisitInputEnvelope = {
    data: TimesheetItemCreateManyVisitInput | TimesheetItemCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type DailyEntryCreateWithoutVisitInput = {
    id?: string
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutDailyEntryInput
    staff: UserCreateNestedOneWithoutDailyEntryInput
  }

  export type DailyEntryUncheckedCreateWithoutVisitInput = {
    id?: string
    clientId: string
    staffId: string
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyEntryCreateOrConnectWithoutVisitInput = {
    where: DailyEntryWhereUniqueInput
    create: XOR<DailyEntryCreateWithoutVisitInput, DailyEntryUncheckedCreateWithoutVisitInput>
  }

  export type DailyEntryCreateManyVisitInputEnvelope = {
    data: DailyEntryCreateManyVisitInput | DailyEntryCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type ClientProfileUpsertWithoutVisitsInput = {
    update: XOR<ClientProfileUpdateWithoutVisitsInput, ClientProfileUncheckedUpdateWithoutVisitsInput>
    create: XOR<ClientProfileCreateWithoutVisitsInput, ClientProfileUncheckedCreateWithoutVisitsInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutVisitsInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutVisitsInput, ClientProfileUncheckedUpdateWithoutVisitsInput>
  }

  export type ClientProfileUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ServiceUpsertWithoutVisitsInput = {
    update: XOR<ServiceUpdateWithoutVisitsInput, ServiceUncheckedUpdateWithoutVisitsInput>
    create: XOR<ServiceCreateWithoutVisitsInput, ServiceUncheckedCreateWithoutVisitsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutVisitsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutVisitsInput, ServiceUncheckedUpdateWithoutVisitsInput>
  }

  export type ServiceUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseRateHourly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseRateHourly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PswProfileUpsertWithoutAssignedVisitsInput = {
    update: XOR<PswProfileUpdateWithoutAssignedVisitsInput, PswProfileUncheckedUpdateWithoutAssignedVisitsInput>
    create: XOR<PswProfileCreateWithoutAssignedVisitsInput, PswProfileUncheckedCreateWithoutAssignedVisitsInput>
    where?: PswProfileWhereInput
  }

  export type PswProfileUpdateToOneWithWhereWithoutAssignedVisitsInput = {
    where?: PswProfileWhereInput
    data: XOR<PswProfileUpdateWithoutAssignedVisitsInput, PswProfileUncheckedUpdateWithoutAssignedVisitsInput>
  }

  export type PswProfileUpdateWithoutAssignedVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPswProfileNestedInput
    documents?: PswDocumentUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutPswNestedInput
  }

  export type PswProfileUncheckedUpdateWithoutAssignedVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PswDocumentUncheckedUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUncheckedUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutPswNestedInput
  }

  export type VisitCheckEventUpsertWithWhereUniqueWithoutVisitInput = {
    where: VisitCheckEventWhereUniqueInput
    update: XOR<VisitCheckEventUpdateWithoutVisitInput, VisitCheckEventUncheckedUpdateWithoutVisitInput>
    create: XOR<VisitCheckEventCreateWithoutVisitInput, VisitCheckEventUncheckedCreateWithoutVisitInput>
  }

  export type VisitCheckEventUpdateWithWhereUniqueWithoutVisitInput = {
    where: VisitCheckEventWhereUniqueInput
    data: XOR<VisitCheckEventUpdateWithoutVisitInput, VisitCheckEventUncheckedUpdateWithoutVisitInput>
  }

  export type VisitCheckEventUpdateManyWithWhereWithoutVisitInput = {
    where: VisitCheckEventScalarWhereInput
    data: XOR<VisitCheckEventUpdateManyMutationInput, VisitCheckEventUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitNoteUpsertWithWhereUniqueWithoutVisitInput = {
    where: VisitNoteWhereUniqueInput
    update: XOR<VisitNoteUpdateWithoutVisitInput, VisitNoteUncheckedUpdateWithoutVisitInput>
    create: XOR<VisitNoteCreateWithoutVisitInput, VisitNoteUncheckedCreateWithoutVisitInput>
  }

  export type VisitNoteUpdateWithWhereUniqueWithoutVisitInput = {
    where: VisitNoteWhereUniqueInput
    data: XOR<VisitNoteUpdateWithoutVisitInput, VisitNoteUncheckedUpdateWithoutVisitInput>
  }

  export type VisitNoteUpdateManyWithWhereWithoutVisitInput = {
    where: VisitNoteScalarWhereInput
    data: XOR<VisitNoteUpdateManyMutationInput, VisitNoteUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitChecklistUpsertWithWhereUniqueWithoutVisitInput = {
    where: VisitChecklistWhereUniqueInput
    update: XOR<VisitChecklistUpdateWithoutVisitInput, VisitChecklistUncheckedUpdateWithoutVisitInput>
    create: XOR<VisitChecklistCreateWithoutVisitInput, VisitChecklistUncheckedCreateWithoutVisitInput>
  }

  export type VisitChecklistUpdateWithWhereUniqueWithoutVisitInput = {
    where: VisitChecklistWhereUniqueInput
    data: XOR<VisitChecklistUpdateWithoutVisitInput, VisitChecklistUncheckedUpdateWithoutVisitInput>
  }

  export type VisitChecklistUpdateManyWithWhereWithoutVisitInput = {
    where: VisitChecklistScalarWhereInput
    data: XOR<VisitChecklistUpdateManyMutationInput, VisitChecklistUncheckedUpdateManyWithoutVisitInput>
  }

  export type IncidentUpsertWithWhereUniqueWithoutVisitInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutVisitInput, IncidentUncheckedUpdateWithoutVisitInput>
    create: XOR<IncidentCreateWithoutVisitInput, IncidentUncheckedCreateWithoutVisitInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutVisitInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutVisitInput, IncidentUncheckedUpdateWithoutVisitInput>
  }

  export type IncidentUpdateManyWithWhereWithoutVisitInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutVisitInput>
  }

  export type TimesheetItemUpsertWithWhereUniqueWithoutVisitInput = {
    where: TimesheetItemWhereUniqueInput
    update: XOR<TimesheetItemUpdateWithoutVisitInput, TimesheetItemUncheckedUpdateWithoutVisitInput>
    create: XOR<TimesheetItemCreateWithoutVisitInput, TimesheetItemUncheckedCreateWithoutVisitInput>
  }

  export type TimesheetItemUpdateWithWhereUniqueWithoutVisitInput = {
    where: TimesheetItemWhereUniqueInput
    data: XOR<TimesheetItemUpdateWithoutVisitInput, TimesheetItemUncheckedUpdateWithoutVisitInput>
  }

  export type TimesheetItemUpdateManyWithWhereWithoutVisitInput = {
    where: TimesheetItemScalarWhereInput
    data: XOR<TimesheetItemUpdateManyMutationInput, TimesheetItemUncheckedUpdateManyWithoutVisitInput>
  }

  export type TimesheetItemScalarWhereInput = {
    AND?: TimesheetItemScalarWhereInput | TimesheetItemScalarWhereInput[]
    OR?: TimesheetItemScalarWhereInput[]
    NOT?: TimesheetItemScalarWhereInput | TimesheetItemScalarWhereInput[]
    id?: StringFilter<"TimesheetItem"> | string
    timesheetId?: StringFilter<"TimesheetItem"> | string
    visitId?: StringFilter<"TimesheetItem"> | string
    minutes?: IntFilter<"TimesheetItem"> | number
    createdAt?: DateTimeFilter<"TimesheetItem"> | Date | string
  }

  export type DailyEntryUpsertWithWhereUniqueWithoutVisitInput = {
    where: DailyEntryWhereUniqueInput
    update: XOR<DailyEntryUpdateWithoutVisitInput, DailyEntryUncheckedUpdateWithoutVisitInput>
    create: XOR<DailyEntryCreateWithoutVisitInput, DailyEntryUncheckedCreateWithoutVisitInput>
  }

  export type DailyEntryUpdateWithWhereUniqueWithoutVisitInput = {
    where: DailyEntryWhereUniqueInput
    data: XOR<DailyEntryUpdateWithoutVisitInput, DailyEntryUncheckedUpdateWithoutVisitInput>
  }

  export type DailyEntryUpdateManyWithWhereWithoutVisitInput = {
    where: DailyEntryScalarWhereInput
    data: XOR<DailyEntryUpdateManyMutationInput, DailyEntryUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitCreateWithoutServiceInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutVisitsInput
    psw?: PswProfileCreateNestedOneWithoutAssignedVisitsInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutVisitInput
    notes?: VisitNoteCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutServiceInput = {
    id?: string
    clientId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemUncheckedCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutServiceInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutServiceInput, VisitUncheckedCreateWithoutServiceInput>
  }

  export type VisitCreateManyServiceInputEnvelope = {
    data: VisitCreateManyServiceInput | VisitCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type VisitUpsertWithWhereUniqueWithoutServiceInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutServiceInput, VisitUncheckedUpdateWithoutServiceInput>
    create: XOR<VisitCreateWithoutServiceInput, VisitUncheckedCreateWithoutServiceInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutServiceInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutServiceInput, VisitUncheckedUpdateWithoutServiceInput>
  }

  export type VisitUpdateManyWithWhereWithoutServiceInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutServiceInput>
  }

  export type VisitCreateWithoutCheckEventsInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutVisitsInput
    service: ServiceCreateNestedOneWithoutVisitsInput
    psw?: PswProfileCreateNestedOneWithoutAssignedVisitsInput
    notes?: VisitNoteCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutCheckEventsInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: VisitNoteUncheckedCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemUncheckedCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutCheckEventsInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutCheckEventsInput, VisitUncheckedCreateWithoutCheckEventsInput>
  }

  export type PswProfileCreateWithoutCheckEventsInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPswProfileInput
    documents?: PswDocumentCreateNestedManyWithoutPswInput
    assignedVisits?: VisitCreateNestedManyWithoutPswInput
    notes?: VisitNoteCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistCreateNestedManyWithoutPswInput
    timesheets?: TimesheetCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadCreateNestedManyWithoutPswInput
  }

  export type PswProfileUncheckedCreateWithoutCheckEventsInput = {
    id?: string
    userId: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PswDocumentUncheckedCreateNestedManyWithoutPswInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutPswInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutPswInput
    timesheets?: TimesheetUncheckedCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutPswInput
  }

  export type PswProfileCreateOrConnectWithoutCheckEventsInput = {
    where: PswProfileWhereUniqueInput
    create: XOR<PswProfileCreateWithoutCheckEventsInput, PswProfileUncheckedCreateWithoutCheckEventsInput>
  }

  export type UserCreateWithoutVisitCheckEventInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutVisitCheckEventInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutVisitCheckEventInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVisitCheckEventInput, UserUncheckedCreateWithoutVisitCheckEventInput>
  }

  export type VisitUpsertWithoutCheckEventsInput = {
    update: XOR<VisitUpdateWithoutCheckEventsInput, VisitUncheckedUpdateWithoutCheckEventsInput>
    create: XOR<VisitCreateWithoutCheckEventsInput, VisitUncheckedCreateWithoutCheckEventsInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutCheckEventsInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutCheckEventsInput, VisitUncheckedUpdateWithoutCheckEventsInput>
  }

  export type VisitUpdateWithoutCheckEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutVisitsNestedInput
    service?: ServiceUpdateOneRequiredWithoutVisitsNestedInput
    psw?: PswProfileUpdateOneWithoutAssignedVisitsNestedInput
    notes?: VisitNoteUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutCheckEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: VisitNoteUncheckedUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type PswProfileUpsertWithoutCheckEventsInput = {
    update: XOR<PswProfileUpdateWithoutCheckEventsInput, PswProfileUncheckedUpdateWithoutCheckEventsInput>
    create: XOR<PswProfileCreateWithoutCheckEventsInput, PswProfileUncheckedCreateWithoutCheckEventsInput>
    where?: PswProfileWhereInput
  }

  export type PswProfileUpdateToOneWithWhereWithoutCheckEventsInput = {
    where?: PswProfileWhereInput
    data: XOR<PswProfileUpdateWithoutCheckEventsInput, PswProfileUncheckedUpdateWithoutCheckEventsInput>
  }

  export type PswProfileUpdateWithoutCheckEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPswProfileNestedInput
    documents?: PswDocumentUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUpdateManyWithoutPswNestedInput
    notes?: VisitNoteUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutPswNestedInput
  }

  export type PswProfileUncheckedUpdateWithoutCheckEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PswDocumentUncheckedUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutPswNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUncheckedUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutPswNestedInput
  }

  export type UserUpsertWithoutVisitCheckEventInput = {
    update: XOR<UserUpdateWithoutVisitCheckEventInput, UserUncheckedUpdateWithoutVisitCheckEventInput>
    create: XOR<UserCreateWithoutVisitCheckEventInput, UserUncheckedCreateWithoutVisitCheckEventInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVisitCheckEventInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVisitCheckEventInput, UserUncheckedUpdateWithoutVisitCheckEventInput>
  }

  export type UserUpdateWithoutVisitCheckEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutVisitCheckEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type VisitCreateWithoutNotesInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutVisitsInput
    service: ServiceCreateNestedOneWithoutVisitsInput
    psw?: PswProfileCreateNestedOneWithoutAssignedVisitsInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutNotesInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemUncheckedCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutNotesInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutNotesInput, VisitUncheckedCreateWithoutNotesInput>
  }

  export type PswProfileCreateWithoutNotesInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPswProfileInput
    documents?: PswDocumentCreateNestedManyWithoutPswInput
    assignedVisits?: VisitCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutPswProfileInput
    checklists?: VisitChecklistCreateNestedManyWithoutPswInput
    timesheets?: TimesheetCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadCreateNestedManyWithoutPswInput
  }

  export type PswProfileUncheckedCreateWithoutNotesInput = {
    id?: string
    userId: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PswDocumentUncheckedCreateNestedManyWithoutPswInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutPswProfileInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutPswInput
    timesheets?: TimesheetUncheckedCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutPswInput
  }

  export type PswProfileCreateOrConnectWithoutNotesInput = {
    where: PswProfileWhereUniqueInput
    create: XOR<PswProfileCreateWithoutNotesInput, PswProfileUncheckedCreateWithoutNotesInput>
  }

  export type VisitUpsertWithoutNotesInput = {
    update: XOR<VisitUpdateWithoutNotesInput, VisitUncheckedUpdateWithoutNotesInput>
    create: XOR<VisitCreateWithoutNotesInput, VisitUncheckedCreateWithoutNotesInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutNotesInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutNotesInput, VisitUncheckedUpdateWithoutNotesInput>
  }

  export type VisitUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutVisitsNestedInput
    service?: ServiceUpdateOneRequiredWithoutVisitsNestedInput
    psw?: PswProfileUpdateOneWithoutAssignedVisitsNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type PswProfileUpsertWithoutNotesInput = {
    update: XOR<PswProfileUpdateWithoutNotesInput, PswProfileUncheckedUpdateWithoutNotesInput>
    create: XOR<PswProfileCreateWithoutNotesInput, PswProfileUncheckedCreateWithoutNotesInput>
    where?: PswProfileWhereInput
  }

  export type PswProfileUpdateToOneWithWhereWithoutNotesInput = {
    where?: PswProfileWhereInput
    data: XOR<PswProfileUpdateWithoutNotesInput, PswProfileUncheckedUpdateWithoutNotesInput>
  }

  export type PswProfileUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPswProfileNestedInput
    documents?: PswDocumentUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutPswProfileNestedInput
    checklists?: VisitChecklistUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutPswNestedInput
  }

  export type PswProfileUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PswDocumentUncheckedUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutPswProfileNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUncheckedUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutPswNestedInput
  }

  export type VisitCreateWithoutChecklistsInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutVisitsInput
    service: ServiceCreateNestedOneWithoutVisitsInput
    psw?: PswProfileCreateNestedOneWithoutAssignedVisitsInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutVisitInput
    notes?: VisitNoteCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutChecklistsInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemUncheckedCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutChecklistsInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutChecklistsInput, VisitUncheckedCreateWithoutChecklistsInput>
  }

  export type PswProfileCreateWithoutChecklistsInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPswProfileInput
    documents?: PswDocumentCreateNestedManyWithoutPswInput
    assignedVisits?: VisitCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteCreateNestedManyWithoutPswInput
    timesheets?: TimesheetCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadCreateNestedManyWithoutPswInput
  }

  export type PswProfileUncheckedCreateWithoutChecklistsInput = {
    id?: string
    userId: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PswDocumentUncheckedCreateNestedManyWithoutPswInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutPswInput
    timesheets?: TimesheetUncheckedCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutPswInput
  }

  export type PswProfileCreateOrConnectWithoutChecklistsInput = {
    where: PswProfileWhereUniqueInput
    create: XOR<PswProfileCreateWithoutChecklistsInput, PswProfileUncheckedCreateWithoutChecklistsInput>
  }

  export type VisitUpsertWithoutChecklistsInput = {
    update: XOR<VisitUpdateWithoutChecklistsInput, VisitUncheckedUpdateWithoutChecklistsInput>
    create: XOR<VisitCreateWithoutChecklistsInput, VisitUncheckedCreateWithoutChecklistsInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutChecklistsInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutChecklistsInput, VisitUncheckedUpdateWithoutChecklistsInput>
  }

  export type VisitUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutVisitsNestedInput
    service?: ServiceUpdateOneRequiredWithoutVisitsNestedInput
    psw?: PswProfileUpdateOneWithoutAssignedVisitsNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type PswProfileUpsertWithoutChecklistsInput = {
    update: XOR<PswProfileUpdateWithoutChecklistsInput, PswProfileUncheckedUpdateWithoutChecklistsInput>
    create: XOR<PswProfileCreateWithoutChecklistsInput, PswProfileUncheckedCreateWithoutChecklistsInput>
    where?: PswProfileWhereInput
  }

  export type PswProfileUpdateToOneWithWhereWithoutChecklistsInput = {
    where?: PswProfileWhereInput
    data: XOR<PswProfileUpdateWithoutChecklistsInput, PswProfileUncheckedUpdateWithoutChecklistsInput>
  }

  export type PswProfileUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPswProfileNestedInput
    documents?: PswDocumentUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutPswNestedInput
  }

  export type PswProfileUncheckedUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PswDocumentUncheckedUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUncheckedUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutPswNestedInput
  }

  export type VisitCreateWithoutIncidentsInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutVisitsInput
    service: ServiceCreateNestedOneWithoutVisitsInput
    psw?: PswProfileCreateNestedOneWithoutAssignedVisitsInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutVisitInput
    notes?: VisitNoteCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutIncidentsInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemUncheckedCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutIncidentsInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutIncidentsInput, VisitUncheckedCreateWithoutIncidentsInput>
  }

  export type UserCreateWithoutReportedIncidentsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutReportedIncidentsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutReportedIncidentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedIncidentsInput, UserUncheckedCreateWithoutReportedIncidentsInput>
  }

  export type VisitUpsertWithoutIncidentsInput = {
    update: XOR<VisitUpdateWithoutIncidentsInput, VisitUncheckedUpdateWithoutIncidentsInput>
    create: XOR<VisitCreateWithoutIncidentsInput, VisitUncheckedCreateWithoutIncidentsInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutIncidentsInput, VisitUncheckedUpdateWithoutIncidentsInput>
  }

  export type VisitUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutVisitsNestedInput
    service?: ServiceUpdateOneRequiredWithoutVisitsNestedInput
    psw?: PswProfileUpdateOneWithoutAssignedVisitsNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type UserUpsertWithoutReportedIncidentsInput = {
    update: XOR<UserUpdateWithoutReportedIncidentsInput, UserUncheckedUpdateWithoutReportedIncidentsInput>
    create: XOR<UserCreateWithoutReportedIncidentsInput, UserUncheckedCreateWithoutReportedIncidentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedIncidentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedIncidentsInput, UserUncheckedUpdateWithoutReportedIncidentsInput>
  }

  export type UserUpdateWithoutReportedIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type PswProfileCreateWithoutTimesheetsInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPswProfileInput
    documents?: PswDocumentCreateNestedManyWithoutPswInput
    assignedVisits?: VisitCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadCreateNestedManyWithoutPswInput
  }

  export type PswProfileUncheckedCreateWithoutTimesheetsInput = {
    id?: string
    userId: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PswDocumentUncheckedCreateNestedManyWithoutPswInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutPswInput
  }

  export type PswProfileCreateOrConnectWithoutTimesheetsInput = {
    where: PswProfileWhereUniqueInput
    create: XOR<PswProfileCreateWithoutTimesheetsInput, PswProfileUncheckedCreateWithoutTimesheetsInput>
  }

  export type UserCreateWithoutReviewedTimesheetsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutReviewedTimesheetsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutReviewedTimesheetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedTimesheetsInput, UserUncheckedCreateWithoutReviewedTimesheetsInput>
  }

  export type TimesheetItemCreateWithoutTimesheetInput = {
    id?: string
    minutes: number
    createdAt?: Date | string
    visit: VisitCreateNestedOneWithoutTimesheetItemsInput
  }

  export type TimesheetItemUncheckedCreateWithoutTimesheetInput = {
    id?: string
    visitId: string
    minutes: number
    createdAt?: Date | string
  }

  export type TimesheetItemCreateOrConnectWithoutTimesheetInput = {
    where: TimesheetItemWhereUniqueInput
    create: XOR<TimesheetItemCreateWithoutTimesheetInput, TimesheetItemUncheckedCreateWithoutTimesheetInput>
  }

  export type TimesheetItemCreateManyTimesheetInputEnvelope = {
    data: TimesheetItemCreateManyTimesheetInput | TimesheetItemCreateManyTimesheetInput[]
    skipDuplicates?: boolean
  }

  export type PswProfileUpsertWithoutTimesheetsInput = {
    update: XOR<PswProfileUpdateWithoutTimesheetsInput, PswProfileUncheckedUpdateWithoutTimesheetsInput>
    create: XOR<PswProfileCreateWithoutTimesheetsInput, PswProfileUncheckedCreateWithoutTimesheetsInput>
    where?: PswProfileWhereInput
  }

  export type PswProfileUpdateToOneWithWhereWithoutTimesheetsInput = {
    where?: PswProfileWhereInput
    data: XOR<PswProfileUpdateWithoutTimesheetsInput, PswProfileUncheckedUpdateWithoutTimesheetsInput>
  }

  export type PswProfileUpdateWithoutTimesheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPswProfileNestedInput
    documents?: PswDocumentUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutPswNestedInput
  }

  export type PswProfileUncheckedUpdateWithoutTimesheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PswDocumentUncheckedUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutPswNestedInput
  }

  export type UserUpsertWithoutReviewedTimesheetsInput = {
    update: XOR<UserUpdateWithoutReviewedTimesheetsInput, UserUncheckedUpdateWithoutReviewedTimesheetsInput>
    create: XOR<UserCreateWithoutReviewedTimesheetsInput, UserUncheckedCreateWithoutReviewedTimesheetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedTimesheetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedTimesheetsInput, UserUncheckedUpdateWithoutReviewedTimesheetsInput>
  }

  export type UserUpdateWithoutReviewedTimesheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedTimesheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type TimesheetItemUpsertWithWhereUniqueWithoutTimesheetInput = {
    where: TimesheetItemWhereUniqueInput
    update: XOR<TimesheetItemUpdateWithoutTimesheetInput, TimesheetItemUncheckedUpdateWithoutTimesheetInput>
    create: XOR<TimesheetItemCreateWithoutTimesheetInput, TimesheetItemUncheckedCreateWithoutTimesheetInput>
  }

  export type TimesheetItemUpdateWithWhereUniqueWithoutTimesheetInput = {
    where: TimesheetItemWhereUniqueInput
    data: XOR<TimesheetItemUpdateWithoutTimesheetInput, TimesheetItemUncheckedUpdateWithoutTimesheetInput>
  }

  export type TimesheetItemUpdateManyWithWhereWithoutTimesheetInput = {
    where: TimesheetItemScalarWhereInput
    data: XOR<TimesheetItemUpdateManyMutationInput, TimesheetItemUncheckedUpdateManyWithoutTimesheetInput>
  }

  export type TimesheetCreateWithoutItemsInput = {
    id?: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    psw: PswProfileCreateNestedOneWithoutTimesheetsInput
    reviewer?: UserCreateNestedOneWithoutReviewedTimesheetsInput
  }

  export type TimesheetUncheckedCreateWithoutItemsInput = {
    id?: string
    pswId: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimesheetCreateOrConnectWithoutItemsInput = {
    where: TimesheetWhereUniqueInput
    create: XOR<TimesheetCreateWithoutItemsInput, TimesheetUncheckedCreateWithoutItemsInput>
  }

  export type VisitCreateWithoutTimesheetItemsInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutVisitsInput
    service: ServiceCreateNestedOneWithoutVisitsInput
    psw?: PswProfileCreateNestedOneWithoutAssignedVisitsInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutVisitInput
    notes?: VisitNoteCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutTimesheetItemsInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutTimesheetItemsInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutTimesheetItemsInput, VisitUncheckedCreateWithoutTimesheetItemsInput>
  }

  export type TimesheetUpsertWithoutItemsInput = {
    update: XOR<TimesheetUpdateWithoutItemsInput, TimesheetUncheckedUpdateWithoutItemsInput>
    create: XOR<TimesheetCreateWithoutItemsInput, TimesheetUncheckedCreateWithoutItemsInput>
    where?: TimesheetWhereInput
  }

  export type TimesheetUpdateToOneWithWhereWithoutItemsInput = {
    where?: TimesheetWhereInput
    data: XOR<TimesheetUpdateWithoutItemsInput, TimesheetUncheckedUpdateWithoutItemsInput>
  }

  export type TimesheetUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    psw?: PswProfileUpdateOneRequiredWithoutTimesheetsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedTimesheetsNestedInput
  }

  export type TimesheetUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUpsertWithoutTimesheetItemsInput = {
    update: XOR<VisitUpdateWithoutTimesheetItemsInput, VisitUncheckedUpdateWithoutTimesheetItemsInput>
    create: XOR<VisitCreateWithoutTimesheetItemsInput, VisitUncheckedCreateWithoutTimesheetItemsInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutTimesheetItemsInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutTimesheetItemsInput, VisitUncheckedUpdateWithoutTimesheetItemsInput>
  }

  export type VisitUpdateWithoutTimesheetItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutVisitsNestedInput
    service?: ServiceUpdateOneRequiredWithoutVisitsNestedInput
    psw?: PswProfileUpdateOneWithoutAssignedVisitsNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutTimesheetItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type ClientProfileCreateWithoutInvoicesInput = {
    id?: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    visits?: VisitCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutInvoicesInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutInvoicesInput, ClientProfileUncheckedCreateWithoutInvoicesInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    stripePaymentIntentId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    stripePaymentIntentId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type ClientProfileUpsertWithoutInvoicesInput = {
    update: XOR<ClientProfileUpdateWithoutInvoicesInput, ClientProfileUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ClientProfileCreateWithoutInvoicesInput, ClientProfileUncheckedCreateWithoutInvoicesInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutInvoicesInput, ClientProfileUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClientProfileUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    visits?: VisitUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    status?: $Enums.InvoiceStatus | null
    currency?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string | null
    tax?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    clientId: string
    status?: $Enums.InvoiceStatus | null
    currency?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string | null
    tax?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileCreateWithoutMessageThreadsInput = {
    id?: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    visits?: VisitCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutMessageThreadsInput = {
    id?: string
    userId: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutMessageThreadsInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutMessageThreadsInput, ClientProfileUncheckedCreateWithoutMessageThreadsInput>
  }

  export type PswProfileCreateWithoutMessageThreadsInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPswProfileInput
    documents?: PswDocumentCreateNestedManyWithoutPswInput
    assignedVisits?: VisitCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistCreateNestedManyWithoutPswInput
    timesheets?: TimesheetCreateNestedManyWithoutPswInput
  }

  export type PswProfileUncheckedCreateWithoutMessageThreadsInput = {
    id?: string
    userId: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PswDocumentUncheckedCreateNestedManyWithoutPswInput
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutPswInput
    timesheets?: TimesheetUncheckedCreateNestedManyWithoutPswInput
  }

  export type PswProfileCreateOrConnectWithoutMessageThreadsInput = {
    where: PswProfileWhereUniqueInput
    create: XOR<PswProfileCreateWithoutMessageThreadsInput, PswProfileUncheckedCreateWithoutMessageThreadsInput>
  }

  export type MessageCreateWithoutThreadInput = {
    id?: string
    bodyText: string
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutThreadInput = {
    id?: string
    senderUserId: string
    bodyText: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutThreadInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput>
  }

  export type MessageCreateManyThreadInputEnvelope = {
    data: MessageCreateManyThreadInput | MessageCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type ClientProfileUpsertWithoutMessageThreadsInput = {
    update: XOR<ClientProfileUpdateWithoutMessageThreadsInput, ClientProfileUncheckedUpdateWithoutMessageThreadsInput>
    create: XOR<ClientProfileCreateWithoutMessageThreadsInput, ClientProfileUncheckedCreateWithoutMessageThreadsInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutMessageThreadsInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutMessageThreadsInput, ClientProfileUncheckedUpdateWithoutMessageThreadsInput>
  }

  export type ClientProfileUpdateWithoutMessageThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    visits?: VisitUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutMessageThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type PswProfileUpsertWithoutMessageThreadsInput = {
    update: XOR<PswProfileUpdateWithoutMessageThreadsInput, PswProfileUncheckedUpdateWithoutMessageThreadsInput>
    create: XOR<PswProfileCreateWithoutMessageThreadsInput, PswProfileUncheckedCreateWithoutMessageThreadsInput>
    where?: PswProfileWhereInput
  }

  export type PswProfileUpdateToOneWithWhereWithoutMessageThreadsInput = {
    where?: PswProfileWhereInput
    data: XOR<PswProfileUpdateWithoutMessageThreadsInput, PswProfileUncheckedUpdateWithoutMessageThreadsInput>
  }

  export type PswProfileUpdateWithoutMessageThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPswProfileNestedInput
    documents?: PswDocumentUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUpdateManyWithoutPswNestedInput
  }

  export type PswProfileUncheckedUpdateWithoutMessageThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PswDocumentUncheckedUpdateManyWithoutPswNestedInput
    assignedVisits?: VisitUncheckedUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUncheckedUpdateManyWithoutPswNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutThreadInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutThreadInput, MessageUncheckedUpdateWithoutThreadInput>
    create: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutThreadInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutThreadInput, MessageUncheckedUpdateWithoutThreadInput>
  }

  export type MessageUpdateManyWithWhereWithoutThreadInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutThreadInput>
  }

  export type MessageThreadCreateWithoutMessagesInput = {
    id?: string
    threadType: string
    createdAt?: Date | string
    client?: ClientProfileCreateNestedOneWithoutMessageThreadsInput
    psw?: PswProfileCreateNestedOneWithoutMessageThreadsInput
  }

  export type MessageThreadUncheckedCreateWithoutMessagesInput = {
    id?: string
    threadType: string
    clientId?: string | null
    pswId?: string | null
    createdAt?: Date | string
  }

  export type MessageThreadCreateOrConnectWithoutMessagesInput = {
    where: MessageThreadWhereUniqueInput
    create: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type MessageThreadUpsertWithoutMessagesInput = {
    update: XOR<MessageThreadUpdateWithoutMessagesInput, MessageThreadUncheckedUpdateWithoutMessagesInput>
    create: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    where?: MessageThreadWhereInput
  }

  export type MessageThreadUpdateToOneWithWhereWithoutMessagesInput = {
    where?: MessageThreadWhereInput
    data: XOR<MessageThreadUpdateWithoutMessagesInput, MessageThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageThreadUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneWithoutMessageThreadsNestedInput
    psw?: PswProfileUpdateOneWithoutMessageThreadsNestedInput
  }

  export type MessageThreadUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    pswId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type UserCreateWithoutBlogPostsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
  }

  export type UserUpsertWithoutBlogPostsInput = {
    update: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type PswProfileCreateWithoutDocumentsInput = {
    id?: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPswProfileInput
    assignedVisits?: VisitCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistCreateNestedManyWithoutPswInput
    timesheets?: TimesheetCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadCreateNestedManyWithoutPswInput
  }

  export type PswProfileUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    fullName: string
    bio?: string | null
    languages?: PswProfileCreatelanguagesInput | string[]
    serviceAreas?: PswProfileCreateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedVisits?: VisitUncheckedCreateNestedManyWithoutPswInput
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutPswProfileInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutPswInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutPswInput
    timesheets?: TimesheetUncheckedCreateNestedManyWithoutPswInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutPswInput
  }

  export type PswProfileCreateOrConnectWithoutDocumentsInput = {
    where: PswProfileWhereUniqueInput
    create: XOR<PswProfileCreateWithoutDocumentsInput, PswProfileUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutVerifiedDocsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutVerifiedDocsInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
    DailyEntry?: DailyEntryUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutVerifiedDocsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedDocsInput, UserUncheckedCreateWithoutVerifiedDocsInput>
  }

  export type PswProfileUpsertWithoutDocumentsInput = {
    update: XOR<PswProfileUpdateWithoutDocumentsInput, PswProfileUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PswProfileCreateWithoutDocumentsInput, PswProfileUncheckedCreateWithoutDocumentsInput>
    where?: PswProfileWhereInput
  }

  export type PswProfileUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PswProfileWhereInput
    data: XOR<PswProfileUpdateWithoutDocumentsInput, PswProfileUncheckedUpdateWithoutDocumentsInput>
  }

  export type PswProfileUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPswProfileNestedInput
    assignedVisits?: VisitUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutPswNestedInput
  }

  export type PswProfileUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: PswProfileUpdatelanguagesInput | string[]
    serviceAreas?: PswProfileUpdateserviceAreasInput | string[]
    availability?: NullableJsonNullValueInput | InputJsonValue
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedVisits?: VisitUncheckedUpdateManyWithoutPswNestedInput
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutPswProfileNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutPswNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutPswNestedInput
    timesheets?: TimesheetUncheckedUpdateManyWithoutPswNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutPswNestedInput
  }

  export type UserUpsertWithoutVerifiedDocsInput = {
    update: XOR<UserUpdateWithoutVerifiedDocsInput, UserUncheckedUpdateWithoutVerifiedDocsInput>
    create: XOR<UserCreateWithoutVerifiedDocsInput, UserUncheckedCreateWithoutVerifiedDocsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifiedDocsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifiedDocsInput, UserUncheckedUpdateWithoutVerifiedDocsInput>
  }

  export type UserUpdateWithoutVerifiedDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ClientProfileCreateWithoutDailyEntryInput = {
    id?: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    visits?: VisitCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutDailyEntryInput = {
    id?: string
    userId: string
    fullName: string
    dob?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    province?: string | null
    postalCode?: string | null
    lat?: number | null
    lng?: number | null
    emergencyName?: string | null
    emergencyPhone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: VisitUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    messageThreads?: MessageThreadUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutDailyEntryInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutDailyEntryInput, ClientProfileUncheckedCreateWithoutDailyEntryInput>
  }

  export type UserCreateWithoutDailyEntryInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventCreateNestedManyWithoutOverriddenByInput
  }

  export type UserUncheckedCreateWithoutDailyEntryInput = {
    id?: string
    role: $Enums.Role
    email: string
    phone?: string | null
    passwordHash: string
    status?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    pswProfile?: PswProfileUncheckedCreateNestedOneWithoutUserInput
    verifiedDocs?: PswDocumentUncheckedCreateNestedManyWithoutVerifierInput
    reportedIncidents?: IncidentUncheckedCreateNestedManyWithoutReporterInput
    reviewedTimesheets?: TimesheetUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    VisitCheckEvent?: VisitCheckEventUncheckedCreateNestedManyWithoutOverriddenByInput
  }

  export type UserCreateOrConnectWithoutDailyEntryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyEntryInput, UserUncheckedCreateWithoutDailyEntryInput>
  }

  export type VisitCreateWithoutDailyEntryInput = {
    id?: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutVisitsInput
    service: ServiceCreateNestedOneWithoutVisitsInput
    psw?: PswProfileCreateNestedOneWithoutAssignedVisitsInput
    checkEvents?: VisitCheckEventCreateNestedManyWithoutVisitInput
    notes?: VisitNoteCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistCreateNestedManyWithoutVisitInput
    incidents?: IncidentCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemCreateNestedManyWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutDailyEntryInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkEvents?: VisitCheckEventUncheckedCreateNestedManyWithoutVisitInput
    notes?: VisitNoteUncheckedCreateNestedManyWithoutVisitInput
    checklists?: VisitChecklistUncheckedCreateNestedManyWithoutVisitInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutVisitInput
    timesheetItems?: TimesheetItemUncheckedCreateNestedManyWithoutVisitInput
  }

  export type VisitCreateOrConnectWithoutDailyEntryInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutDailyEntryInput, VisitUncheckedCreateWithoutDailyEntryInput>
  }

  export type ClientProfileUpsertWithoutDailyEntryInput = {
    update: XOR<ClientProfileUpdateWithoutDailyEntryInput, ClientProfileUncheckedUpdateWithoutDailyEntryInput>
    create: XOR<ClientProfileCreateWithoutDailyEntryInput, ClientProfileUncheckedCreateWithoutDailyEntryInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutDailyEntryInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutDailyEntryInput, ClientProfileUncheckedUpdateWithoutDailyEntryInput>
  }

  export type ClientProfileUpdateWithoutDailyEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    visits?: VisitUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutDailyEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: VisitUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    messageThreads?: MessageThreadUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutDailyEntryInput = {
    update: XOR<UserUpdateWithoutDailyEntryInput, UserUncheckedUpdateWithoutDailyEntryInput>
    create: XOR<UserCreateWithoutDailyEntryInput, UserUncheckedCreateWithoutDailyEntryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyEntryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyEntryInput, UserUncheckedUpdateWithoutDailyEntryInput>
  }

  export type UserUpdateWithoutDailyEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUpdateManyWithoutOverriddenByNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    pswProfile?: PswProfileUncheckedUpdateOneWithoutUserNestedInput
    verifiedDocs?: PswDocumentUncheckedUpdateManyWithoutVerifierNestedInput
    reportedIncidents?: IncidentUncheckedUpdateManyWithoutReporterNestedInput
    reviewedTimesheets?: TimesheetUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    VisitCheckEvent?: VisitCheckEventUncheckedUpdateManyWithoutOverriddenByNestedInput
  }

  export type VisitUpsertWithoutDailyEntryInput = {
    update: XOR<VisitUpdateWithoutDailyEntryInput, VisitUncheckedUpdateWithoutDailyEntryInput>
    create: XOR<VisitCreateWithoutDailyEntryInput, VisitUncheckedCreateWithoutDailyEntryInput>
    where?: VisitWhereInput
  }

  export type VisitUpdateToOneWithWhereWithoutDailyEntryInput = {
    where?: VisitWhereInput
    data: XOR<VisitUpdateWithoutDailyEntryInput, VisitUncheckedUpdateWithoutDailyEntryInput>
  }

  export type VisitUpdateWithoutDailyEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutVisitsNestedInput
    service?: ServiceUpdateOneRequiredWithoutVisitsNestedInput
    psw?: PswProfileUpdateOneWithoutAssignedVisitsNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutDailyEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type PswDocumentCreateManyVerifierInput = {
    id?: string
    pswId: string
    docType: string
    fileKey: string
    status?: $Enums.DocStatus | null
    expiryDate?: Date | string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateManyReporterInput = {
    id?: string
    visitId?: string | null
    type: $Enums.IncidentType
    description: string
    status?: $Enums.IncidentStatus | null
    resolutionNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimesheetCreateManyReviewerInput = {
    id?: string
    pswId: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    threadId: string
    bodyText: string
    createdAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: string
    action: string
    resourceType: string
    resourceId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type BlogPostCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt?: string | null
    contentHtml?: string | null
    status?: string | null
    publishedAt?: Date | string | null
    featureImageDocId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    canonicalUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCheckEventCreateManyOverriddenByInput = {
    id?: string
    visitId: string
    pswId: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideReason?: string | null
    createdAt?: Date | string
  }

  export type DailyEntryCreateManyStaffInput = {
    id?: string
    clientId: string
    visitId?: string | null
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PswDocumentUpdateWithoutVerifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    psw?: PswProfileUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type PswDocumentUncheckedUpdateWithoutVerifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PswDocumentUncheckedUpdateManyWithoutVerifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneWithoutIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    psw?: PswProfileUpdateOneRequiredWithoutTimesheetsNestedInput
    items?: TimesheetItemUpdateManyWithoutTimesheetNestedInput
  }

  export type TimesheetUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TimesheetItemUncheckedUpdateManyWithoutTimesheetNestedInput
  }

  export type TimesheetUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    contentHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureImageDocId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    contentHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureImageDocId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    contentHtml?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureImageDocId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCheckEventUpdateWithoutOverriddenByInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutCheckEventsNestedInput
    pswProfile?: PswProfileUpdateOneRequiredWithoutCheckEventsNestedInput
  }

  export type VisitCheckEventUncheckedUpdateWithoutOverriddenByInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCheckEventUncheckedUpdateManyWithoutOverriddenByInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutDailyEntryNestedInput
    visit?: VisitUpdateOneWithoutDailyEntryNestedInput
  }

  export type DailyEntryUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateManyClientInput = {
    id?: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyClientInput = {
    id?: string
    status?: $Enums.InvoiceStatus | null
    currency?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string | null
    tax?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageThreadCreateManyClientInput = {
    id?: string
    threadType: string
    pswId?: string | null
    createdAt?: Date | string
  }

  export type DailyEntryCreateManyClientInput = {
    id?: string
    staffId: string
    visitId?: string | null
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutVisitsNestedInput
    psw?: PswProfileUpdateOneWithoutAssignedVisitsNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    psw?: PswProfileUpdateOneWithoutMessageThreadsNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    pswId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    pswId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: UserUpdateOneRequiredWithoutDailyEntryNestedInput
    visit?: VisitUpdateOneWithoutDailyEntryNestedInput
  }

  export type DailyEntryUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PswDocumentCreateManyPswInput = {
    id?: string
    docType: string
    fileKey: string
    status?: $Enums.DocStatus | null
    expiryDate?: Date | string | null
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCreateManyPswInput = {
    id?: string
    clientId: string
    serviceId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCheckEventCreateManyPswProfileInput = {
    id?: string
    visitId: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideByUserId?: string | null
    overrideReason?: string | null
    createdAt?: Date | string
  }

  export type VisitNoteCreateManyPswInput = {
    id?: string
    visitId: string
    noteText: string
    createdAt?: Date | string
  }

  export type VisitChecklistCreateManyPswInput = {
    id?: string
    visitId: string
    checklistJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TimesheetCreateManyPswInput = {
    id?: string
    weekId: string
    totalMinutes?: number | null
    status?: $Enums.TimesheetStatus | null
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageThreadCreateManyPswInput = {
    id?: string
    threadType: string
    clientId?: string | null
    createdAt?: Date | string
  }

  export type PswDocumentUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifier?: UserUpdateOneWithoutVerifiedDocsNestedInput
  }

  export type PswDocumentUncheckedUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PswDocumentUncheckedUpdateManyWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutVisitsNestedInput
    service?: ServiceUpdateOneRequiredWithoutVisitsNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateManyWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCheckEventUpdateWithoutPswProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutCheckEventsNestedInput
    overriddenBy?: UserUpdateOneWithoutVisitCheckEventNestedInput
  }

  export type VisitCheckEventUncheckedUpdateWithoutPswProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCheckEventUncheckedUpdateManyWithoutPswProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitNoteUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutNotesNestedInput
  }

  export type VisitNoteUncheckedUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitNoteUncheckedUpdateManyWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitChecklistUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutChecklistsNestedInput
  }

  export type VisitChecklistUncheckedUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitChecklistUncheckedUpdateManyWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneWithoutReviewedTimesheetsNestedInput
    items?: TimesheetItemUpdateManyWithoutTimesheetNestedInput
  }

  export type TimesheetUncheckedUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TimesheetItemUncheckedUpdateManyWithoutTimesheetNestedInput
  }

  export type TimesheetUncheckedUpdateManyWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    totalMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumTimesheetStatusFieldUpdateOperationsInput | $Enums.TimesheetStatus | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneWithoutMessageThreadsNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateManyWithoutPswInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCheckEventCreateManyVisitInput = {
    id?: string
    pswId: string
    eventType: $Enums.EventType
    lat?: number | null
    lng?: number | null
    accuracyM?: number | null
    computedDistanceM?: number | null
    deviceTimeIso?: Date | string | null
    serverTime?: Date | string | null
    result: $Enums.EventResult
    rejectReason?: string | null
    isOverride?: boolean | null
    overrideByUserId?: string | null
    overrideReason?: string | null
    createdAt?: Date | string
  }

  export type VisitNoteCreateManyVisitInput = {
    id?: string
    pswId: string
    noteText: string
    createdAt?: Date | string
  }

  export type VisitChecklistCreateManyVisitInput = {
    id?: string
    pswId: string
    checklistJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IncidentCreateManyVisitInput = {
    id?: string
    reporterUserId: string
    type: $Enums.IncidentType
    description: string
    status?: $Enums.IncidentStatus | null
    resolutionNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimesheetItemCreateManyVisitInput = {
    id?: string
    timesheetId: string
    minutes: number
    createdAt?: Date | string
  }

  export type DailyEntryCreateManyVisitInput = {
    id?: string
    clientId: string
    staffId: string
    adlData: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    signature?: string | null
    status?: $Enums.DailyEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCheckEventUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pswProfile?: PswProfileUpdateOneRequiredWithoutCheckEventsNestedInput
    overriddenBy?: UserUpdateOneWithoutVisitCheckEventNestedInput
  }

  export type VisitCheckEventUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCheckEventUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    accuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    computedDistanceM?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceTimeIso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumEventResultFieldUpdateOperationsInput | $Enums.EventResult
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    isOverride?: NullableBoolFieldUpdateOperationsInput | boolean | null
    overrideByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitNoteUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    psw?: PswProfileUpdateOneRequiredWithoutNotesNestedInput
  }

  export type VisitNoteUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitNoteUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    noteText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitChecklistUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    psw?: PswProfileUpdateOneRequiredWithoutChecklistsNestedInput
  }

  export type VisitChecklistUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitChecklistUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    pswId?: StringFieldUpdateOperationsInput | string
    checklistJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportedIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumIncidentTypeFieldUpdateOperationsInput | $Enums.IncidentType
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus | null
    resolutionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetItemUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timesheet?: TimesheetUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TimesheetItemUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    timesheetId?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetItemUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    timesheetId?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutDailyEntryNestedInput
    staff?: UserUpdateOneRequiredWithoutDailyEntryNestedInput
  }

  export type DailyEntryUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    adlData?: JsonNullValueInput | InputJsonValue
    medication?: NullableJsonNullValueInput | InputJsonValue
    mood?: NullableIntFieldUpdateOperationsInput | number | null
    vitals?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDailyEntryStatusFieldUpdateOperationsInput | $Enums.DailyEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateManyServiceInput = {
    id?: string
    clientId: string
    requestedStartAt: Date | string
    durationMinutes: number
    status?: $Enums.VisitStatus | null
    assignedPswId?: string | null
    serviceAddressLine1?: string | null
    serviceAddressLine2?: string | null
    serviceCity?: string | null
    serviceProvince?: string | null
    servicePostalCode?: string | null
    serviceLat?: number | null
    serviceLng?: number | null
    clientNotes?: string | null
    coordinatorNotes?: string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutVisitsNestedInput
    psw?: PswProfileUpdateOneWithoutAssignedVisitsNestedInput
    checkEvents?: VisitCheckEventUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkEvents?: VisitCheckEventUncheckedUpdateManyWithoutVisitNestedInput
    notes?: VisitNoteUncheckedUpdateManyWithoutVisitNestedInput
    checklists?: VisitChecklistUncheckedUpdateManyWithoutVisitNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutVisitNestedInput
    timesheetItems?: TimesheetItemUncheckedUpdateManyWithoutVisitNestedInput
    DailyEntry?: DailyEntryUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type VisitUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    requestedStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus | null
    assignedPswId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    serviceAddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCity?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvince?: NullableStringFieldUpdateOperationsInput | string | null
    servicePostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    serviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clientNotes?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetItemCreateManyTimesheetInput = {
    id?: string
    visitId: string
    minutes: number
    createdAt?: Date | string
  }

  export type TimesheetItemUpdateWithoutTimesheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: VisitUpdateOneRequiredWithoutTimesheetItemsNestedInput
  }

  export type TimesheetItemUncheckedUpdateWithoutTimesheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimesheetItemUncheckedUpdateManyWithoutTimesheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    stripePaymentIntentId?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyThreadInput = {
    id?: string
    senderUserId: string
    bodyText: string
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderUserId?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderUserId?: StringFieldUpdateOperationsInput | string
    bodyText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientProfileCountOutputTypeDefaultArgs instead
     */
    export type ClientProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PswProfileCountOutputTypeDefaultArgs instead
     */
    export type PswProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PswProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitCountOutputTypeDefaultArgs instead
     */
    export type VisitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimesheetCountOutputTypeDefaultArgs instead
     */
    export type TimesheetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimesheetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageThreadCountOutputTypeDefaultArgs instead
     */
    export type MessageThreadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientProfileDefaultArgs instead
     */
    export type ClientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PswProfileDefaultArgs instead
     */
    export type PswProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PswProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitDefaultArgs instead
     */
    export type VisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitCheckEventDefaultArgs instead
     */
    export type VisitCheckEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitCheckEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitNoteDefaultArgs instead
     */
    export type VisitNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitChecklistDefaultArgs instead
     */
    export type VisitChecklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitChecklistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentDefaultArgs instead
     */
    export type IncidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimesheetDefaultArgs instead
     */
    export type TimesheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimesheetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimesheetItemDefaultArgs instead
     */
    export type TimesheetItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimesheetItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageThreadDefaultArgs instead
     */
    export type MessageThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageThreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadDefaultArgs instead
     */
    export type LeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostDefaultArgs instead
     */
    export type BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PswDocumentDefaultArgs instead
     */
    export type PswDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PswDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FAQDefaultArgs instead
     */
    export type FAQArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FAQDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyEntryDefaultArgs instead
     */
    export type DailyEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyEntryDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}